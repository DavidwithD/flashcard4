import "./chunk-UXIASGQL.js";

// ../../node_modules/compromise/src/API/world.js
var methods = {
  one: {},
  two: {},
  three: {},
  four: {}
};
var model = {
  one: {},
  two: {},
  three: {}
};
var compute = {};
var hooks = [];
var world_default = { methods, model, compute, hooks };

// ../../node_modules/compromise/src/API/methods/compute.js
var isArray = (input) => Object.prototype.toString.call(input) === "[object Array]";
var fns = {
  /** add metadata to term objects */
  compute: function(input) {
    const { world: world2 } = this;
    const compute4 = world2.compute;
    if (typeof input === "string" && compute4.hasOwnProperty(input)) {
      compute4[input](this);
    } else if (isArray(input)) {
      input.forEach((name) => {
        if (world2.compute.hasOwnProperty(name)) {
          compute4[name](this);
        } else {
          console.warn("no compute:", input);
        }
      });
    } else if (typeof input === "function") {
      input(this);
    } else {
      console.warn("no compute:", input);
    }
    return this;
  }
};
var compute_default = fns;

// ../../node_modules/compromise/src/API/methods/loops.js
var forEach = function(cb) {
  let ptrs = this.fullPointer;
  ptrs.forEach((ptr, i3) => {
    let view = this.update([ptr]);
    cb(view, i3);
  });
  return this;
};
var map = function(cb, empty) {
  let ptrs = this.fullPointer;
  let res = ptrs.map((ptr, i3) => {
    let view = this.update([ptr]);
    let out2 = cb(view, i3);
    if (out2 === void 0) {
      return this.none();
    }
    return out2;
  });
  if (res.length === 0) {
    return empty || this.update([]);
  }
  if (res[0] !== void 0) {
    if (typeof res[0] === "string") {
      return res;
    }
    if (typeof res[0] === "object" && (res[0] === null || !res[0].isView)) {
      return res;
    }
  }
  let all4 = [];
  res.forEach((ptr) => {
    all4 = all4.concat(ptr.fullPointer);
  });
  return this.toView(all4);
};
var filter = function(cb) {
  let ptrs = this.fullPointer;
  ptrs = ptrs.filter((ptr, i3) => {
    let view = this.update([ptr]);
    return cb(view, i3);
  });
  let res = this.update(ptrs);
  return res;
};
var find = function(cb) {
  let ptrs = this.fullPointer;
  let found = ptrs.find((ptr, i3) => {
    let view = this.update([ptr]);
    return cb(view, i3);
  });
  return this.update([found]);
};
var some = function(cb) {
  let ptrs = this.fullPointer;
  return ptrs.some((ptr, i3) => {
    let view = this.update([ptr]);
    return cb(view, i3);
  });
};
var random = function(n3 = 1) {
  let ptrs = this.fullPointer;
  let r2 = Math.floor(Math.random() * ptrs.length);
  if (r2 + n3 > this.length) {
    r2 = this.length - n3;
    r2 = r2 < 0 ? 0 : r2;
  }
  ptrs = ptrs.slice(r2, r2 + n3);
  return this.update(ptrs);
};
var loops_default = { forEach, map, filter, find, some, random };

// ../../node_modules/compromise/src/API/methods/utils.js
var utils = {
  /** */
  termList: function() {
    return this.methods.one.termList(this.docs);
  },
  /** return individual terms*/
  terms: function(n3) {
    let m3 = this.match(".");
    return typeof n3 === "number" ? m3.eq(n3) : m3;
  },
  /** */
  groups: function(group) {
    if (group || group === 0) {
      return this.update(this._groups[group] || []);
    }
    let res = {};
    Object.keys(this._groups).forEach((k2) => {
      res[k2] = this.update(this._groups[k2]);
    });
    return res;
  },
  /** */
  eq: function(n3) {
    let ptr = this.pointer;
    if (!ptr) {
      ptr = this.docs.map((_doc, i3) => [i3]);
    }
    if (ptr[n3]) {
      return this.update([ptr[n3]]);
    }
    return this.none();
  },
  /** */
  first: function() {
    return this.eq(0);
  },
  /** */
  last: function() {
    let n3 = this.fullPointer.length - 1;
    return this.eq(n3);
  },
  /** grab term[0] for every match */
  firstTerms: function() {
    return this.match("^.");
  },
  /** grab the last term for every match  */
  lastTerms: function() {
    return this.match(".$");
  },
  /** */
  slice: function(min2, max3) {
    let pntrs = this.pointer || this.docs.map((_o, n3) => [n3]);
    pntrs = pntrs.slice(min2, max3);
    return this.update(pntrs);
  },
  /** return a view of the entire document */
  all: function() {
    return this.update().toView();
  },
  /**  */
  fullSentences: function() {
    let ptrs = this.fullPointer.map((a2) => [a2[0]]);
    return this.update(ptrs).toView();
  },
  /** return a view of no parts of the document */
  none: function() {
    return this.update([]);
  },
  /** are these two views looking at the same words? */
  isDoc: function(b) {
    if (!b || !b.isView) {
      return false;
    }
    let aPtr = this.fullPointer;
    let bPtr = b.fullPointer;
    if (!aPtr.length === bPtr.length) {
      return false;
    }
    return aPtr.every((ptr, i3) => {
      if (!bPtr[i3]) {
        return false;
      }
      return ptr[0] === bPtr[i3][0] && ptr[1] === bPtr[i3][1] && ptr[2] === bPtr[i3][2];
    });
  },
  /** how many seperate terms does the document have? */
  wordCount: function() {
    return this.docs.reduce((count, terms) => {
      count += terms.filter((t3) => t3.text !== "").length;
      return count;
    }, 0);
  },
  // is the pointer the full sentence?
  isFull: function() {
    let ptrs = this.pointer;
    if (!ptrs) {
      return true;
    }
    if (ptrs.length === 0 || ptrs[0][0] !== 0) {
      return false;
    }
    let wantTerms = 0;
    let haveTerms = 0;
    this.document.forEach((terms) => wantTerms += terms.length);
    this.docs.forEach((terms) => haveTerms += terms.length);
    return wantTerms === haveTerms;
  },
  // return the nth elem of a doc
  getNth: function(n3) {
    if (typeof n3 === "number") {
      return this.eq(n3);
    } else if (typeof n3 === "string") {
      return this.if(n3);
    }
    return this;
  }
};
utils.group = utils.groups;
utils.fullSentence = utils.fullSentences;
utils.sentence = utils.fullSentences;
utils.lastTerm = utils.lastTerms;
utils.firstTerm = utils.firstTerms;
var utils_default = utils;

// ../../node_modules/compromise/src/API/methods/index.js
var methods2 = Object.assign({}, utils_default, compute_default, loops_default);
methods2.get = methods2.eq;
var methods_default = methods2;

// ../../node_modules/compromise/src/API/View.js
var View = class _View {
  constructor(document, pointer, groups = {}) {
    [
      ["document", document],
      ["world", world_default],
      ["_groups", groups],
      ["_cache", null],
      ["viewType", "View"]
    ].forEach((a2) => {
      Object.defineProperty(this, a2[0], {
        value: a2[1],
        writable: true
      });
    });
    this.ptrs = pointer;
  }
  /* getters:  */
  get docs() {
    let docs = this.document;
    if (this.ptrs) {
      docs = world_default.methods.one.getDoc(this.ptrs, this.document);
    }
    return docs;
  }
  get pointer() {
    return this.ptrs;
  }
  get methods() {
    return this.world.methods;
  }
  get model() {
    return this.world.model;
  }
  get hooks() {
    return this.world.hooks;
  }
  get isView() {
    return true;
  }
  // is the view not-empty?
  get found() {
    return this.docs.length > 0;
  }
  // how many matches we have
  get length() {
    return this.docs.length;
  }
  // return a more-hackable pointer
  get fullPointer() {
    let { docs, ptrs, document } = this;
    let pointers = ptrs || docs.map((_d, n3) => [n3]);
    return pointers.map((a2) => {
      let [n3, start2, end2, id, endId] = a2;
      start2 = start2 || 0;
      end2 = end2 || (document[n3] || []).length;
      if (document[n3] && document[n3][start2]) {
        id = id || document[n3][start2].id;
        if (document[n3][end2 - 1]) {
          endId = endId || document[n3][end2 - 1].id;
        }
      }
      return [n3, start2, end2, id, endId];
    });
  }
  // create a new View, from this one
  update(pointer) {
    let m3 = new _View(this.document, pointer);
    if (this._cache && pointer && pointer.length > 0) {
      let cache2 = [];
      pointer.forEach((ptr, i3) => {
        let [n3, start2, end2] = ptr;
        if (ptr.length === 1) {
          cache2[i3] = this._cache[n3];
        } else if (start2 === 0 && this.document[n3].length === end2) {
          cache2[i3] = this._cache[n3];
        }
      });
      if (cache2.length > 0) {
        m3._cache = cache2;
      }
    }
    m3.world = this.world;
    return m3;
  }
  // create a new View, from this one
  toView(pointer) {
    return new _View(this.document, pointer || this.pointer);
  }
  fromText(input) {
    const { methods: methods18 } = this;
    let document = methods18.one.tokenize.fromString(input, this.world);
    let doc = new _View(document);
    doc.world = this.world;
    doc.compute(["normal", "lexicon"]);
    if (this.world.compute.preTagger) {
      doc.compute("preTagger");
    }
    return doc;
  }
  clone() {
    let document = this.document.slice(0);
    document = document.map((terms) => {
      return terms.map((term) => {
        term = Object.assign({}, term);
        term.tags = new Set(term.tags);
        return term;
      });
    });
    let m3 = this.update(this.pointer);
    m3.document = document;
    m3._cache = this._cache;
    return m3;
  }
};
Object.assign(View.prototype, methods_default);
var View_default = View;

// ../../node_modules/compromise/src/_version.js
var version_default = "14.10.0";

// ../../node_modules/compromise/src/API/extend.js
var isObject = function(item) {
  return item && typeof item === "object" && !Array.isArray(item);
};
function mergeDeep(model5, plugin5) {
  if (isObject(plugin5)) {
    for (const key in plugin5) {
      if (isObject(plugin5[key])) {
        if (!model5[key])
          Object.assign(model5, { [key]: {} });
        mergeDeep(model5[key], plugin5[key]);
      } else {
        Object.assign(model5, { [key]: plugin5[key] });
      }
    }
  }
  return model5;
}
function mergeQuick(model5, plugin5) {
  for (const key in plugin5) {
    model5[key] = model5[key] || {};
    Object.assign(model5[key], plugin5[key]);
  }
  return model5;
}
var addIrregulars = function(model5, conj) {
  let m3 = model5.two.models || {};
  Object.keys(conj).forEach((k2) => {
    if (conj[k2].pastTense) {
      if (m3.toPast) {
        m3.toPast.ex[k2] = conj[k2].pastTense;
      }
      if (m3.fromPast) {
        m3.fromPast.ex[conj[k2].pastTense] = k2;
      }
    }
    if (conj[k2].presentTense) {
      if (m3.toPresent) {
        m3.toPresent.ex[k2] = conj[k2].presentTense;
      }
      if (m3.fromPresent) {
        m3.fromPresent.ex[conj[k2].presentTense] = k2;
      }
    }
    if (conj[k2].gerund) {
      if (m3.toGerund) {
        m3.toGerund.ex[k2] = conj[k2].gerund;
      }
      if (m3.fromGerund) {
        m3.fromGerund.ex[conj[k2].gerund] = k2;
      }
    }
    if (conj[k2].comparative) {
      if (m3.toComparative) {
        m3.toComparative.ex[k2] = conj[k2].comparative;
      }
      if (m3.fromComparative) {
        m3.fromComparative.ex[conj[k2].comparative] = k2;
      }
    }
    if (conj[k2].superlative) {
      if (m3.toSuperlative) {
        m3.toSuperlative.ex[k2] = conj[k2].superlative;
      }
      if (m3.fromSuperlative) {
        m3.fromSuperlative.ex[conj[k2].superlative] = k2;
      }
    }
  });
};
var extend = function(plugin5, world2, View2, nlp2) {
  const { methods: methods18, model: model5, compute: compute4, hooks: hooks2 } = world2;
  if (plugin5.methods) {
    mergeQuick(methods18, plugin5.methods);
  }
  if (plugin5.model) {
    mergeDeep(model5, plugin5.model);
  }
  if (plugin5.irregulars) {
    addIrregulars(model5, plugin5.irregulars);
  }
  if (plugin5.compute) {
    Object.assign(compute4, plugin5.compute);
  }
  if (hooks2) {
    world2.hooks = hooks2.concat(plugin5.hooks || []);
  }
  if (plugin5.api) {
    plugin5.api(View2);
  }
  if (plugin5.lib) {
    Object.keys(plugin5.lib).forEach((k2) => nlp2[k2] = plugin5.lib[k2]);
  }
  if (plugin5.tags) {
    nlp2.addTags(plugin5.tags);
  }
  if (plugin5.words) {
    nlp2.addWords(plugin5.words);
  }
  if (plugin5.mutate) {
    plugin5.mutate(world2);
  }
};
var extend_default = extend;

// ../../node_modules/compromise/src/API/_lib.js
var verbose = function(set) {
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  env2.DEBUG_TAGS = set === "tagger" || set === true ? true : "";
  env2.DEBUG_MATCH = set === "match" || set === true ? true : "";
  env2.DEBUG_CHUNKS = set === "chunker" || set === true ? true : "";
  return this;
};

// ../../node_modules/compromise/src/API/inputs.js
var isObject2 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var isArray2 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var fromJson = function(json) {
  return json.map((o2) => {
    return o2.terms.map((term) => {
      if (isArray2(term.tags)) {
        term.tags = new Set(term.tags);
      }
      return term;
    });
  });
};
var preTokenized = function(arr) {
  return arr.map((a2) => {
    return a2.map((str) => {
      return {
        text: str,
        normal: str,
        //cleanup
        pre: "",
        post: " ",
        tags: /* @__PURE__ */ new Set()
      };
    });
  });
};
var inputs = function(input, View2, world2) {
  const { methods: methods18 } = world2;
  let doc = new View2([]);
  doc.world = world2;
  if (typeof input === "number") {
    input = String(input);
  }
  if (!input) {
    return doc;
  }
  if (typeof input === "string") {
    let document = methods18.one.tokenize.fromString(input, world2);
    return new View2(document);
  }
  if (isObject2(input) && input.isView) {
    return new View2(input.document, input.ptrs);
  }
  if (isArray2(input)) {
    if (isArray2(input[0])) {
      let document2 = preTokenized(input);
      return new View2(document2);
    }
    let document = fromJson(input);
    return new View2(document);
  }
  return doc;
};
var inputs_default = inputs;

// ../../node_modules/compromise/src/nlp.js
var world = Object.assign({}, world_default);
var nlp = function(input, lex) {
  if (lex) {
    nlp.addWords(lex);
  }
  let doc = inputs_default(input, View_default, world);
  if (input) {
    doc.compute(world.hooks);
  }
  return doc;
};
Object.defineProperty(nlp, "_world", {
  value: world,
  writable: true
});
nlp.tokenize = function(input, lex) {
  const { compute: compute4 } = this._world;
  if (lex) {
    nlp.addWords(lex);
  }
  let doc = inputs_default(input, View_default, world);
  if (compute4.contractions) {
    doc.compute(["alias", "normal", "machine", "contractions"]);
  }
  return doc;
};
nlp.plugin = function(plugin5) {
  extend_default(plugin5, this._world, View_default, this);
  return this;
};
nlp.extend = nlp.plugin;
nlp.world = function() {
  return this._world;
};
nlp.model = function() {
  return this._world.model;
};
nlp.methods = function() {
  return this._world.methods;
};
nlp.hooks = function() {
  return this._world.hooks;
};
nlp.verbose = verbose;
nlp.version = version_default;
var nlp_default = nlp;

// ../../node_modules/compromise/src/1-one/cache/methods/cacheDoc.js
var createCache = function(document) {
  let cache2 = document.map((terms) => {
    let stuff = /* @__PURE__ */ new Set();
    terms.forEach((term) => {
      if (term.normal !== "") {
        stuff.add(term.normal);
      }
      if (term.switch) {
        stuff.add(`%${term.switch}%`);
      }
      if (term.implicit) {
        stuff.add(term.implicit);
      }
      if (term.machine) {
        stuff.add(term.machine);
      }
      if (term.root) {
        stuff.add(term.root);
      }
      if (term.alias) {
        term.alias.forEach((str) => stuff.add(str));
      }
      let tags = Array.from(term.tags);
      for (let t3 = 0; t3 < tags.length; t3 += 1) {
        stuff.add("#" + tags[t3]);
      }
    });
    return stuff;
  });
  return cache2;
};
var cacheDoc_default = createCache;

// ../../node_modules/compromise/src/1-one/cache/methods/index.js
var methods_default2 = {
  one: {
    cacheDoc: cacheDoc_default
  }
};

// ../../node_modules/compromise/src/1-one/cache/api.js
var methods3 = {
  /** */
  cache: function() {
    this._cache = this.methods.one.cacheDoc(this.document);
    return this;
  },
  /** */
  uncache: function() {
    this._cache = null;
    return this;
  }
};
var addAPI = function(View2) {
  Object.assign(View2.prototype, methods3);
};
var api_default = addAPI;

// ../../node_modules/compromise/src/1-one/cache/compute.js
var compute_default2 = {
  cache: function(view) {
    view._cache = view.methods.one.cacheDoc(view.document);
  }
};

// ../../node_modules/compromise/src/1-one/cache/plugin.js
var plugin_default = {
  api: api_default,
  compute: compute_default2,
  methods: methods_default2
};

// ../../node_modules/compromise/src/1-one/change/api/case.js
var case_default = {
  /** */
  toLowerCase: function() {
    this.termList().forEach((t3) => {
      t3.text = t3.text.toLowerCase();
    });
    return this;
  },
  /** */
  toUpperCase: function() {
    this.termList().forEach((t3) => {
      t3.text = t3.text.toUpperCase();
    });
    return this;
  },
  /** */
  toTitleCase: function() {
    this.termList().forEach((t3) => {
      t3.text = t3.text.replace(/^ *[a-z\u00C0-\u00FF]/, (x) => x.toUpperCase());
    });
    return this;
  },
  /** */
  toCamelCase: function() {
    this.docs.forEach((terms) => {
      terms.forEach((t3, i3) => {
        if (i3 !== 0) {
          t3.text = t3.text.replace(/^ *[a-z\u00C0-\u00FF]/, (x) => x.toUpperCase());
        }
        if (i3 !== terms.length - 1) {
          t3.post = "";
        }
      });
    });
    return this;
  }
};

// ../../node_modules/compromise/src/1-one/change/api/lib/insert.js
var isTitleCase = (str) => /^\p{Lu}[\p{Ll}'’]/u.test(str) || /^\p{Lu}$/u.test(str);
var toTitleCase = (str) => str.replace(/^\p{Ll}/u, (x) => x.toUpperCase());
var toLowerCase = (str) => str.replace(/^\p{Lu}/u, (x) => x.toLowerCase());
var spliceArr = (parent, index3, child) => {
  child.forEach((term) => term.dirty = true);
  if (parent) {
    let args = [index3, 0].concat(child);
    Array.prototype.splice.apply(parent, args);
  }
  return parent;
};
var endSpace = function(terms) {
  const hasSpace2 = / $/;
  const hasDash4 = /[-–—]/;
  let lastTerm = terms[terms.length - 1];
  if (lastTerm && !hasSpace2.test(lastTerm.post) && !hasDash4.test(lastTerm.post)) {
    lastTerm.post += " ";
  }
};
var movePunct = (source, end2, needle) => {
  const juicy = /[-.?!,;:)–—'"]/g;
  let wasLast = source[end2 - 1];
  if (!wasLast) {
    return;
  }
  let post = wasLast.post;
  if (juicy.test(post)) {
    let punct = post.match(juicy).join("");
    let last = needle[needle.length - 1];
    last.post = punct + last.post;
    wasLast.post = wasLast.post.replace(juicy, "");
  }
};
var moveTitleCase = function(home, start2, needle) {
  let from = home[start2];
  if (start2 !== 0 || !isTitleCase(from.text)) {
    return;
  }
  needle[0].text = toTitleCase(needle[0].text);
  let old = home[start2];
  if (old.tags.has("ProperNoun") || old.tags.has("Acronym")) {
    return;
  }
  if (isTitleCase(old.text) && old.text.length > 1) {
    old.text = toLowerCase(old.text);
  }
};
var cleanPrepend = function(home, ptr, needle, document) {
  let [n3, start2, end2] = ptr;
  if (start2 === 0) {
    endSpace(needle);
  } else if (end2 === document[n3].length) {
    endSpace(needle);
  } else {
    endSpace(needle);
    endSpace([home[ptr[1]]]);
  }
  moveTitleCase(home, start2, needle);
  spliceArr(home, start2, needle);
};
var cleanAppend = function(home, ptr, needle, document) {
  let [n3, , end2] = ptr;
  let total = (document[n3] || []).length;
  if (end2 < total) {
    movePunct(home, end2, needle);
    endSpace(needle);
  } else if (total === end2) {
    endSpace(home);
    movePunct(home, end2, needle);
    if (document[n3 + 1]) {
      needle[needle.length - 1].post += " ";
    }
  }
  spliceArr(home, ptr[2], needle);
  ptr[4] = needle[needle.length - 1].id;
};

// ../../node_modules/compromise/src/1-one/change/compute/uuid.js
var index = 0;
var pad3 = (str) => {
  str = str.length < 3 ? "0" + str : str;
  return str.length < 3 ? "0" + str : str;
};
var toId = function(term) {
  let [n3, i3] = term.index || [0, 0];
  index += 1;
  index = index > 46655 ? 0 : index;
  n3 = n3 > 46655 ? 0 : n3;
  i3 = i3 > 1294 ? 0 : i3;
  let id = pad3(index.toString(36));
  id += pad3(n3.toString(36));
  let tx = i3.toString(36);
  tx = tx.length < 2 ? "0" + tx : tx;
  id += tx;
  let r2 = parseInt(Math.random() * 36, 10);
  id += r2.toString(36);
  return term.normal + "|" + id.toUpperCase();
};
var uuid_default = toId;

// ../../node_modules/compromise/src/1-one/change/api/insert.js
var expand = function(m3) {
  if (m3.has("@hasContraction") && typeof m3.contractions === "function") {
    let more = m3.grow("@hasContraction");
    more.contractions().expand();
  }
};
var isArray3 = (arr) => Object.prototype.toString.call(arr) === "[object Array]";
var addIds = function(terms) {
  terms = terms.map((term) => {
    term.id = uuid_default(term);
    return term;
  });
  return terms;
};
var getTerms = function(input, world2) {
  const { methods: methods18 } = world2;
  if (typeof input === "string") {
    return methods18.one.tokenize.fromString(input, world2)[0];
  }
  if (typeof input === "object" && input.isView) {
    return input.clone().docs[0] || [];
  }
  if (isArray3(input)) {
    return isArray3(input[0]) ? input[0] : input;
  }
  return [];
};
var insert = function(input, view, prepend) {
  const { document, world: world2 } = view;
  view.uncache();
  let ptrs = view.fullPointer;
  let selfPtrs = view.fullPointer;
  view.forEach((m3, i3) => {
    let ptr = m3.fullPointer[0];
    let [n3] = ptr;
    let home = document[n3];
    let terms = getTerms(input, world2);
    if (terms.length === 0) {
      return;
    }
    terms = addIds(terms);
    if (prepend) {
      expand(view.update([ptr]).firstTerm());
      cleanPrepend(home, ptr, terms, document);
    } else {
      expand(view.update([ptr]).lastTerm());
      cleanAppend(home, ptr, terms, document);
    }
    if (document[n3] && document[n3][ptr[1]]) {
      ptr[3] = document[n3][ptr[1]].id;
    }
    selfPtrs[i3] = ptr;
    ptr[2] += terms.length;
    ptrs[i3] = ptr;
  });
  let doc = view.toView(ptrs);
  view.ptrs = selfPtrs;
  doc.compute(["id", "index", "lexicon"]);
  if (doc.world.compute.preTagger) {
    doc.compute("preTagger");
  }
  return doc;
};
var fns2 = {
  insertAfter: function(input) {
    return insert(input, this, false);
  },
  insertBefore: function(input) {
    return insert(input, this, true);
  }
};
fns2.append = fns2.insertAfter;
fns2.prepend = fns2.insertBefore;
fns2.insert = fns2.insertAfter;
var insert_default = fns2;

// ../../node_modules/compromise/src/1-one/change/api/replace.js
var dollarStub = /\$[0-9a-z]+/g;
var fns3 = {};
var titleCase = function(str) {
  return str.replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase());
};
var replaceByFn = function(main, fn) {
  main.forEach((m3) => {
    let out2 = fn(m3);
    m3.replaceWith(out2);
  });
  return main;
};
var subDollarSign = function(input, main) {
  if (typeof input !== "string") {
    return input;
  }
  let groups = main.groups();
  input = input.replace(dollarStub, (a2) => {
    let num = a2.replace(/\$/, "");
    if (groups.hasOwnProperty(num)) {
      return groups[num].text();
    }
    return a2;
  });
  return input;
};
fns3.replaceWith = function(input, keep9 = {}) {
  let ptrs = this.fullPointer;
  let main = this;
  this.uncache();
  if (typeof input === "function") {
    return replaceByFn(main, input);
  }
  let terms = main.docs[0];
  let isPossessive2 = keep9.possessives && terms[terms.length - 1].tags.has("Possessive");
  input = subDollarSign(input, main);
  let original = this.update(ptrs);
  ptrs = ptrs.map((ptr) => ptr.slice(0, 3));
  let oldTags = (original.docs[0] || []).map((term) => Array.from(term.tags));
  if (typeof input === "string") {
    input = this.fromText(input).compute("id");
  }
  main.insertAfter(input);
  if (original.has("@hasContraction") && main.contractions) {
    let more = main.grow("@hasContraction+");
    more.contractions().expand();
  }
  main.delete(original);
  if (isPossessive2) {
    let tmp = main.docs[0];
    let term = tmp[tmp.length - 1];
    if (!term.tags.has("Possessive")) {
      term.text += "'s";
      term.normal += "'s";
      term.tags.add("Possessive");
    }
  }
  let m3 = main.toView(ptrs).compute(["index", "lexicon"]);
  if (m3.world.compute.preTagger) {
    m3.compute("preTagger");
  }
  if (keep9.tags) {
    m3.terms().forEach((term, i3) => {
      term.tagSafe(oldTags[i3]);
    });
  }
  if (keep9.case && m3.docs[0] && m3.docs[0][0] && m3.docs[0][0].index[1] === 0) {
    m3.docs[0][0].text = titleCase(m3.docs[0][0].text);
  }
  return m3;
};
fns3.replace = function(match2, input, keep9) {
  if (match2 && !input) {
    return this.replaceWith(match2, keep9);
  }
  let m3 = this.match(match2);
  if (!m3.found) {
    return this;
  }
  this.soften();
  return m3.replaceWith(input, keep9);
};
var replace_default = fns3;

// ../../node_modules/compromise/src/1-one/change/api/lib/remove.js
var repairPunct = function(terms, len) {
  let last = terms.length - 1;
  let from = terms[last];
  let to = terms[last - len];
  if (to && from) {
    to.post += from.post;
    to.post = to.post.replace(/ +([.?!,;:])/, "$1");
    to.post = to.post.replace(/[,;:]+([.?!])/, "$1");
  }
};
var pluckOut = function(document, nots) {
  nots.forEach((ptr) => {
    let [n3, start2, end2] = ptr;
    let len = end2 - start2;
    if (!document[n3]) {
      return;
    }
    if (end2 === document[n3].length && end2 > 1) {
      repairPunct(document[n3], len);
    }
    document[n3].splice(start2, len);
  });
  for (let i3 = document.length - 1; i3 >= 0; i3 -= 1) {
    if (document[i3].length === 0) {
      document.splice(i3, 1);
      if (i3 === document.length && document[i3 - 1]) {
        let terms = document[i3 - 1];
        let lastTerm = terms[terms.length - 1];
        if (lastTerm) {
          lastTerm.post = lastTerm.post.trimEnd();
        }
      }
    }
  }
  return document;
};
var remove_default = pluckOut;

// ../../node_modules/compromise/src/1-one/change/api/remove.js
var fixPointers = function(ptrs, gonePtrs) {
  ptrs = ptrs.map((ptr) => {
    let [n3] = ptr;
    if (!gonePtrs[n3]) {
      return ptr;
    }
    gonePtrs[n3].forEach((no) => {
      let len = no[2] - no[1];
      if (ptr[1] <= no[1] && ptr[2] >= no[2]) {
        ptr[2] -= len;
      }
    });
    return ptr;
  });
  ptrs.forEach((ptr, i3) => {
    if (ptr[1] === 0 && ptr[2] == 0) {
      for (let n3 = i3 + 1; n3 < ptrs.length; n3 += 1) {
        ptrs[n3][0] -= 1;
        if (ptrs[n3][0] < 0) {
          ptrs[n3][0] = 0;
        }
      }
    }
  });
  ptrs = ptrs.filter((ptr) => ptr[2] - ptr[1] > 0);
  ptrs = ptrs.map((ptr) => {
    ptr[3] = null;
    ptr[4] = null;
    return ptr;
  });
  return ptrs;
};
var methods4 = {
  /** */
  remove: function(reg) {
    const { indexN: indexN2 } = this.methods.one.pointer;
    this.uncache();
    let self2 = this.all();
    let not = this;
    if (reg) {
      self2 = this;
      not = this.match(reg);
    }
    let isFull = !self2.ptrs;
    if (not.has("@hasContraction") && not.contractions) {
      let more = not.grow("@hasContraction");
      more.contractions().expand();
    }
    let ptrs = self2.fullPointer;
    let nots = not.fullPointer.reverse();
    let document = remove_default(this.document, nots);
    let gonePtrs = indexN2(nots);
    ptrs = fixPointers(ptrs, gonePtrs);
    self2.ptrs = ptrs;
    self2.document = document;
    self2.compute("index");
    if (isFull) {
      self2.ptrs = void 0;
    }
    if (!reg) {
      this.ptrs = [];
      return self2.none();
    }
    let res = self2.toView(ptrs);
    return res;
  }
};
methods4.delete = methods4.remove;
var remove_default2 = methods4;

// ../../node_modules/compromise/src/1-one/change/api/whitespace.js
var methods5 = {
  /** add this punctuation or whitespace before each match: */
  pre: function(str, concat) {
    if (str === void 0 && this.found) {
      return this.docs[0][0].pre;
    }
    this.docs.forEach((terms) => {
      let term = terms[0];
      if (concat === true) {
        term.pre += str;
      } else {
        term.pre = str;
      }
    });
    return this;
  },
  /** add this punctuation or whitespace after each match: */
  post: function(str, concat) {
    if (str === void 0) {
      let last = this.docs[this.docs.length - 1];
      return last[last.length - 1].post;
    }
    this.docs.forEach((terms) => {
      let term = terms[terms.length - 1];
      if (concat === true) {
        term.post += str;
      } else {
        term.post = str;
      }
    });
    return this;
  },
  /** remove whitespace from start/end */
  trim: function() {
    if (!this.found) {
      return this;
    }
    let docs = this.docs;
    let start2 = docs[0][0];
    start2.pre = start2.pre.trimStart();
    let last = docs[docs.length - 1];
    let end2 = last[last.length - 1];
    end2.post = end2.post.trimEnd();
    return this;
  },
  /** connect words with hyphen, and remove whitespace */
  hyphenate: function() {
    this.docs.forEach((terms) => {
      terms.forEach((t3, i3) => {
        if (i3 !== 0) {
          t3.pre = "";
        }
        if (terms[i3 + 1]) {
          t3.post = "-";
        }
      });
    });
    return this;
  },
  /** remove hyphens between words, and set whitespace */
  dehyphenate: function() {
    const hasHyphen3 = /[-–—]/;
    this.docs.forEach((terms) => {
      terms.forEach((t3) => {
        if (hasHyphen3.test(t3.post)) {
          t3.post = " ";
        }
      });
    });
    return this;
  },
  /** add quotations around these matches */
  toQuotations: function(start2, end2) {
    start2 = start2 || `"`;
    end2 = end2 || `"`;
    this.docs.forEach((terms) => {
      terms[0].pre = start2 + terms[0].pre;
      let last = terms[terms.length - 1];
      last.post = end2 + last.post;
    });
    return this;
  },
  /** add brackets around these matches */
  toParentheses: function(start2, end2) {
    start2 = start2 || `(`;
    end2 = end2 || `)`;
    this.docs.forEach((terms) => {
      terms[0].pre = start2 + terms[0].pre;
      let last = terms[terms.length - 1];
      last.post = end2 + last.post;
    });
    return this;
  }
};
methods5.deHyphenate = methods5.dehyphenate;
methods5.toQuotation = methods5.toQuotations;
var whitespace_default = methods5;

// ../../node_modules/compromise/src/1-one/change/api/lib/_sort.js
var alpha = (a2, b) => {
  if (a2.normal < b.normal) {
    return -1;
  }
  if (a2.normal > b.normal) {
    return 1;
  }
  return 0;
};
var length = (a2, b) => {
  let left = a2.normal.trim().length;
  let right = b.normal.trim().length;
  if (left < right) {
    return 1;
  }
  if (left > right) {
    return -1;
  }
  return 0;
};
var wordCount = (a2, b) => {
  if (a2.words < b.words) {
    return 1;
  }
  if (a2.words > b.words) {
    return -1;
  }
  return 0;
};
var sequential = (a2, b) => {
  if (a2[0] < b[0]) {
    return 1;
  }
  if (a2[0] > b[0]) {
    return -1;
  }
  return a2[1] > b[1] ? 1 : -1;
};
var byFreq = function(arr) {
  let counts = {};
  arr.forEach((o2) => {
    counts[o2.normal] = counts[o2.normal] || 0;
    counts[o2.normal] += 1;
  });
  arr.sort((a2, b) => {
    let left = counts[a2.normal];
    let right = counts[b.normal];
    if (left < right) {
      return 1;
    }
    if (left > right) {
      return -1;
    }
    return 0;
  });
  return arr;
};
var sort_default = { alpha, length, wordCount, sequential, byFreq };

// ../../node_modules/compromise/src/1-one/change/api/sort.js
var seqNames = /* @__PURE__ */ new Set(["index", "sequence", "seq", "sequential", "chron", "chronological"]);
var freqNames = /* @__PURE__ */ new Set(["freq", "frequency", "topk", "repeats"]);
var alphaNames = /* @__PURE__ */ new Set(["alpha", "alphabetical"]);
var customSort = function(view, fn) {
  let ptrs = view.fullPointer;
  ptrs = ptrs.sort((a2, b) => {
    a2 = view.update([a2]);
    b = view.update([b]);
    return fn(a2, b);
  });
  view.ptrs = ptrs;
  return view;
};
var sort = function(input) {
  let { docs, pointer } = this;
  this.uncache();
  if (typeof input === "function") {
    return customSort(this, input);
  }
  input = input || "alpha";
  let ptrs = pointer || docs.map((_d, n3) => [n3]);
  let arr = docs.map((terms, n3) => {
    return {
      index: n3,
      words: terms.length,
      normal: terms.map((t3) => t3.machine || t3.normal || "").join(" "),
      pointer: ptrs[n3]
    };
  });
  if (seqNames.has(input)) {
    input = "sequential";
  }
  if (alphaNames.has(input)) {
    input = "alpha";
  }
  if (freqNames.has(input)) {
    arr = sort_default.byFreq(arr);
    return this.update(arr.map((o2) => o2.pointer));
  }
  if (typeof sort_default[input] === "function") {
    arr = arr.sort(sort_default[input]);
    return this.update(arr.map((o2) => o2.pointer));
  }
  return this;
};
var reverse = function() {
  let ptrs = this.pointer || this.docs.map((_d, n3) => [n3]);
  ptrs = [].concat(ptrs);
  ptrs = ptrs.reverse();
  if (this._cache) {
    this._cache = this._cache.reverse();
  }
  return this.update(ptrs);
};
var unique = function() {
  let already = /* @__PURE__ */ new Set();
  let res = this.filter((m3) => {
    let txt = m3.text("machine");
    if (already.has(txt)) {
      return false;
    }
    already.add(txt);
    return true;
  });
  return res;
};
var sort_default2 = { unique, reverse, sort };

// ../../node_modules/compromise/src/1-one/change/api/concat.js
var isArray4 = (arr) => Object.prototype.toString.call(arr) === "[object Array]";
var combineDocs = function(homeDocs, inputDocs) {
  if (homeDocs.length > 0) {
    let end2 = homeDocs[homeDocs.length - 1];
    let last = end2[end2.length - 1];
    if (/ /.test(last.post) === false) {
      last.post += " ";
    }
  }
  homeDocs = homeDocs.concat(inputDocs);
  return homeDocs;
};
var combineViews = function(home, input) {
  if (home.document === input.document) {
    let ptrs2 = home.fullPointer.concat(input.fullPointer);
    return home.toView(ptrs2).compute("index");
  }
  let ptrs = input.fullPointer;
  ptrs.forEach((a2) => {
    a2[0] += home.document.length;
  });
  home.document = combineDocs(home.document, input.docs);
  return home.all();
};
var concat_default = {
  // add string as new match/sentence
  concat: function(input) {
    if (typeof input === "string") {
      let more = this.fromText(input);
      if (!this.found || !this.ptrs) {
        this.document = this.document.concat(more.document);
      } else {
        let ptrs = this.fullPointer;
        let at = ptrs[ptrs.length - 1][0];
        this.document.splice(at, 0, ...more.document);
      }
      return this.all().compute("index");
    }
    if (typeof input === "object" && input.isView) {
      return combineViews(this, input);
    }
    if (isArray4(input)) {
      let docs = combineDocs(this.document, input);
      this.document = docs;
      return this.all();
    }
    return this;
  }
};

// ../../node_modules/compromise/src/1-one/change/api/harden.js
var harden = function() {
  this.ptrs = this.fullPointer;
  return this;
};
var soften = function() {
  let ptr = this.ptrs;
  if (!ptr || ptr.length < 1) {
    return this;
  }
  ptr = ptr.map((a2) => a2.slice(0, 3));
  this.ptrs = ptr;
  return this;
};
var harden_default = { harden, soften };

// ../../node_modules/compromise/src/1-one/change/api/index.js
var methods6 = Object.assign({}, case_default, insert_default, replace_default, remove_default2, whitespace_default, sort_default2, concat_default, harden_default);
var addAPI2 = function(View2) {
  Object.assign(View2.prototype, methods6);
};
var api_default2 = addAPI2;

// ../../node_modules/compromise/src/1-one/change/compute/index.js
var compute2 = {
  id: function(view) {
    let docs = view.docs;
    for (let n3 = 0; n3 < docs.length; n3 += 1) {
      for (let i3 = 0; i3 < docs[n3].length; i3 += 1) {
        let term = docs[n3][i3];
        term.id = term.id || uuid_default(term);
      }
    }
  }
};
var compute_default3 = compute2;

// ../../node_modules/compromise/src/1-one/change/plugin.js
var plugin_default2 = {
  api: api_default2,
  compute: compute_default3
};

// ../../node_modules/compromise/src/1-one/contraction-one/model/contractions.js
var contractions_default = [
  // simple mappings
  { word: "@", out: ["at"] },
  { word: "arent", out: ["are", "not"] },
  { word: "alot", out: ["a", "lot"] },
  { word: "brb", out: ["be", "right", "back"] },
  { word: "cannot", out: ["can", "not"] },
  { word: "dun", out: ["do", "not"] },
  { word: "can't", out: ["can", "not"] },
  { word: "shan't", out: ["should", "not"] },
  { word: "won't", out: ["will", "not"] },
  { word: "that's", out: ["that", "is"] },
  { word: "what's", out: ["what", "is"] },
  { word: "let's", out: ["let", "us"] },
  // { word: "there's", out: ['there', 'is'] },
  { word: "dunno", out: ["do", "not", "know"] },
  { word: "gonna", out: ["going", "to"] },
  { word: "gotta", out: ["have", "got", "to"] },
  //hmm
  { word: "gimme", out: ["give", "me"] },
  { word: "outta", out: ["out", "of"] },
  { word: "tryna", out: ["trying", "to"] },
  { word: "gtg", out: ["got", "to", "go"] },
  { word: "im", out: ["i", "am"] },
  { word: "imma", out: ["I", "will"] },
  { word: "imo", out: ["in", "my", "opinion"] },
  { word: "irl", out: ["in", "real", "life"] },
  { word: "ive", out: ["i", "have"] },
  { word: "rn", out: ["right", "now"] },
  { word: "tbh", out: ["to", "be", "honest"] },
  { word: "wanna", out: ["want", "to"] },
  { word: `c'mere`, out: ["come", "here"] },
  { word: `c'mon`, out: ["come", "on"] },
  // shoulda, coulda
  { word: "shoulda", out: ["should", "have"] },
  { word: "coulda", out: ["coulda", "have"] },
  { word: "woulda", out: ["woulda", "have"] },
  { word: "musta", out: ["must", "have"] },
  { word: "tis", out: ["it", "is"] },
  { word: "twas", out: ["it", "was"] },
  { word: `y'know`, out: ["you", "know"] },
  { word: "ne'er", out: ["never"] },
  { word: "o'er", out: ["over"] },
  // contraction-part mappings
  { after: "ll", out: ["will"] },
  { after: "ve", out: ["have"] },
  { after: "re", out: ["are"] },
  { after: "m", out: ["am"] },
  // french contractions
  { before: "c", out: ["ce"] },
  { before: "m", out: ["me"] },
  { before: "n", out: ["ne"] },
  { before: "qu", out: ["que"] },
  { before: "s", out: ["se"] },
  { before: "t", out: ["tu"] },
  // t'aime
  // missing apostrophes
  { word: "shouldnt", out: ["should", "not"] },
  { word: "couldnt", out: ["could", "not"] },
  { word: "wouldnt", out: ["would", "not"] },
  { word: "hasnt", out: ["has", "not"] },
  { word: "wasnt", out: ["was", "not"] },
  { word: "isnt", out: ["is", "not"] },
  { word: "cant", out: ["can", "not"] },
  { word: "dont", out: ["do", "not"] },
  { word: "wont", out: ["will", "not"] },
  // apostrophe d
  { word: "howd", out: ["how", "did"] },
  { word: "whatd", out: ["what", "did"] },
  { word: "whend", out: ["when", "did"] },
  { word: "whered", out: ["where", "did"] }
];

// ../../node_modules/compromise/src/1-one/contraction-one/model/number-suffix.js
var t = true;
var number_suffix_default = {
  "st": t,
  "nd": t,
  "rd": t,
  "th": t,
  "am": t,
  "pm": t,
  "max": t,
  "°": t,
  "s": t,
  // 1990s
  "e": t,
  // 18e - french/spanish ordinal
  "er": t,
  //french 1er
  "ère": t,
  //''
  "ème": t
  //french 2ème
};

// ../../node_modules/compromise/src/1-one/contraction-one/model/index.js
var model_default = {
  one: {
    contractions: contractions_default,
    numberSuffixes: number_suffix_default
  }
};

// ../../node_modules/compromise/src/1-one/contraction-one/compute/contractions/_splice.js
var insertContraction = function(document, point, words) {
  let [n3, w] = point;
  if (!words || words.length === 0) {
    return;
  }
  words = words.map((word, i3) => {
    word.implicit = word.text;
    word.machine = word.text;
    word.pre = "";
    word.post = "";
    word.text = "";
    word.normal = "";
    word.index = [n3, w + i3];
    return word;
  });
  if (words[0]) {
    words[0].pre = document[n3][w].pre;
    words[words.length - 1].post = document[n3][w].post;
    words[0].text = document[n3][w].text;
    words[0].normal = document[n3][w].normal;
  }
  document[n3].splice(w, 1, ...words);
};
var splice_default = insertContraction;

// ../../node_modules/compromise/src/1-one/contraction-one/compute/contractions/apostrophe-d.js
var hasContraction = /'/;
var alwaysDid = /* @__PURE__ */ new Set([
  "what",
  "how",
  "when",
  "where",
  "why"
]);
var useWould = /* @__PURE__ */ new Set([
  "be",
  "go",
  "start",
  "think",
  "need"
]);
var useHad = /* @__PURE__ */ new Set([
  "been",
  "gone"
]);
var _apostropheD = function(terms, i3) {
  let before2 = terms[i3].normal.split(hasContraction)[0];
  if (alwaysDid.has(before2)) {
    return [before2, "did"];
  }
  if (terms[i3 + 1]) {
    if (useHad.has(terms[i3 + 1].normal)) {
      return [before2, "had"];
    }
    if (useWould.has(terms[i3 + 1].normal)) {
      return [before2, "would"];
    }
  }
  return null;
};
var apostrophe_d_default = _apostropheD;

// ../../node_modules/compromise/src/1-one/contraction-one/compute/contractions/apostrophe-t.js
var apostropheT = function(terms, i3) {
  if (terms[i3].normal === "ain't" || terms[i3].normal === "aint") {
    return null;
  }
  let before2 = terms[i3].normal.replace(/n't/, "");
  return [before2, "not"];
};
var apostrophe_t_default = apostropheT;

// ../../node_modules/compromise/src/1-one/contraction-one/compute/contractions/french.js
var hasContraction2 = /'/;
var preL = (terms, i3) => {
  let after2 = terms[i3].normal.split(hasContraction2)[1];
  if (after2 && after2.endsWith("e")) {
    return ["la", after2];
  }
  return ["le", after2];
};
var preD = (terms, i3) => {
  let after2 = terms[i3].normal.split(hasContraction2)[1];
  if (after2 && after2.endsWith("e")) {
    return ["du", after2];
  } else if (after2 && after2.endsWith("s")) {
    return ["des", after2];
  }
  return ["de", after2];
};
var preJ = (terms, i3) => {
  let after2 = terms[i3].normal.split(hasContraction2)[1];
  return ["je", after2];
};
var french_default = {
  preJ,
  preL,
  preD
};

// ../../node_modules/compromise/src/1-one/contraction-one/compute/contractions/number-range.js
var isRange = /^([0-9.]{1,4}[a-z]{0,2}) ?[-–—] ?([0-9]{1,4}[a-z]{0,2})$/i;
var timeRange = /^([0-9]{1,2}(:[0-9][0-9])?(am|pm)?) ?[-–—] ?([0-9]{1,2}(:[0-9][0-9])?(am|pm)?)$/i;
var phoneNum = /^[0-9]{3}-[0-9]{4}$/;
var numberRange = function(terms, i3) {
  let term = terms[i3];
  let parts = term.text.match(isRange);
  if (parts !== null) {
    if (term.tags.has("PhoneNumber") === true || phoneNum.test(term.text)) {
      return null;
    }
    return [parts[1], "to", parts[2]];
  } else {
    parts = term.text.match(timeRange);
    if (parts !== null) {
      return [parts[1], "to", parts[4]];
    }
  }
  return null;
};
var number_range_default = numberRange;

// ../../node_modules/compromise/src/1-one/contraction-one/compute/contractions/number-unit.js
var numUnit = /^([+-]?[0-9][.,0-9]*)([a-z°²³µ/]+)$/;
var numberUnit = function(terms, i3, world2) {
  const notUnit = world2.model.one.numberSuffixes || {};
  let term = terms[i3];
  let parts = term.text.match(numUnit);
  if (parts !== null) {
    let unit = parts[2].toLowerCase().trim();
    if (notUnit.hasOwnProperty(unit)) {
      return null;
    }
    return [parts[1], unit];
  }
  return null;
};
var number_unit_default = numberUnit;

// ../../node_modules/compromise/src/1-one/contraction-one/compute/contractions/index.js
var byApostrophe = /'/;
var numDash = /^[0-9][^-–—]*[-–—].*?[0-9]/;
var reTag = function(terms, view, start2, len) {
  let tmp = view.update();
  tmp.document = [terms];
  let end2 = start2 + len;
  if (start2 > 0) {
    start2 -= 1;
  }
  if (terms[end2]) {
    end2 += 1;
  }
  tmp.ptrs = [[0, start2, end2]];
};
var byEnd = {
  // ain't
  t: (terms, i3) => apostrophe_t_default(terms, i3),
  // how'd
  d: (terms, i3) => apostrophe_d_default(terms, i3)
};
var byStart = {
  // j'aime
  j: (terms, i3) => french_default.preJ(terms, i3),
  // l'amour
  l: (terms, i3) => french_default.preL(terms, i3),
  // d'amerique
  d: (terms, i3) => french_default.preD(terms, i3)
};
var knownOnes = function(list4, term, before2, after2) {
  for (let i3 = 0; i3 < list4.length; i3 += 1) {
    let o2 = list4[i3];
    if (o2.word === term.normal) {
      return o2.out;
    } else if (after2 !== null && after2 === o2.after) {
      return [before2].concat(o2.out);
    } else if (before2 !== null && before2 === o2.before && after2 && after2.length > 2) {
      return o2.out.concat(after2);
    }
  }
  return null;
};
var toDocs = function(words, view) {
  let doc = view.fromText(words.join(" "));
  doc.compute(["id", "alias"]);
  return doc.docs[0];
};
var thereHas = function(terms, i3) {
  for (let k2 = i3 + 1; k2 < 5; k2 += 1) {
    if (!terms[k2]) {
      break;
    }
    if (terms[k2].normal === "been") {
      return ["there", "has"];
    }
  }
  return ["there", "is"];
};
var contractions = (view) => {
  let { world: world2, document } = view;
  const { model: model5, methods: methods18 } = world2;
  let list4 = model5.one.contractions || [];
  document.forEach((terms, n3) => {
    for (let i3 = terms.length - 1; i3 >= 0; i3 -= 1) {
      let before2 = null;
      let after2 = null;
      if (byApostrophe.test(terms[i3].normal) === true) {
        [before2, after2] = terms[i3].normal.split(byApostrophe);
      }
      let words = knownOnes(list4, terms[i3], before2, after2);
      if (!words && byEnd.hasOwnProperty(after2)) {
        words = byEnd[after2](terms, i3, world2);
      }
      if (!words && byStart.hasOwnProperty(before2)) {
        words = byStart[before2](terms, i3);
      }
      if (before2 === "there" && after2 === "s") {
        words = thereHas(terms, i3);
      }
      if (words) {
        words = toDocs(words, view);
        splice_default(document, [n3, i3], words);
        reTag(document[n3], view, i3, words.length);
        continue;
      }
      if (numDash.test(terms[i3].normal)) {
        words = number_range_default(terms, i3);
        if (words) {
          words = toDocs(words, view);
          splice_default(document, [n3, i3], words);
          methods18.one.setTag(words, "NumberRange", world2);
          if (words[2] && words[2].tags.has("Time")) {
            methods18.one.setTag([words[0]], "Time", world2, null, "time-range");
          }
          reTag(document[n3], view, i3, words.length);
        }
        continue;
      }
      words = number_unit_default(terms, i3, world2);
      if (words) {
        words = toDocs(words, view);
        splice_default(document, [n3, i3], words);
        methods18.one.setTag([words[1]], "Unit", world2, null, "contraction-unit");
      }
    }
  });
};
var contractions_default2 = contractions;

// ../../node_modules/compromise/src/1-one/contraction-one/compute/index.js
var compute_default4 = { contractions: contractions_default2 };

// ../../node_modules/compromise/src/1-one/contraction-one/plugin.js
var plugin = {
  model: model_default,
  compute: compute_default4,
  hooks: ["contractions"]
};
var plugin_default3 = plugin;

// ../../node_modules/compromise/src/1-one/lexicon/compute/multi-word.js
var checkMulti = function(terms, i3, lexicon4, setTag3, world2) {
  let max3 = i3 + 4 > terms.length ? terms.length - i3 : 4;
  let str = terms[i3].machine || terms[i3].normal;
  for (let skip = 1; skip < max3; skip += 1) {
    let t3 = terms[i3 + skip];
    let word = t3.machine || t3.normal;
    str += " " + word;
    if (lexicon4.hasOwnProperty(str) === true) {
      let tag = lexicon4[str];
      let ts = terms.slice(i3, i3 + skip + 1);
      setTag3(ts, tag, world2, false, "1-multi-lexicon");
      if (tag && tag.length === 2 && (tag[0] === "PhrasalVerb" || tag[1] === "PhrasalVerb")) {
        setTag3([ts[1]], "Particle", world2, false, "1-phrasal-particle");
      }
      return true;
    }
  }
  return false;
};
var multiWord = function(terms, i3, world2) {
  const { model: model5, methods: methods18 } = world2;
  const setTag3 = methods18.one.setTag;
  const multi = model5.one._multiCache || {};
  const lexicon4 = model5.one.lexicon || {};
  let t3 = terms[i3];
  let word = t3.machine || t3.normal;
  if (terms[i3 + 1] !== void 0 && multi[word] === true) {
    return checkMulti(terms, i3, lexicon4, setTag3, world2);
  }
  return null;
};
var multi_word_default = multiWord;

// ../../node_modules/compromise/src/1-one/lexicon/compute/single-word.js
var prefix = /^(under|over|mis|re|un|dis|semi|pre|post)-?/;
var allowPrefix = /* @__PURE__ */ new Set(["Verb", "Infinitive", "PastTense", "Gerund", "PresentTense", "Adjective", "Participle"]);
var checkLexicon = function(terms, i3, world2) {
  const { model: model5, methods: methods18 } = world2;
  const setTag3 = methods18.one.setTag;
  const lexicon4 = model5.one.lexicon;
  let t3 = terms[i3];
  let word = t3.machine || t3.normal;
  if (lexicon4[word] !== void 0 && lexicon4.hasOwnProperty(word)) {
    let tag = lexicon4[word];
    setTag3([t3], tag, world2, false, "1-lexicon");
    return true;
  }
  if (t3.alias) {
    let found = t3.alias.find((str) => lexicon4.hasOwnProperty(str));
    if (found) {
      let tag = lexicon4[found];
      setTag3([t3], tag, world2, false, "1-lexicon-alias");
      return true;
    }
  }
  if (prefix.test(word) === true) {
    let stem = word.replace(prefix, "");
    if (lexicon4.hasOwnProperty(stem) && stem.length > 3) {
      if (allowPrefix.has(lexicon4[stem])) {
        setTag3([t3], lexicon4[stem], world2, false, "1-lexicon-prefix");
        return true;
      }
    }
  }
  return null;
};
var single_word_default = checkLexicon;

// ../../node_modules/compromise/src/1-one/lexicon/compute/index.js
var lexicon = function(view) {
  const world2 = view.world;
  view.docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      if (terms[i3].tags.size === 0) {
        let found = null;
        found = found || multi_word_default(terms, i3, world2);
        found = found || single_word_default(terms, i3, world2);
      }
    }
  });
};
var compute_default5 = {
  lexicon
};

// ../../node_modules/compromise/src/1-one/lexicon/methods/expand.js
var expand2 = function(words) {
  let lex = {};
  let _multi = {};
  Object.keys(words).forEach((word) => {
    let tag = words[word];
    word = word.toLowerCase().trim();
    word = word.replace(/'s\b/, "");
    let split3 = word.split(/ /);
    if (split3.length > 1) {
      _multi[split3[0]] = true;
    }
    lex[word] = lex[word] || tag;
  });
  delete lex[""];
  delete lex[null];
  delete lex[" "];
  return { lex, _multi };
};
var expand_default = expand2;

// ../../node_modules/compromise/src/1-one/lexicon/methods/index.js
var methods_default3 = {
  one: {
    expandLexicon: expand_default
  }
};

// ../../node_modules/compromise/src/1-one/lexicon/lib.js
var addWords = function(words) {
  const world2 = this.world();
  const { methods: methods18, model: model5 } = world2;
  if (!words) {
    return;
  }
  Object.keys(words).forEach((k2) => {
    if (typeof words[k2] === "string" && words[k2].startsWith("#")) {
      words[k2] = words[k2].replace(/^#/, "");
    }
  });
  if (methods18.two.expandLexicon) {
    let { lex, _multi } = methods18.two.expandLexicon(words, world2);
    Object.assign(model5.one.lexicon, lex);
    Object.assign(model5.one._multiCache, _multi);
  } else if (methods18.one.expandLexicon) {
    let { lex, _multi } = methods18.one.expandLexicon(words, world2);
    Object.assign(model5.one.lexicon, lex);
    Object.assign(model5.one._multiCache, _multi);
  } else {
    Object.assign(model5.one.lexicon, words);
  }
};
var lib_default = { addWords };

// ../../node_modules/compromise/src/1-one/lexicon/plugin.js
var model2 = {
  one: {
    lexicon: {},
    //setup blank lexicon
    _multiCache: {}
  }
};
var plugin_default4 = {
  model: model2,
  methods: methods_default3,
  compute: compute_default5,
  lib: lib_default,
  hooks: ["lexicon"]
};

// ../../node_modules/compromise/src/1-one/lookup/api/buildTrie/index.js
var tokenize = function(phrase, world2) {
  const { methods: methods18, model: model5 } = world2;
  let terms = methods18.one.tokenize.splitTerms(phrase, model5).map((t3) => methods18.one.tokenize.splitWhitespace(t3, model5));
  return terms.map((term) => term.text.toLowerCase());
};
var buildTrie = function(phrases, world2) {
  let goNext = [{}];
  let endAs = [null];
  let failTo = [0];
  let xs = [];
  let n3 = 0;
  phrases.forEach(function(phrase) {
    let curr = 0;
    let words = tokenize(phrase, world2);
    for (let i3 = 0; i3 < words.length; i3++) {
      let word = words[i3];
      if (goNext[curr] && goNext[curr].hasOwnProperty(word)) {
        curr = goNext[curr][word];
      } else {
        n3++;
        goNext[curr][word] = n3;
        goNext[n3] = {};
        curr = n3;
        endAs[n3] = null;
      }
    }
    endAs[curr] = [words.length];
  });
  for (let word in goNext[0]) {
    n3 = goNext[0][word];
    failTo[n3] = 0;
    xs.push(n3);
  }
  while (xs.length) {
    let r2 = xs.shift();
    let keys = Object.keys(goNext[r2]);
    for (let i3 = 0; i3 < keys.length; i3 += 1) {
      let word = keys[i3];
      let s3 = goNext[r2][word];
      xs.push(s3);
      n3 = failTo[r2];
      while (n3 > 0 && !goNext[n3].hasOwnProperty(word)) {
        n3 = failTo[n3];
      }
      if (goNext.hasOwnProperty(n3)) {
        let fs = goNext[n3][word];
        failTo[s3] = fs;
        if (endAs[fs]) {
          endAs[s3] = endAs[s3] || [];
          endAs[s3] = endAs[s3].concat(endAs[fs]);
        }
      } else {
        failTo[s3] = 0;
      }
    }
  }
  return { goNext, endAs, failTo };
};
var buildTrie_default = buildTrie;

// ../../node_modules/compromise/src/1-one/lookup/api/scan.js
var scanWords = function(terms, trie, opts2) {
  let n3 = 0;
  let results = [];
  for (let i3 = 0; i3 < terms.length; i3++) {
    let word = terms[i3][opts2.form] || terms[i3].normal;
    while (n3 > 0 && (trie.goNext[n3] === void 0 || !trie.goNext[n3].hasOwnProperty(word))) {
      n3 = trie.failTo[n3] || 0;
    }
    if (!trie.goNext[n3].hasOwnProperty(word)) {
      continue;
    }
    n3 = trie.goNext[n3][word];
    if (trie.endAs[n3]) {
      let arr = trie.endAs[n3];
      for (let o2 = 0; o2 < arr.length; o2++) {
        let len = arr[o2];
        let term = terms[i3 - len + 1];
        let [no, start2] = term.index;
        results.push([no, start2, start2 + len, term.id]);
      }
    }
  }
  return results;
};
var cacheMiss = function(words, cache2) {
  for (let i3 = 0; i3 < words.length; i3 += 1) {
    if (cache2.has(words[i3]) === true) {
      return false;
    }
  }
  return true;
};
var scan = function(view, trie, opts2) {
  let results = [];
  opts2.form = opts2.form || "normal";
  let docs = view.docs;
  if (!trie.goNext || !trie.goNext[0]) {
    console.error("Compromise invalid lookup trie");
    return view.none();
  }
  let firstWords = Object.keys(trie.goNext[0]);
  for (let i3 = 0; i3 < docs.length; i3++) {
    if (view._cache && view._cache[i3] && cacheMiss(firstWords, view._cache[i3]) === true) {
      continue;
    }
    let terms = docs[i3];
    let found = scanWords(terms, trie, opts2);
    if (found.length > 0) {
      results = results.concat(found);
    }
  }
  return view.update(results);
};
var scan_default = scan;

// ../../node_modules/compromise/src/1-one/lookup/api/index.js
var isObject3 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
function api_default3(View2) {
  View2.prototype.lookup = function(input, opts2 = {}) {
    if (!input) {
      return this.none();
    }
    if (typeof input === "string") {
      input = [input];
    }
    let trie = isObject3(input) ? input : buildTrie_default(input, this.world);
    let res = scan_default(this, trie, opts2);
    res = res.settle();
    return res;
  };
}

// ../../node_modules/compromise/src/1-one/lookup/api/buildTrie/compress.js
var truncate = (list4, val) => {
  for (let i3 = list4.length - 1; i3 >= 0; i3 -= 1) {
    if (list4[i3] !== val) {
      list4 = list4.slice(0, i3 + 1);
      return list4;
    }
  }
  return list4;
};
var compress = function(trie) {
  trie.goNext = trie.goNext.map((o2) => {
    if (Object.keys(o2).length === 0) {
      return void 0;
    }
    return o2;
  });
  trie.goNext = truncate(trie.goNext, void 0);
  trie.failTo = truncate(trie.failTo, 0);
  trie.endAs = truncate(trie.endAs, null);
  return trie;
};
var compress_default = compress;

// ../../node_modules/compromise/src/1-one/lookup/plugin.js
var lib = {
  /** turn an array or object into a compressed trie*/
  buildTrie: function(input) {
    const trie = buildTrie_default(input, this.world());
    return compress_default(trie);
  }
};
lib.compile = lib.buildTrie;
var plugin_default5 = {
  api: api_default3,
  lib
};

// ../../node_modules/compromise/src/1-one/match/api/_lib.js
var relPointer = function(ptrs, parent) {
  if (!parent) {
    return ptrs;
  }
  ptrs.forEach((ptr) => {
    let n3 = ptr[0];
    if (parent[n3]) {
      ptr[0] = parent[n3][0];
      ptr[1] += parent[n3][1];
      ptr[2] += parent[n3][1];
    }
  });
  return ptrs;
};
var fixPointers2 = function(res, parent) {
  let { ptrs, byGroup } = res;
  ptrs = relPointer(ptrs, parent);
  Object.keys(byGroup).forEach((k2) => {
    byGroup[k2] = relPointer(byGroup[k2], parent);
  });
  return { ptrs, byGroup };
};
var isObject4 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var isView = (val) => val && isObject4(val) && val.isView === true;
var isNet = (val) => val && isObject4(val) && val.isNet === true;

// ../../node_modules/compromise/src/1-one/match/api/match.js
var parseRegs = function(regs, opts2, world2) {
  const one = world2.methods.one;
  if (typeof regs === "number") {
    regs = String(regs);
  }
  if (typeof regs === "string") {
    regs = one.killUnicode(regs, world2);
    regs = one.parseMatch(regs, opts2, world2);
  }
  return regs;
};
var match = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    return this.intersection(regs);
  }
  if (isNet(regs)) {
    return this.sweep(regs, { tagger: false }).view.settle();
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group };
  let res = one.match(this.docs, todo, this._cache);
  let { ptrs, byGroup } = fixPointers2(res, this.fullPointer);
  let view = this.toView(ptrs);
  view._groups = byGroup;
  return view;
};
var matchOne = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    return this.intersection(regs).eq(0);
  }
  if (isNet(regs)) {
    return this.sweep(regs, { tagger: false, matchOne: true }).view;
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group, justOne: true };
  let res = one.match(this.docs, todo, this._cache);
  let { ptrs, byGroup } = fixPointers2(res, this.fullPointer);
  let view = this.toView(ptrs);
  view._groups = byGroup;
  return view;
};
var has = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    let ptrs2 = regs.fullPointer;
    return ptrs2.length > 0;
  }
  if (isNet(regs)) {
    return this.sweep(regs, { tagger: false }).view.found;
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group, justOne: true };
  let ptrs = one.match(this.docs, todo, this._cache).ptrs;
  return ptrs.length > 0;
};
var ifFn = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    return this.filter((m3) => m3.intersection(regs).found);
  }
  if (isNet(regs)) {
    let m3 = this.sweep(regs, { tagger: false }).view.settle();
    return this.if(m3);
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group, justOne: true };
  let ptrs = this.fullPointer;
  let cache2 = this._cache || [];
  ptrs = ptrs.filter((ptr, i3) => {
    let m3 = this.update([ptr]);
    let res = one.match(m3.docs, todo, cache2[i3]).ptrs;
    return res.length > 0;
  });
  let view = this.update(ptrs);
  if (this._cache) {
    view._cache = ptrs.map((ptr) => cache2[ptr[0]]);
  }
  return view;
};
var ifNo = function(regs, group, opts2) {
  const { methods: methods18 } = this;
  const one = methods18.one;
  if (isView(regs)) {
    return this.filter((m3) => !m3.intersection(regs).found);
  }
  if (isNet(regs)) {
    let m3 = this.sweep(regs, { tagger: false }).view.settle();
    return this.ifNo(m3);
  }
  regs = parseRegs(regs, opts2, this.world);
  let cache2 = this._cache || [];
  let view = this.filter((m3, i3) => {
    let todo = { regs, group, justOne: true };
    let ptrs = one.match(m3.docs, todo, cache2[i3]).ptrs;
    return ptrs.length === 0;
  });
  if (this._cache) {
    view._cache = view.ptrs.map((ptr) => cache2[ptr[0]]);
  }
  return view;
};
var match_default = { matchOne, match, has, if: ifFn, ifNo };

// ../../node_modules/compromise/src/1-one/match/api/lookaround.js
var before = function(regs, group, opts2) {
  const { indexN: indexN2 } = this.methods.one.pointer;
  let pre = [];
  let byN = indexN2(this.fullPointer);
  Object.keys(byN).forEach((k2) => {
    let first = byN[k2].sort((a2, b) => a2[1] > b[1] ? 1 : -1)[0];
    if (first[1] > 0) {
      pre.push([first[0], 0, first[1]]);
    }
  });
  let preWords = this.toView(pre);
  if (!regs) {
    return preWords;
  }
  return preWords.match(regs, group, opts2);
};
var after = function(regs, group, opts2) {
  const { indexN: indexN2 } = this.methods.one.pointer;
  let post = [];
  let byN = indexN2(this.fullPointer);
  let document = this.document;
  Object.keys(byN).forEach((k2) => {
    let last = byN[k2].sort((a2, b) => a2[1] > b[1] ? -1 : 1)[0];
    let [n3, , end2] = last;
    if (end2 < document[n3].length) {
      post.push([n3, end2, document[n3].length]);
    }
  });
  let postWords = this.toView(post);
  if (!regs) {
    return postWords;
  }
  return postWords.match(regs, group, opts2);
};
var growLeft = function(regs, group, opts2) {
  if (typeof regs === "string") {
    regs = this.world.methods.one.parseMatch(regs, opts2, this.world);
  }
  regs[regs.length - 1].end = true;
  let ptrs = this.fullPointer;
  this.forEach((m3, n3) => {
    let more = m3.before(regs, group);
    if (more.found) {
      let terms = more.terms();
      ptrs[n3][1] -= terms.length;
      ptrs[n3][3] = terms.docs[0][0].id;
    }
  });
  return this.update(ptrs);
};
var growRight = function(regs, group, opts2) {
  if (typeof regs === "string") {
    regs = this.world.methods.one.parseMatch(regs, opts2, this.world);
  }
  regs[0].start = true;
  let ptrs = this.fullPointer;
  this.forEach((m3, n3) => {
    let more = m3.after(regs, group);
    if (more.found) {
      let terms = more.terms();
      ptrs[n3][2] += terms.length;
      ptrs[n3][4] = null;
    }
  });
  return this.update(ptrs);
};
var grow = function(regs, group, opts2) {
  return this.growRight(regs, group, opts2).growLeft(regs, group, opts2);
};
var lookaround_default = { before, after, growLeft, growRight, grow };

// ../../node_modules/compromise/src/1-one/match/api/split.js
var combine = function(left, right) {
  return [left[0], left[1], right[2]];
};
var isArray5 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var getDoc = (reg, view, group) => {
  if (typeof reg === "string" || isArray5(reg)) {
    return view.match(reg, group);
  }
  if (!reg) {
    return view.none();
  }
  return reg;
};
var addIds2 = function(ptr, view) {
  let [n3, start2, end2] = ptr;
  if (view.document[n3] && view.document[n3][start2]) {
    ptr[3] = ptr[3] || view.document[n3][start2].id;
    if (view.document[n3][end2 - 1]) {
      ptr[4] = ptr[4] || view.document[n3][end2 - 1].id;
    }
  }
  return ptr;
};
var methods7 = {};
methods7.splitOn = function(m3, group) {
  const { splitAll: splitAll2 } = this.methods.one.pointer;
  let splits = getDoc(m3, this, group).fullPointer;
  let all4 = splitAll2(this.fullPointer, splits);
  let res = [];
  all4.forEach((o2) => {
    res.push(o2.passthrough);
    res.push(o2.before);
    res.push(o2.match);
    res.push(o2.after);
  });
  res = res.filter((p5) => p5);
  res = res.map((p5) => addIds2(p5, this));
  return this.update(res);
};
methods7.splitBefore = function(m3, group) {
  const { splitAll: splitAll2 } = this.methods.one.pointer;
  let splits = getDoc(m3, this, group).fullPointer;
  let all4 = splitAll2(this.fullPointer, splits);
  for (let i3 = 0; i3 < all4.length; i3 += 1) {
    if (!all4[i3].after && all4[i3 + 1] && all4[i3 + 1].before) {
      if (all4[i3].match && all4[i3].match[0] === all4[i3 + 1].before[0]) {
        all4[i3].after = all4[i3 + 1].before;
        delete all4[i3 + 1].before;
      }
    }
  }
  let res = [];
  all4.forEach((o2) => {
    res.push(o2.passthrough);
    res.push(o2.before);
    if (o2.match && o2.after) {
      res.push(combine(o2.match, o2.after));
    } else {
      res.push(o2.match);
    }
  });
  res = res.filter((p5) => p5);
  res = res.map((p5) => addIds2(p5, this));
  return this.update(res);
};
methods7.splitAfter = function(m3, group) {
  const { splitAll: splitAll2 } = this.methods.one.pointer;
  let splits = getDoc(m3, this, group).fullPointer;
  let all4 = splitAll2(this.fullPointer, splits);
  let res = [];
  all4.forEach((o2) => {
    res.push(o2.passthrough);
    if (o2.before && o2.match) {
      res.push(combine(o2.before, o2.match));
    } else {
      res.push(o2.before);
      res.push(o2.match);
    }
    res.push(o2.after);
  });
  res = res.filter((p5) => p5);
  res = res.map((p5) => addIds2(p5, this));
  return this.update(res);
};
methods7.split = methods7.splitAfter;
var split_default = methods7;

// ../../node_modules/compromise/src/1-one/match/api/index.js
var methods8 = Object.assign({}, match_default, lookaround_default, split_default);
methods8.lookBehind = methods8.before;
methods8.lookBefore = methods8.before;
methods8.lookAhead = methods8.after;
methods8.lookAfter = methods8.after;
methods8.notIf = methods8.ifNo;
var matchAPI = function(View2) {
  Object.assign(View2.prototype, methods8);
};
var api_default4 = matchAPI;

// ../../node_modules/compromise/src/1-one/match/methods/parseMatch/01-parseBlocks.js
var bySlashes = /(?:^|\s)([![^]*(?:<[^<]*>)?\/.*?[^\\/]\/[?\]+*$~]*)(?:\s|$)/;
var byParentheses = /([!~[^]*(?:<[^<]*>)?\([^)]+[^\\)]\)[?\]+*$~]*)(?:\s|$)/;
var byWord = / /g;
var isBlock = (str) => {
  return /^[![^]*(<[^<]*>)?\(/.test(str) && /\)[?\]+*$~]*$/.test(str);
};
var isReg = (str) => {
  return /^[![^]*(<[^<]*>)?\//.test(str) && /\/[?\]+*$~]*$/.test(str);
};
var cleanUp = function(arr) {
  arr = arr.map((str) => str.trim());
  arr = arr.filter((str) => str);
  return arr;
};
var parseBlocks = function(txt) {
  let arr = txt.split(bySlashes);
  let res = [];
  arr.forEach((str) => {
    if (isReg(str)) {
      res.push(str);
      return;
    }
    res = res.concat(str.split(byParentheses));
  });
  res = cleanUp(res);
  let final = [];
  res.forEach((str) => {
    if (isBlock(str)) {
      final.push(str);
    } else if (isReg(str)) {
      final.push(str);
    } else {
      final = final.concat(str.split(byWord));
    }
  });
  final = cleanUp(final);
  return final;
};
var parseBlocks_default = parseBlocks;

// ../../node_modules/compromise/src/1-one/match/methods/parseMatch/02-parseToken.js
var hasMinMax = /\{([0-9]+)?(, *[0-9]*)?\}/;
var andSign = /&&/;
var captureName = new RegExp(/^<\s*(\S+)\s*>/);
var titleCase2 = (str) => str.charAt(0).toUpperCase() + str.substring(1);
var end = (str) => str.charAt(str.length - 1);
var start = (str) => str.charAt(0);
var stripStart = (str) => str.substring(1);
var stripEnd = (str) => str.substring(0, str.length - 1);
var stripBoth = function(str) {
  str = stripStart(str);
  str = stripEnd(str);
  return str;
};
var parseToken = function(w, opts2) {
  let obj = {};
  for (let i3 = 0; i3 < 2; i3 += 1) {
    if (end(w) === "$") {
      obj.end = true;
      w = stripEnd(w);
    }
    if (start(w) === "^") {
      obj.start = true;
      w = stripStart(w);
    }
    if (end(w) === "?") {
      obj.optional = true;
      w = stripEnd(w);
    }
    if (start(w) === "[" || end(w) === "]") {
      obj.group = null;
      if (start(w) === "[") {
        obj.groupStart = true;
      }
      if (end(w) === "]") {
        obj.groupEnd = true;
      }
      w = w.replace(/^\[/, "");
      w = w.replace(/\]$/, "");
      if (start(w) === "<") {
        const res = captureName.exec(w);
        if (res.length >= 2) {
          obj.group = res[1];
          w = w.replace(res[0], "");
        }
      }
    }
    if (end(w) === "+") {
      obj.greedy = true;
      w = stripEnd(w);
    }
    if (w !== "*" && end(w) === "*" && w !== "\\*") {
      obj.greedy = true;
      w = stripEnd(w);
    }
    if (start(w) === "!") {
      obj.negative = true;
      w = stripStart(w);
    }
    if (start(w) === "~" && end(w) === "~" && w.length > 2) {
      w = stripBoth(w);
      obj.fuzzy = true;
      obj.min = opts2.fuzzy || 0.85;
      if (/\(/.test(w) === false) {
        obj.word = w;
        return obj;
      }
    }
    if (start(w) === "/" && end(w) === "/") {
      w = stripBoth(w);
      if (opts2.caseSensitive) {
        obj.use = "text";
      }
      obj.regex = new RegExp(w);
      return obj;
    }
    if (hasMinMax.test(w) === true) {
      w = w.replace(hasMinMax, (_a, b, c2) => {
        if (c2 === void 0) {
          obj.min = Number(b);
          obj.max = Number(b);
        } else {
          c2 = c2.replace(/, */, "");
          if (b === void 0) {
            obj.min = 0;
            obj.max = Number(c2);
          } else {
            obj.min = Number(b);
            obj.max = Number(c2 || 999);
          }
        }
        obj.greedy = true;
        if (!obj.min) {
          obj.optional = true;
        }
        return "";
      });
    }
    if (start(w) === "(" && end(w) === ")") {
      if (andSign.test(w)) {
        obj.choices = w.split(andSign);
        obj.operator = "and";
      } else {
        obj.choices = w.split("|");
        obj.operator = "or";
      }
      obj.choices[0] = stripStart(obj.choices[0]);
      let last = obj.choices.length - 1;
      obj.choices[last] = stripEnd(obj.choices[last]);
      obj.choices = obj.choices.map((s3) => s3.trim());
      obj.choices = obj.choices.filter((s3) => s3);
      obj.choices = obj.choices.map((str) => {
        return str.split(/ /g).map((s3) => parseToken(s3, opts2));
      });
      w = "";
    }
    if (start(w) === "{" && end(w) === "}") {
      w = stripBoth(w);
      obj.root = w;
      if (/\//.test(w)) {
        let split3 = obj.root.split(/\//);
        obj.root = split3[0];
        obj.pos = split3[1];
        if (obj.pos === "adj") {
          obj.pos = "Adjective";
        }
        obj.pos = obj.pos.charAt(0).toUpperCase() + obj.pos.substr(1).toLowerCase();
        if (split3[2] !== void 0) {
          obj.sense = split3[2];
        }
      }
      return obj;
    }
    if (start(w) === "<" && end(w) === ">") {
      w = stripBoth(w);
      obj.chunk = titleCase2(w);
      obj.greedy = true;
      return obj;
    }
    if (start(w) === "%" && end(w) === "%") {
      w = stripBoth(w);
      obj.switch = w;
      return obj;
    }
  }
  if (start(w) === "#") {
    obj.tag = stripStart(w);
    obj.tag = titleCase2(obj.tag);
    return obj;
  }
  if (start(w) === "@") {
    obj.method = stripStart(w);
    return obj;
  }
  if (w === ".") {
    obj.anything = true;
    return obj;
  }
  if (w === "*") {
    obj.anything = true;
    obj.greedy = true;
    obj.optional = true;
    return obj;
  }
  if (w) {
    w = w.replace("\\*", "*");
    w = w.replace("\\.", ".");
    if (opts2.caseSensitive) {
      obj.use = "text";
    } else {
      w = w.toLowerCase();
    }
    obj.word = w;
  }
  return obj;
};
var parseToken_default = parseToken;

// ../../node_modules/compromise/src/1-one/match/methods/parseMatch/03-splitHyphens.js
var hasDash = /[a-z0-9][-–—][a-z]/i;
var splitHyphens = function(regs, world2) {
  let prefixes2 = world2.model.one.prefixes;
  for (let i3 = regs.length - 1; i3 >= 0; i3 -= 1) {
    let reg = regs[i3];
    if (reg.word && hasDash.test(reg.word)) {
      let words = reg.word.split(/[-–—]/g);
      if (prefixes2.hasOwnProperty(words[0])) {
        continue;
      }
      words = words.filter((w) => w).reverse();
      regs.splice(i3, 1);
      words.forEach((w) => {
        let obj = Object.assign({}, reg);
        obj.word = w;
        regs.splice(i3, 0, obj);
      });
    }
  }
  return regs;
};
var splitHyphens_default = splitHyphens;

// ../../node_modules/compromise/src/1-one/match/methods/parseMatch/04-inflect-root.js
var addVerbs = function(token, world2) {
  let { all: all4 } = world2.methods.two.transform.verb || {};
  let str = token.root;
  if (!all4) {
    return [];
  }
  return all4(str, world2.model);
};
var addNoun = function(token, world2) {
  let { all: all4 } = world2.methods.two.transform.noun || {};
  if (!all4) {
    return [token.root];
  }
  return all4(token.root, world2.model);
};
var addAdjective = function(token, world2) {
  let { all: all4 } = world2.methods.two.transform.adjective || {};
  if (!all4) {
    return [token.root];
  }
  return all4(token.root, world2.model);
};
var inflectRoot = function(regs, world2) {
  regs = regs.map((token) => {
    if (token.root) {
      if (world2.methods.two && world2.methods.two.transform) {
        let choices = [];
        if (token.pos) {
          if (token.pos === "Verb") {
            choices = choices.concat(addVerbs(token, world2));
          } else if (token.pos === "Noun") {
            choices = choices.concat(addNoun(token, world2));
          } else if (token.pos === "Adjective") {
            choices = choices.concat(addAdjective(token, world2));
          }
        } else {
          choices = choices.concat(addVerbs(token, world2));
          choices = choices.concat(addNoun(token, world2));
          choices = choices.concat(addAdjective(token, world2));
        }
        choices = choices.filter((str) => str);
        if (choices.length > 0) {
          token.operator = "or";
          token.fastOr = new Set(choices);
        }
      } else {
        token.machine = token.root;
        delete token.id;
        delete token.root;
      }
    }
    return token;
  });
  return regs;
};
var inflect_root_default = inflectRoot;

// ../../node_modules/compromise/src/1-one/match/methods/parseMatch/05-postProcess.js
var nameGroups = function(regs) {
  let index3 = 0;
  let inGroup = null;
  for (let i3 = 0; i3 < regs.length; i3++) {
    const token = regs[i3];
    if (token.groupStart === true) {
      inGroup = token.group;
      if (inGroup === null) {
        inGroup = String(index3);
        index3 += 1;
      }
    }
    if (inGroup !== null) {
      token.group = inGroup;
    }
    if (token.groupEnd === true) {
      inGroup = null;
    }
  }
  return regs;
};
var doFastOrMode = function(tokens) {
  return tokens.map((token) => {
    if (token.choices !== void 0) {
      if (token.operator !== "or") {
        return token;
      }
      if (token.fuzzy === true) {
        return token;
      }
      let shouldPack = token.choices.every((block) => {
        if (block.length !== 1) {
          return false;
        }
        let reg = block[0];
        if (reg.fuzzy === true) {
          return false;
        }
        if (reg.start || reg.end) {
          return false;
        }
        if (reg.word !== void 0 && reg.negative !== true && reg.optional !== true && reg.method !== true) {
          return true;
        }
        return false;
      });
      if (shouldPack === true) {
        token.fastOr = /* @__PURE__ */ new Set();
        token.choices.forEach((block) => {
          token.fastOr.add(block[0].word);
        });
        delete token.choices;
      }
    }
    return token;
  });
};
var fuzzyOr = function(regs) {
  return regs.map((reg) => {
    if (reg.fuzzy && reg.choices) {
      reg.choices.forEach((r2) => {
        if (r2.length === 1 && r2[0].word) {
          r2[0].fuzzy = true;
          r2[0].min = reg.min;
        }
      });
    }
    return reg;
  });
};
var postProcess = function(regs) {
  regs = nameGroups(regs);
  regs = doFastOrMode(regs);
  regs = fuzzyOr(regs);
  return regs;
};
var postProcess_default = postProcess;

// ../../node_modules/compromise/src/1-one/match/methods/parseMatch/index.js
var syntax = function(input, opts2, world2) {
  if (input === null || input === void 0 || input === "") {
    return [];
  }
  opts2 = opts2 || {};
  if (typeof input === "number") {
    input = String(input);
  }
  let tokens = parseBlocks_default(input);
  tokens = tokens.map((str) => parseToken_default(str, opts2));
  tokens = splitHyphens_default(tokens, world2);
  tokens = inflect_root_default(tokens, world2);
  tokens = postProcess_default(tokens, opts2);
  return tokens;
};
var parseMatch_default = syntax;

// ../../node_modules/compromise/src/1-one/match/methods/match/01-failFast.js
var anyIntersection = function(setA, setB) {
  for (let elem of setB) {
    if (setA.has(elem)) {
      return true;
    }
  }
  return false;
};
var failFast = function(regs, cache2) {
  for (let i3 = 0; i3 < regs.length; i3 += 1) {
    let reg = regs[i3];
    if (reg.optional === true || reg.negative === true || reg.fuzzy === true) {
      continue;
    }
    if (reg.word !== void 0 && cache2.has(reg.word) === false) {
      return true;
    }
    if (reg.tag !== void 0 && cache2.has("#" + reg.tag) === false) {
      return true;
    }
    if (reg.fastOr && anyIntersection(reg.fastOr, cache2) === false) {
      return false;
    }
  }
  return false;
};
var failFast_default = failFast;

// ../../node_modules/compromise/src/1-one/match/methods/match/term/_fuzzy.js
var editDistance = function(strA, strB) {
  let aLength = strA.length, bLength = strB.length;
  if (aLength === 0) {
    return bLength;
  }
  if (bLength === 0) {
    return aLength;
  }
  let limit = (bLength > aLength ? bLength : aLength) + 1;
  if (Math.abs(aLength - bLength) > (limit || 100)) {
    return limit || 100;
  }
  let matrix = [];
  for (let i3 = 0; i3 < limit; i3++) {
    matrix[i3] = [i3];
    matrix[i3].length = limit;
  }
  for (let i3 = 0; i3 < limit; i3++) {
    matrix[0][i3] = i3;
  }
  let j2, a_index, b_index, cost, min2, t3;
  for (let i3 = 1; i3 <= aLength; ++i3) {
    a_index = strA[i3 - 1];
    for (j2 = 1; j2 <= bLength; ++j2) {
      if (i3 === j2 && matrix[i3][j2] > 4) {
        return aLength;
      }
      b_index = strB[j2 - 1];
      cost = a_index === b_index ? 0 : 1;
      min2 = matrix[i3 - 1][j2] + 1;
      if ((t3 = matrix[i3][j2 - 1] + 1) < min2)
        min2 = t3;
      if ((t3 = matrix[i3 - 1][j2 - 1] + cost) < min2)
        min2 = t3;
      let shouldUpdate = i3 > 1 && j2 > 1 && a_index === strB[j2 - 2] && strA[i3 - 2] === b_index && (t3 = matrix[i3 - 2][j2 - 2] + cost) < min2;
      if (shouldUpdate) {
        matrix[i3][j2] = t3;
      } else {
        matrix[i3][j2] = min2;
      }
    }
  }
  return matrix[aLength][bLength];
};
var fuzzyMatch = function(strA, strB, minLength = 3) {
  if (strA === strB) {
    return 1;
  }
  if (strA.length < minLength || strB.length < minLength) {
    return 0;
  }
  const steps = editDistance(strA, strB);
  let length2 = Math.max(strA.length, strB.length);
  let relative2 = length2 === 0 ? 0 : steps / length2;
  let similarity = 1 - relative2;
  return similarity;
};
var fuzzy_default = fuzzyMatch;

// ../../node_modules/compromise/src/1-one/match/methods/termMethods.js
var startQuote = /([\u0022\uFF02\u0027\u201C\u2018\u201F\u201B\u201E\u2E42\u201A\u00AB\u2039\u2035\u2036\u2037\u301D\u0060\u301F])/;
var endQuote = /([\u0022\uFF02\u0027\u201D\u2019\u00BB\u203A\u2032\u2033\u2034\u301E\u00B4])/;
var hasHyphen = /^[-–—]$/;
var hasDash2 = / [-–—]{1,3} /;
var hasPost = (term, punct) => term.post.indexOf(punct) !== -1;
var hasPre = (term, punct) => term.pre.indexOf(punct) !== -1;
var methods9 = {
  /** does it have a quotation symbol?  */
  hasQuote: (term) => startQuote.test(term.pre) || endQuote.test(term.post),
  /** does it have a comma?  */
  hasComma: (term) => hasPost(term, ","),
  /** does it end in a period? */
  hasPeriod: (term) => hasPost(term, ".") === true && hasPost(term, "...") === false,
  /** does it end in an exclamation */
  hasExclamation: (term) => hasPost(term, "!"),
  /** does it end with a question mark? */
  hasQuestionMark: (term) => hasPost(term, "?") || hasPost(term, "¿"),
  /** is there a ... at the end? */
  hasEllipses: (term) => hasPost(term, "..") || hasPost(term, "…") || hasPre(term, "..") || hasPre(term, "…"),
  /** is there a semicolon after term word? */
  hasSemicolon: (term) => hasPost(term, ";"),
  /** is there a colon after term word? */
  hasColon: (term) => hasPost(term, ":"),
  /** is there a slash '/' in term word? */
  hasSlash: (term) => /\//.test(term.text),
  /** a hyphen connects two words like-term */
  hasHyphen: (term) => hasHyphen.test(term.post) || hasHyphen.test(term.pre),
  /** a dash separates words - like that */
  hasDash: (term) => hasDash2.test(term.post) || hasDash2.test(term.pre),
  /** is it multiple words combinded */
  hasContraction: (term) => Boolean(term.implicit),
  /** is it an acronym */
  isAcronym: (term) => term.tags.has("Acronym"),
  /** does it have any tags */
  isKnown: (term) => term.tags.size > 0,
  /** uppercase first letter, then a lowercase */
  isTitleCase: (term) => /^\p{Lu}[a-z'\u00C0-\u00FF]/u.test(term.text),
  /** uppercase all letters */
  isUpperCase: (term) => /^\p{Lu}+$/u.test(term.text)
};
methods9.hasQuotation = methods9.hasQuote;
var termMethods_default = methods9;

// ../../node_modules/compromise/src/1-one/match/methods/match/term/doesMatch.js
var wrapMatch = function() {
};
var doesMatch = function(term, reg, index3, length2) {
  if (reg.anything === true) {
    return true;
  }
  if (reg.start === true && index3 !== 0) {
    return false;
  }
  if (reg.end === true && index3 !== length2 - 1) {
    return false;
  }
  if (reg.id !== void 0 && reg.id === term.id) {
    return true;
  }
  if (reg.word !== void 0) {
    if (reg.use) {
      return reg.word === term[reg.use];
    }
    if (term.machine !== null && term.machine === reg.word) {
      return true;
    }
    if (term.alias !== void 0 && term.alias.hasOwnProperty(reg.word)) {
      return true;
    }
    if (reg.fuzzy === true) {
      if (reg.word === term.root) {
        return true;
      }
      let score = fuzzy_default(reg.word, term.normal);
      if (score >= reg.min) {
        return true;
      }
    }
    if (term.alias && term.alias.some((str) => str === reg.word)) {
      return true;
    }
    return reg.word === term.text || reg.word === term.normal;
  }
  if (reg.tag !== void 0) {
    return term.tags.has(reg.tag) === true;
  }
  if (reg.method !== void 0) {
    if (typeof termMethods_default[reg.method] === "function" && termMethods_default[reg.method](term) === true) {
      return true;
    }
    return false;
  }
  if (reg.pre !== void 0) {
    return term.pre && term.pre.includes(reg.pre);
  }
  if (reg.post !== void 0) {
    return term.post && term.post.includes(reg.post);
  }
  if (reg.regex !== void 0) {
    let str = term.normal;
    if (reg.use) {
      str = term[reg.use];
    }
    return reg.regex.test(str);
  }
  if (reg.chunk !== void 0) {
    return term.chunk === reg.chunk;
  }
  if (reg.switch !== void 0) {
    return term.switch === reg.switch;
  }
  if (reg.machine !== void 0) {
    return term.normal === reg.machine || term.machine === reg.machine || term.root === reg.machine;
  }
  if (reg.sense !== void 0) {
    return term.sense === reg.sense;
  }
  if (reg.fastOr !== void 0) {
    if (reg.pos && !term.tags.has(reg.pos)) {
      return null;
    }
    let str = term.root || term.implicit || term.machine || term.normal;
    return reg.fastOr.has(str) || reg.fastOr.has(term.text);
  }
  if (reg.choices !== void 0) {
    if (reg.operator === "and") {
      return reg.choices.every((r2) => wrapMatch(term, r2, index3, length2));
    }
    return reg.choices.some((r2) => wrapMatch(term, r2, index3, length2));
  }
  return false;
};
wrapMatch = function(t3, reg, index3, length2) {
  let result = doesMatch(t3, reg, index3, length2);
  if (reg.negative === true) {
    return !result;
  }
  return result;
};
var doesMatch_default = wrapMatch;

// ../../node_modules/compromise/src/1-one/match/methods/match/steps/logic/greedy.js
var getGreedy = function(state, endReg) {
  let reg = Object.assign({}, state.regs[state.r], { start: false, end: false });
  let start2 = state.t;
  for (; state.t < state.terms.length; state.t += 1) {
    if (endReg && doesMatch_default(state.terms[state.t], endReg, state.start_i + state.t, state.phrase_length)) {
      return state.t;
    }
    let count = state.t - start2 + 1;
    if (reg.max !== void 0 && count === reg.max) {
      return state.t;
    }
    if (doesMatch_default(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length) === false) {
      if (reg.min !== void 0 && count < reg.min) {
        return null;
      }
      return state.t;
    }
  }
  return state.t;
};
var greedyTo = function(state, nextReg) {
  let t3 = state.t;
  if (!nextReg) {
    return state.terms.length;
  }
  for (; t3 < state.terms.length; t3 += 1) {
    if (doesMatch_default(state.terms[t3], nextReg, state.start_i + t3, state.phrase_length) === true) {
      return t3;
    }
  }
  return null;
};
var isEndGreedy = function(reg, state) {
  if (reg.end === true && reg.greedy === true) {
    if (state.start_i + state.t < state.phrase_length - 1) {
      let tmpReg = Object.assign({}, reg, { end: false });
      if (doesMatch_default(state.terms[state.t], tmpReg, state.start_i + state.t, state.phrase_length) === true) {
        return true;
      }
    }
  }
  return false;
};

// ../../node_modules/compromise/src/1-one/match/methods/match/_lib.js
var getGroup = function(state, term_index) {
  if (state.groups[state.inGroup]) {
    return state.groups[state.inGroup];
  }
  state.groups[state.inGroup] = {
    start: term_index,
    length: 0
  };
  return state.groups[state.inGroup];
};

// ../../node_modules/compromise/src/1-one/match/methods/match/steps/astrix.js
var doAstrix = function(state) {
  let { regs } = state;
  let reg = regs[state.r];
  let skipto = greedyTo(state, regs[state.r + 1]);
  if (skipto === null || skipto === 0) {
    return null;
  }
  if (reg.min !== void 0 && skipto - state.t < reg.min) {
    return null;
  }
  if (reg.max !== void 0 && skipto - state.t > reg.max) {
    state.t = state.t + reg.max;
    return true;
  }
  if (state.hasGroup === true) {
    const g3 = getGroup(state, state.t);
    g3.length = skipto - state.t;
  }
  state.t = skipto;
  return true;
};
var astrix_default = doAstrix;

// ../../node_modules/compromise/src/1-one/match/methods/match/steps/logic/and-or.js
var isArray6 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var doOrBlock = function(state, skipN = 0) {
  let block = state.regs[state.r];
  let wasFound = false;
  for (let c2 = 0; c2 < block.choices.length; c2 += 1) {
    let regs = block.choices[c2];
    if (!isArray6(regs)) {
      return false;
    }
    wasFound = regs.every((cr, w_index) => {
      let extra = 0;
      let t3 = state.t + w_index + skipN + extra;
      if (state.terms[t3] === void 0) {
        return false;
      }
      let foundBlock = doesMatch_default(state.terms[t3], cr, t3 + state.start_i, state.phrase_length);
      if (foundBlock === true && cr.greedy === true) {
        for (let i3 = 1; i3 < state.terms.length; i3 += 1) {
          let term = state.terms[t3 + i3];
          if (term) {
            let keepGoing = doesMatch_default(term, cr, state.start_i + i3, state.phrase_length);
            if (keepGoing === true) {
              extra += 1;
            } else {
              break;
            }
          }
        }
      }
      skipN += extra;
      return foundBlock;
    });
    if (wasFound) {
      skipN += regs.length;
      break;
    }
  }
  if (wasFound && block.greedy === true) {
    return doOrBlock(state, skipN);
  }
  return skipN;
};
var doAndBlock = function(state) {
  let longest = 0;
  let reg = state.regs[state.r];
  let allDidMatch = reg.choices.every((block) => {
    let allWords = block.every((cr, w_index) => {
      let tryTerm = state.t + w_index;
      if (state.terms[tryTerm] === void 0) {
        return false;
      }
      return doesMatch_default(state.terms[tryTerm], cr, tryTerm, state.phrase_length);
    });
    if (allWords === true && block.length > longest) {
      longest = block.length;
    }
    return allWords;
  });
  if (allDidMatch === true) {
    return longest;
  }
  return false;
};

// ../../node_modules/compromise/src/1-one/match/methods/match/steps/or-block.js
var orBlock = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let skipNum = doOrBlock(state);
  if (skipNum) {
    if (reg.negative === true) {
      return null;
    }
    if (state.hasGroup === true) {
      const g3 = getGroup(state, state.t);
      g3.length += skipNum;
    }
    if (reg.end === true) {
      let end2 = state.phrase_length;
      if (state.t + state.start_i + skipNum !== end2) {
        return null;
      }
    }
    state.t += skipNum;
    return true;
  } else if (!reg.optional) {
    return null;
  }
  return true;
};
var or_block_default = orBlock;

// ../../node_modules/compromise/src/1-one/match/methods/match/steps/and-block.js
var andBlock = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let skipNum = doAndBlock(state);
  if (skipNum) {
    if (reg.negative === true) {
      return null;
    }
    if (state.hasGroup === true) {
      const g3 = getGroup(state, state.t);
      g3.length += skipNum;
    }
    if (reg.end === true) {
      let end2 = state.phrase_length - 1;
      if (state.t + state.start_i !== end2) {
        return null;
      }
    }
    state.t += skipNum;
    return true;
  } else if (!reg.optional) {
    return null;
  }
  return true;
};
var and_block_default = andBlock;

// ../../node_modules/compromise/src/1-one/match/methods/match/steps/logic/negative-greedy.js
var negGreedy = function(state, reg, nextReg) {
  let skip = 0;
  for (let t3 = state.t; t3 < state.terms.length; t3 += 1) {
    let found = doesMatch_default(state.terms[t3], reg, state.start_i + state.t, state.phrase_length);
    if (found) {
      break;
    }
    if (nextReg) {
      found = doesMatch_default(state.terms[t3], nextReg, state.start_i + state.t, state.phrase_length);
      if (found) {
        break;
      }
    }
    skip += 1;
    if (reg.max !== void 0 && skip === reg.max) {
      break;
    }
  }
  if (skip === 0) {
    return false;
  }
  if (reg.min && reg.min > skip) {
    return false;
  }
  state.t += skip;
  return true;
};
var negative_greedy_default = negGreedy;

// ../../node_modules/compromise/src/1-one/match/methods/match/steps/negative.js
var doNegative = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let tmpReg = Object.assign({}, reg);
  tmpReg.negative = false;
  let found = doesMatch_default(state.terms[state.t], tmpReg, state.start_i + state.t, state.phrase_length);
  if (found) {
    return false;
  }
  if (reg.optional) {
    let nextReg = regs[state.r + 1];
    if (nextReg) {
      let fNext = doesMatch_default(state.terms[state.t], nextReg, state.start_i + state.t, state.phrase_length);
      if (fNext) {
        state.r += 1;
      } else if (nextReg.optional && regs[state.r + 2]) {
        let fNext2 = doesMatch_default(state.terms[state.t], regs[state.r + 2], state.start_i + state.t, state.phrase_length);
        if (fNext2) {
          state.r += 2;
        }
      }
    }
  }
  if (reg.greedy) {
    return negative_greedy_default(state, tmpReg, regs[state.r + 1]);
  }
  state.t += 1;
  return true;
};
var negative_default = doNegative;

// ../../node_modules/compromise/src/1-one/match/methods/match/steps/optional-match.js
var foundOptional = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let term = state.terms[state.t];
  let nextRegMatched = doesMatch_default(term, regs[state.r + 1], state.start_i + state.t, state.phrase_length);
  if (reg.negative || nextRegMatched) {
    let nextTerm = state.terms[state.t + 1];
    if (!nextTerm || !doesMatch_default(nextTerm, regs[state.r + 1], state.start_i + state.t, state.phrase_length)) {
      state.r += 1;
    }
  }
};
var optional_match_default = foundOptional;

// ../../node_modules/compromise/src/1-one/match/methods/match/steps/greedy-match.js
var greedyMatch = function(state) {
  const { regs, phrase_length } = state;
  let reg = regs[state.r];
  state.t = getGreedy(state, regs[state.r + 1]);
  if (state.t === null) {
    return null;
  }
  if (reg.min && reg.min > state.t) {
    return null;
  }
  if (reg.end === true && state.start_i + state.t !== phrase_length) {
    return null;
  }
  return true;
};
var greedy_match_default = greedyMatch;

// ../../node_modules/compromise/src/1-one/match/methods/match/steps/contraction-skip.js
var contractionSkip = function(state) {
  let term = state.terms[state.t];
  let reg = state.regs[state.r];
  if (term.implicit && state.terms[state.t + 1]) {
    let nextTerm = state.terms[state.t + 1];
    if (!nextTerm.implicit) {
      return;
    }
    if (reg.word === term.normal) {
      state.t += 1;
    }
    if (reg.method === "hasContraction") {
      state.t += 1;
    }
  }
};
var contraction_skip_default = contractionSkip;

// ../../node_modules/compromise/src/1-one/match/methods/match/steps/simple-match.js
var setGroup = function(state, startAt) {
  let reg = state.regs[state.r];
  const g3 = getGroup(state, startAt);
  if (state.t > 1 && reg.greedy) {
    g3.length += state.t - startAt;
  } else {
    g3.length++;
  }
};
var simpleMatch = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let term = state.terms[state.t];
  let startAt = state.t;
  if (reg.optional && regs[state.r + 1] && reg.negative) {
    return true;
  }
  if (reg.optional && regs[state.r + 1]) {
    optional_match_default(state);
  }
  if (term.implicit && state.terms[state.t + 1]) {
    contraction_skip_default(state);
  }
  state.t += 1;
  if (reg.end === true && state.t !== state.terms.length && reg.greedy !== true) {
    return null;
  }
  if (reg.greedy === true) {
    let alive = greedy_match_default(state);
    if (!alive) {
      return null;
    }
  }
  if (state.hasGroup === true) {
    setGroup(state, startAt);
  }
  return true;
};
var simple_match_default = simpleMatch;

// ../../node_modules/compromise/src/1-one/match/methods/match/02-from-here.js
var tryHere = function(terms, regs, start_i, phrase_length) {
  if (terms.length === 0 || regs.length === 0) {
    return null;
  }
  let state = {
    t: 0,
    terms,
    r: 0,
    regs,
    groups: {},
    start_i,
    phrase_length,
    inGroup: null
  };
  for (; state.r < regs.length; state.r += 1) {
    let reg = regs[state.r];
    state.hasGroup = Boolean(reg.group);
    if (state.hasGroup === true) {
      state.inGroup = reg.group;
    } else {
      state.inGroup = null;
    }
    if (!state.terms[state.t]) {
      const alive = regs.slice(state.r).some((remain) => !remain.optional);
      if (alive === false) {
        break;
      }
      return null;
    }
    if (reg.anything === true && reg.greedy === true) {
      let alive = astrix_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.choices !== void 0 && reg.operator === "or") {
      let alive = or_block_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.choices !== void 0 && reg.operator === "and") {
      let alive = and_block_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.anything === true) {
      if (reg.negative && reg.anything) {
        return null;
      }
      let alive = simple_match_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (isEndGreedy(reg, state) === true) {
      let alive = simple_match_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.negative) {
      let alive = negative_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    let hasMatch = doesMatch_default(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length);
    if (hasMatch === true) {
      let alive = simple_match_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.optional === true) {
      continue;
    }
    return null;
  }
  let pntr = [null, start_i, state.t + start_i];
  if (pntr[1] === pntr[2]) {
    return null;
  }
  let groups = {};
  Object.keys(state.groups).forEach((k2) => {
    let o2 = state.groups[k2];
    let start2 = start_i + o2.start;
    groups[k2] = [null, start2, start2 + o2.length];
  });
  return { pointer: pntr, groups };
};
var from_here_default = tryHere;

// ../../node_modules/compromise/src/1-one/match/methods/match/03-getGroup.js
var getGroup2 = function(res, group) {
  let ptrs = [];
  let byGroup = {};
  if (res.length === 0) {
    return { ptrs, byGroup };
  }
  if (typeof group === "number") {
    group = String(group);
  }
  if (group) {
    res.forEach((r2) => {
      if (r2.groups[group]) {
        ptrs.push(r2.groups[group]);
      }
    });
  } else {
    res.forEach((r2) => {
      ptrs.push(r2.pointer);
      Object.keys(r2.groups).forEach((k2) => {
        byGroup[k2] = byGroup[k2] || [];
        byGroup[k2].push(r2.groups[k2]);
      });
    });
  }
  return { ptrs, byGroup };
};
var getGroup_default = getGroup2;

// ../../node_modules/compromise/src/1-one/match/methods/match/03-notIf.js
var notIf = function(results, not, docs) {
  results = results.filter((res) => {
    let [n3, start2, end2] = res.pointer;
    let terms = docs[n3].slice(start2, end2);
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let slice = terms.slice(i3);
      let found = from_here_default(slice, not, i3, terms.length);
      if (found !== null) {
        return false;
      }
    }
    return true;
  });
  return results;
};
var notIf_default = notIf;

// ../../node_modules/compromise/src/1-one/match/methods/match/index.js
var addSentence = function(res, n3) {
  res.pointer[0] = n3;
  Object.keys(res.groups).forEach((k2) => {
    res.groups[k2][0] = n3;
  });
  return res;
};
var handleStart = function(terms, regs, n3) {
  let res = from_here_default(terms, regs, 0, terms.length);
  if (res) {
    res = addSentence(res, n3);
    return res;
  }
  return null;
};
var runMatch = function(docs, todo, cache2) {
  cache2 = cache2 || [];
  let { regs, group, justOne } = todo;
  let results = [];
  if (!regs || regs.length === 0) {
    return { ptrs: [], byGroup: {} };
  }
  const minLength = regs.filter((r2) => r2.optional !== true && r2.negative !== true).length;
  docs:
    for (let n3 = 0; n3 < docs.length; n3 += 1) {
      let terms = docs[n3];
      if (cache2[n3] && failFast_default(regs, cache2[n3])) {
        continue;
      }
      if (regs[0].start === true) {
        let foundStart = handleStart(terms, regs, n3, group);
        if (foundStart) {
          results.push(foundStart);
        }
        continue;
      }
      for (let i3 = 0; i3 < terms.length; i3 += 1) {
        let slice = terms.slice(i3);
        if (slice.length < minLength) {
          break;
        }
        let res = from_here_default(slice, regs, i3, terms.length);
        if (res) {
          res = addSentence(res, n3);
          results.push(res);
          if (justOne === true) {
            break docs;
          }
          let end2 = res.pointer[2];
          if (Math.abs(end2 - 1) > i3) {
            i3 = Math.abs(end2 - 1);
          }
        }
      }
    }
  if (regs[regs.length - 1].end === true) {
    results = results.filter((res) => {
      let n3 = res.pointer[0];
      return docs[n3].length === res.pointer[2];
    });
  }
  if (todo.notIf) {
    results = notIf_default(results, todo.notIf, docs);
  }
  results = getGroup_default(results, group);
  results.ptrs.forEach((ptr) => {
    let [n3, start2, end2] = ptr;
    ptr[3] = docs[n3][start2].id;
    ptr[4] = docs[n3][end2 - 1].id;
  });
  return results;
};
var match_default2 = runMatch;

// ../../node_modules/compromise/src/1-one/match/methods/index.js
var methods10 = {
  one: {
    termMethods: termMethods_default,
    parseMatch: parseMatch_default,
    match: match_default2
  }
};
var methods_default4 = methods10;

// ../../node_modules/compromise/src/1-one/match/lib.js
var lib_default2 = {
  /** pre-parse any match statements */
  parseMatch: function(str, opts2) {
    const world2 = this.world();
    let killUnicode2 = world2.methods.one.killUnicode;
    if (killUnicode2) {
      str = killUnicode2(str, world2);
    }
    return world2.methods.one.parseMatch(str, opts2, world2);
  }
};

// ../../node_modules/compromise/src/1-one/match/plugin.js
var plugin_default6 = {
  api: api_default4,
  methods: methods_default4,
  lib: lib_default2
};

// ../../node_modules/compromise/src/1-one/output/api/html.js
var isClass = /^\../;
var isId = /^#./;
var escapeXml = (str) => {
  str = str.replace(/&/g, "&amp;");
  str = str.replace(/</g, "&lt;");
  str = str.replace(/>/g, "&gt;");
  str = str.replace(/"/g, "&quot;");
  str = str.replace(/'/g, "&apos;");
  return str;
};
var toTag = function(k2) {
  let start2 = "";
  let end2 = "</span>";
  k2 = escapeXml(k2);
  if (isClass.test(k2)) {
    start2 = `<span class="${k2.replace(/^\./, "")}"`;
  } else if (isId.test(k2)) {
    start2 = `<span id="${k2.replace(/^#/, "")}"`;
  } else {
    start2 = `<${k2}`;
    end2 = `</${k2}>`;
  }
  start2 += ">";
  return { start: start2, end: end2 };
};
var getIndex = function(doc, obj) {
  let starts = {};
  let ends = {};
  Object.keys(obj).forEach((k2) => {
    let res = obj[k2];
    let tag = toTag(k2);
    if (typeof res === "string") {
      res = doc.match(res);
    }
    res.docs.forEach((terms) => {
      if (terms.every((t3) => t3.implicit)) {
        return;
      }
      let a2 = terms[0].id;
      starts[a2] = starts[a2] || [];
      starts[a2].push(tag.start);
      let b = terms[terms.length - 1].id;
      ends[b] = ends[b] || [];
      ends[b].push(tag.end);
    });
  });
  return { starts, ends };
};
var html = function(obj) {
  let { starts, ends } = getIndex(this, obj);
  let out2 = "";
  this.docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let t3 = terms[i3];
      if (starts.hasOwnProperty(t3.id)) {
        out2 += starts[t3.id].join("");
      }
      out2 += t3.pre || "" + t3.text || "";
      if (ends.hasOwnProperty(t3.id)) {
        out2 += ends[t3.id].join("");
      }
      out2 += t3.post || "";
    }
  });
  return out2;
};
var html_default = { html };

// ../../node_modules/compromise/src/1-one/output/api/lib/_text.js
var trimEnd = /[,:;)\]*.?~!\u0022\uFF02\u201D\u2019\u00BB\u203A\u2032\u2033\u2034\u301E\u00B4—-]+$/;
var trimStart = /^[(['"*~\uFF02\u201C\u2018\u201F\u201B\u201E\u2E42\u201A\u00AB\u2039\u2035\u2036\u2037\u301D\u0060\u301F]+/;
var punctToKill = /[,:;)('"\u201D\]]/;
var isHyphen = /^[-–—]$/;
var hasSpace = / /;
var textFromTerms = function(terms, opts2, keepSpace = true) {
  let txt = "";
  terms.forEach((t3) => {
    let pre = t3.pre || "";
    let post = t3.post || "";
    if (opts2.punctuation === "some") {
      pre = pre.replace(trimStart, "");
      if (isHyphen.test(post)) {
        post = " ";
      }
      post = post.replace(punctToKill, "");
      post = post.replace(/\?!+/, "?");
      post = post.replace(/!+/, "!");
      post = post.replace(/\?+/, "?");
      post = post.replace(/\.{2,}/, "");
      if (t3.tags.has("Abbreviation")) {
        post = post.replace(/\./, "");
      }
    }
    if (opts2.whitespace === "some") {
      pre = pre.replace(/\s/, "");
      post = post.replace(/\s+/, " ");
    }
    if (!opts2.keepPunct) {
      pre = pre.replace(trimStart, "");
      if (post === "-") {
        post = " ";
      } else {
        post = post.replace(trimEnd, "");
      }
    }
    let word = t3[opts2.form || "text"] || t3.normal || "";
    if (opts2.form === "implicit") {
      word = t3.implicit || t3.text;
    }
    if (opts2.form === "root" && t3.implicit) {
      word = t3.root || t3.implicit || t3.normal;
    }
    if ((opts2.form === "machine" || opts2.form === "implicit" || opts2.form === "root") && t3.implicit) {
      if (!post || !hasSpace.test(post)) {
        post += " ";
      }
    }
    txt += pre + word + post;
  });
  if (keepSpace === false) {
    txt = txt.trim();
  }
  if (opts2.lowerCase === true) {
    txt = txt.toLowerCase();
  }
  return txt;
};
var textFromDoc = function(docs, opts2) {
  let text = "";
  if (!docs || !docs[0] || !docs[0][0]) {
    return text;
  }
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    text += textFromTerms(docs[i3], opts2, true);
  }
  if (!opts2.keepSpace) {
    text = text.trim();
  }
  if (opts2.keepEndPunct === false) {
    if (!docs[0][0].tags.has("Emoticon")) {
      text = text.replace(trimStart, "");
    }
    let last = docs[docs.length - 1];
    if (!last[last.length - 1].tags.has("Emoticon")) {
      text = text.replace(trimEnd, "");
    }
  }
  if (opts2.cleanWhitespace === true) {
    text = text.trim();
  }
  return text;
};

// ../../node_modules/compromise/src/1-one/output/api/_fmts.js
var fmts = {
  text: {
    form: "text"
  },
  normal: {
    whitespace: "some",
    punctuation: "some",
    case: "some",
    unicode: "some",
    form: "normal"
  },
  machine: {
    keepSpace: false,
    whitespace: "some",
    punctuation: "some",
    case: "none",
    unicode: "some",
    form: "machine"
  },
  root: {
    keepSpace: false,
    whitespace: "some",
    punctuation: "some",
    case: "some",
    unicode: "some",
    form: "root"
  },
  implicit: {
    form: "implicit"
  }
};
fmts.clean = fmts.normal;
fmts.reduced = fmts.root;
var fmts_default = fmts;

// ../../node_modules/compromise/src/1-one/output/api/lib/hash.js
var k = [];
var i = 0;
for (; i < 64; ) {
  k[i] = 0 | Math.sin(++i % Math.PI) * 4294967296;
}
function md5(s3) {
  let b, c2, d2, h2 = [b = 1732584193, c2 = 4023233417, ~b, ~c2], words = [], j2 = decodeURI(encodeURI(s3)) + "", a2 = j2.length;
  s3 = --a2 / 4 + 2 | 15;
  words[--s3] = a2 * 8;
  for (; ~a2; ) {
    words[a2 >> 2] |= j2.charCodeAt(a2) << 8 * a2--;
  }
  for (i = j2 = 0; i < s3; i += 16) {
    a2 = h2;
    for (; j2 < 64; a2 = [
      d2 = a2[3],
      b + ((d2 = a2[0] + [
        b & c2 | ~b & d2,
        d2 & b | ~d2 & c2,
        b ^ c2 ^ d2,
        c2 ^ (b | ~d2)
      ][a2 = j2 >> 4] + k[j2] + ~~words[i | [
        j2,
        5 * j2 + 1,
        3 * j2 + 5,
        7 * j2
      ][a2] & 15]) << (a2 = [
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21
      ][4 * a2 + j2++ % 4]) | d2 >>> -a2),
      b,
      c2
    ]) {
      b = a2[1] | 0;
      c2 = a2[2];
    }
    for (j2 = 4; j2; )
      h2[--j2] += a2[j2];
  }
  for (s3 = ""; j2 < 32; ) {
    s3 += (h2[j2 >> 3] >> (1 ^ j2++) * 4 & 15).toString(16);
  }
  return s3;
}

// ../../node_modules/compromise/src/1-one/output/api/json.js
var defaults = {
  text: true,
  terms: true
};
var opts = { case: "none", unicode: "some", form: "machine", punctuation: "some" };
var merge = function(a2, b) {
  return Object.assign({}, a2, b);
};
var fns4 = {
  text: (terms) => textFromTerms(terms, { keepPunct: true }, false),
  normal: (terms) => textFromTerms(terms, merge(fmts_default.normal, { keepPunct: true }), false),
  implicit: (terms) => textFromTerms(terms, merge(fmts_default.implicit, { keepPunct: true }), false),
  machine: (terms) => textFromTerms(terms, opts, false),
  root: (terms) => textFromTerms(terms, merge(opts, { form: "root" }), false),
  hash: (terms) => md5(textFromTerms(terms, { keepPunct: true }, false)),
  offset: (terms) => {
    let len = fns4.text(terms).length;
    return {
      index: terms[0].offset.index,
      start: terms[0].offset.start,
      length: len
    };
  },
  terms: (terms) => {
    return terms.map((t3) => {
      let term = Object.assign({}, t3);
      term.tags = Array.from(t3.tags);
      return term;
    });
  },
  confidence: (_terms, view, i3) => view.eq(i3).confidence(),
  syllables: (_terms, view, i3) => view.eq(i3).syllables(),
  sentence: (_terms, view, i3) => view.eq(i3).fullSentence().text(),
  dirty: (terms) => terms.some((t3) => t3.dirty === true)
};
fns4.sentences = fns4.sentence;
fns4.clean = fns4.normal;
fns4.reduced = fns4.root;
var toJSON = function(view, option) {
  option = option || {};
  if (typeof option === "string") {
    option = {};
  }
  option = Object.assign({}, defaults, option);
  if (option.offset) {
    view.compute("offset");
  }
  return view.docs.map((terms, i3) => {
    let res = {};
    Object.keys(option).forEach((k2) => {
      if (option[k2] && fns4[k2]) {
        res[k2] = fns4[k2](terms, view, i3);
      }
    });
    return res;
  });
};
var methods11 = {
  /** return data */
  json: function(n3) {
    let res = toJSON(this, n3);
    if (typeof n3 === "number") {
      return res[n3];
    }
    return res;
  }
};
methods11.data = methods11.json;
var json_default = methods11;

// ../../node_modules/compromise/src/1-one/output/api/debug/client-side.js
var logClientSide = function(view) {
  console.log("%c -=-=- ", "background-color:#6699cc;");
  view.forEach((m3) => {
    console.groupCollapsed(m3.text());
    let terms = m3.docs[0];
    let out2 = terms.map((t3) => {
      let text = t3.text || "-";
      if (t3.implicit) {
        text = "[" + t3.implicit + "]";
      }
      let tags = "[" + Array.from(t3.tags).join(", ") + "]";
      return { text, tags };
    });
    console.table(out2, ["text", "tags"]);
    console.groupEnd();
  });
};
var client_side_default = logClientSide;

// ../../node_modules/compromise/src/1-one/output/api/debug/_color.js
var reset = "\x1B[0m";
var cli = {
  green: (str) => "\x1B[32m" + str + reset,
  red: (str) => "\x1B[31m" + str + reset,
  blue: (str) => "\x1B[34m" + str + reset,
  magenta: (str) => "\x1B[35m" + str + reset,
  cyan: (str) => "\x1B[36m" + str + reset,
  yellow: (str) => "\x1B[33m" + str + reset,
  black: (str) => "\x1B[30m" + str + reset,
  dim: (str) => "\x1B[2m" + str + reset,
  i: (str) => "\x1B[3m" + str + reset
};
var color_default = cli;

// ../../node_modules/compromise/src/1-one/output/api/debug/tags.js
var tagString = function(tags, model5) {
  if (model5.one.tagSet) {
    tags = tags.map((tag) => {
      if (!model5.one.tagSet.hasOwnProperty(tag)) {
        return tag;
      }
      const c2 = model5.one.tagSet[tag].color || "blue";
      return color_default[c2](tag);
    });
  }
  return tags.join(", ");
};
var showTags = function(view) {
  let { docs, model: model5 } = view;
  if (docs.length === 0) {
    console.log(color_default.blue("\n     ──────"));
  }
  docs.forEach((terms) => {
    console.log(color_default.blue("\n  ┌─────────"));
    terms.forEach((t3) => {
      let tags = [...t3.tags || []];
      let text = t3.text || "-";
      if (t3.sense) {
        text = `{${t3.normal}/${t3.sense}}`;
      }
      if (t3.implicit) {
        text = "[" + t3.implicit + "]";
      }
      text = color_default.yellow(text);
      let word = "'" + text + "'";
      if (t3.reference) {
        let str2 = view.update([t3.reference]).text("normal");
        word += ` - ${color_default.dim(color_default.i("[" + str2 + "]"))}`;
      }
      word = word.padEnd(18);
      let str = color_default.blue("  │ ") + color_default.i(word) + "  - " + tagString(tags, model5);
      console.log(str);
    });
  });
};
var tags_default = showTags;

// ../../node_modules/compromise/src/1-one/output/api/debug/chunks.js
var showChunks = function(view) {
  let { docs } = view;
  console.log("");
  docs.forEach((terms) => {
    let out2 = [];
    terms.forEach((term) => {
      if (term.chunk === "Noun") {
        out2.push(color_default.blue(term.implicit || term.normal));
      } else if (term.chunk === "Verb") {
        out2.push(color_default.green(term.implicit || term.normal));
      } else if (term.chunk === "Adjective") {
        out2.push(color_default.yellow(term.implicit || term.normal));
      } else if (term.chunk === "Pivot") {
        out2.push(color_default.red(term.implicit || term.normal));
      } else {
        out2.push(term.implicit || term.normal);
      }
    });
    console.log(out2.join(" "), "\n");
  });
};
var chunks_default = showChunks;

// ../../node_modules/compromise/src/1-one/output/api/debug/highlight.js
var split = (txt, offset2, index3) => {
  let buff = index3 * 9;
  let start2 = offset2.start + buff;
  let end2 = start2 + offset2.length;
  let pre = txt.substring(0, start2);
  let mid = txt.substring(start2, end2);
  let post = txt.substring(end2, txt.length);
  return [pre, mid, post];
};
var spliceIn = function(txt, offset2, index3) {
  let parts = split(txt, offset2, index3);
  return `${parts[0]}${color_default.blue(parts[1])}${parts[2]}`;
};
var showHighlight = function(doc) {
  if (!doc.found) {
    return;
  }
  let bySentence = {};
  doc.fullPointer.forEach((ptr) => {
    bySentence[ptr[0]] = bySentence[ptr[0]] || [];
    bySentence[ptr[0]].push(ptr);
  });
  Object.keys(bySentence).forEach((k2) => {
    let full = doc.update([[Number(k2)]]);
    let txt = full.text();
    let matches3 = doc.update(bySentence[k2]);
    let json = matches3.json({ offset: true });
    json.forEach((obj, i3) => {
      txt = spliceIn(txt, obj.offset, i3);
    });
    console.log(txt);
  });
};
var highlight_default = showHighlight;

// ../../node_modules/compromise/src/1-one/output/api/debug/index.js
function isClientSide() {
  return typeof window !== "undefined" && window.document;
}
var debug = function(opts2 = {}) {
  let view = this;
  if (typeof opts2 === "string") {
    let tmp = {};
    tmp[opts2] = true;
    opts2 = tmp;
  }
  if (isClientSide()) {
    client_side_default(view);
    return view;
  }
  if (opts2.tags !== false) {
    tags_default(view);
    console.log("\n");
  }
  if (opts2.chunks === true) {
    chunks_default(view);
    console.log("\n");
  }
  if (opts2.highlight === true) {
    highlight_default(view);
    console.log("\n");
  }
  return view;
};
var debug_default = debug;

// ../../node_modules/compromise/src/1-one/output/api/wrap.js
var toText = function(term) {
  let pre = term.pre || "";
  let post = term.post || "";
  return pre + term.text + post;
};
var findStarts = function(doc, obj) {
  let starts = {};
  Object.keys(obj).forEach((reg) => {
    let m3 = doc.match(reg);
    m3.fullPointer.forEach((a2) => {
      starts[a2[3]] = { fn: obj[reg], end: a2[2] };
    });
  });
  return starts;
};
var wrap = function(doc, obj) {
  let starts = findStarts(doc, obj);
  let text = "";
  doc.docs.forEach((terms, n3) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let t3 = terms[i3];
      if (starts.hasOwnProperty(t3.id)) {
        let { fn, end: end2 } = starts[t3.id];
        let m3 = doc.update([[n3, i3, end2]]);
        text += terms[i3].pre || "";
        text += fn(m3);
        i3 = end2 - 1;
        text += terms[i3].post || "";
      } else {
        text += toText(t3);
      }
    }
  });
  return text;
};
var wrap_default = wrap;

// ../../node_modules/compromise/src/1-one/output/api/out.js
var isObject5 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var topk = function(arr) {
  let obj = {};
  arr.forEach((a2) => {
    obj[a2] = obj[a2] || 0;
    obj[a2] += 1;
  });
  let res = Object.keys(obj).map((k2) => {
    return { normal: k2, count: obj[k2] };
  });
  return res.sort((a2, b) => a2.count > b.count ? -1 : 0);
};
var out = function(method) {
  if (isObject5(method)) {
    return wrap_default(this, method);
  }
  if (method === "text") {
    return this.text();
  }
  if (method === "normal") {
    return this.text("normal");
  }
  if (method === "root") {
    return this.text("root");
  }
  if (method === "machine" || method === "reduced") {
    return this.text("machine");
  }
  if (method === "hash" || method === "md5") {
    return md5(this.text());
  }
  if (method === "json") {
    return this.json();
  }
  if (method === "offset" || method === "offsets") {
    this.compute("offset");
    return this.json({ offset: true });
  }
  if (method === "array") {
    let arr = this.docs.map((terms) => {
      return terms.reduce((str, t3) => {
        return str + t3.pre + t3.text + t3.post;
      }, "").trim();
    });
    return arr.filter((str) => str);
  }
  if (method === "freq" || method === "frequency" || method === "topk") {
    return topk(this.json({ normal: true }).map((o2) => o2.normal));
  }
  if (method === "terms") {
    let list4 = [];
    this.docs.forEach((s3) => {
      let terms = s3.terms.map((t3) => t3.text);
      terms = terms.filter((t3) => t3);
      list4 = list4.concat(terms);
    });
    return list4;
  }
  if (method === "tags") {
    return this.docs.map((terms) => {
      return terms.reduce((h2, t3) => {
        h2[t3.implicit || t3.normal] = Array.from(t3.tags);
        return h2;
      }, {});
    });
  }
  if (method === "debug") {
    return this.debug();
  }
  return this.text();
};
var methods12 = {
  /** */
  debug: debug_default,
  /** */
  out,
  /** */
  wrap: function(obj) {
    return wrap_default(this, obj);
  }
};
var out_default = methods12;

// ../../node_modules/compromise/src/1-one/output/api/text.js
var isObject6 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var text_default = {
  /** */
  text: function(fmt2) {
    let opts2 = {};
    if (fmt2 && typeof fmt2 === "string" && fmts_default.hasOwnProperty(fmt2)) {
      opts2 = Object.assign({}, fmts_default[fmt2]);
    } else if (fmt2 && isObject6(fmt2)) {
      opts2 = Object.assign({}, fmt2);
    }
    if (opts2.keepSpace === void 0 && !this.isFull()) {
      opts2.keepSpace = false;
    }
    if (opts2.keepEndPunct === void 0 && this.pointer) {
      let ptr = this.pointer[0];
      if (ptr && ptr[1]) {
        opts2.keepEndPunct = false;
      } else {
        opts2.keepEndPunct = true;
      }
    }
    if (opts2.keepPunct === void 0) {
      opts2.keepPunct = true;
    }
    if (opts2.keepSpace === void 0) {
      opts2.keepSpace = true;
    }
    return textFromDoc(this.docs, opts2);
  }
};

// ../../node_modules/compromise/src/1-one/output/api/index.js
var methods13 = Object.assign({}, out_default, text_default, json_default, html_default);
var addAPI3 = function(View2) {
  Object.assign(View2.prototype, methods13);
};
var api_default5 = addAPI3;

// ../../node_modules/compromise/src/1-one/output/plugin.js
var plugin_default7 = {
  api: api_default5,
  methods: {
    one: {
      hash: md5
    }
  }
};

// ../../node_modules/compromise/src/1-one/pointers/api/lib/_lib.js
var doesOverlap = function(a2, b) {
  if (a2[0] !== b[0]) {
    return false;
  }
  let [, startA, endA] = a2;
  let [, startB, endB] = b;
  if (startA <= startB && endA > startB) {
    return true;
  }
  if (startB <= startA && endB > startA) {
    return true;
  }
  return false;
};
var getExtent = function(ptrs) {
  let min2 = ptrs[0][1];
  let max3 = ptrs[0][2];
  ptrs.forEach((ptr) => {
    if (ptr[1] < min2) {
      min2 = ptr[1];
    }
    if (ptr[2] > max3) {
      max3 = ptr[2];
    }
  });
  return [ptrs[0][0], min2, max3];
};
var indexN = function(ptrs) {
  let byN = {};
  ptrs.forEach((ref) => {
    byN[ref[0]] = byN[ref[0]] || [];
    byN[ref[0]].push(ref);
  });
  return byN;
};
var uniquePtrs = function(arr) {
  let obj = {};
  for (let i3 = 0; i3 < arr.length; i3 += 1) {
    obj[arr[i3].join(",")] = arr[i3];
  }
  return Object.values(obj);
};

// ../../node_modules/compromise/src/1-one/pointers/api/lib/split.js
var pivotBy = function(full, m3) {
  let [n3, start2] = full;
  let mStart = m3[1];
  let mEnd = m3[2];
  let res = {};
  if (start2 < mStart) {
    let end2 = mStart < full[2] ? mStart : full[2];
    res.before = [n3, start2, end2];
  }
  res.match = m3;
  if (full[2] > mEnd) {
    res.after = [n3, mEnd, full[2]];
  }
  return res;
};
var doesMatch2 = function(full, m3) {
  return full[1] <= m3[1] && m3[2] <= full[2];
};
var splitAll = function(full, m3) {
  let byN = indexN(m3);
  let res = [];
  full.forEach((ptr) => {
    let [n3] = ptr;
    let matches3 = byN[n3] || [];
    matches3 = matches3.filter((p5) => doesMatch2(ptr, p5));
    if (matches3.length === 0) {
      res.push({ passthrough: ptr });
      return;
    }
    matches3 = matches3.sort((a2, b) => a2[1] - b[1]);
    let carry = ptr;
    matches3.forEach((p5, i3) => {
      let found = pivotBy(carry, p5);
      if (!matches3[i3 + 1]) {
        res.push(found);
      } else {
        res.push({ before: found.before, match: found.match });
        if (found.after) {
          carry = found.after;
        }
      }
    });
  });
  return res;
};
var split_default2 = splitAll;

// ../../node_modules/compromise/src/1-one/pointers/methods/getDoc.js
var max = 20;
var blindSweep = function(id, doc, n3) {
  for (let i3 = 0; i3 < max; i3 += 1) {
    if (doc[n3 - i3]) {
      let index3 = doc[n3 - i3].findIndex((term) => term.id === id);
      if (index3 !== -1) {
        return [n3 - i3, index3];
      }
    }
    if (doc[n3 + i3]) {
      let index3 = doc[n3 + i3].findIndex((term) => term.id === id);
      if (index3 !== -1) {
        return [n3 + i3, index3];
      }
    }
  }
  return null;
};
var repairEnding = function(ptr, document) {
  let [n3, start2, , , endId] = ptr;
  let terms = document[n3];
  let newEnd = terms.findIndex((t3) => t3.id === endId);
  if (newEnd === -1) {
    ptr[2] = document[n3].length;
    ptr[4] = terms.length ? terms[terms.length - 1].id : null;
  } else {
    ptr[2] = newEnd;
  }
  return document[n3].slice(start2, ptr[2] + 1);
};
var getDoc2 = function(ptrs, document) {
  let doc = [];
  ptrs.forEach((ptr, i3) => {
    if (!ptr) {
      return;
    }
    let [n3, start2, end2, id, endId] = ptr;
    let terms = document[n3] || [];
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end2 === void 0) {
      end2 = terms.length;
    }
    if (id && (!terms[start2] || terms[start2].id !== id)) {
      let wild = blindSweep(id, document, n3);
      if (wild !== null) {
        let len = end2 - start2;
        terms = document[wild[0]].slice(wild[1], wild[1] + len);
        let startId = terms[0] ? terms[0].id : null;
        ptrs[i3] = [wild[0], wild[1], wild[1] + len, startId];
      }
    } else {
      terms = terms.slice(start2, end2);
    }
    if (terms.length === 0) {
      return;
    }
    if (start2 === end2) {
      return;
    }
    if (endId && terms[terms.length - 1].id !== endId) {
      terms = repairEnding(ptr, document);
    }
    doc.push(terms);
  });
  doc = doc.filter((a2) => a2.length > 0);
  return doc;
};
var getDoc_default = getDoc2;

// ../../node_modules/compromise/src/1-one/pointers/methods/index.js
var termList = function(docs) {
  let arr = [];
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t3 = 0; t3 < docs[i3].length; t3 += 1) {
      arr.push(docs[i3][t3]);
    }
  }
  return arr;
};
var methods_default5 = {
  one: {
    termList,
    getDoc: getDoc_default,
    pointer: {
      indexN,
      splitAll: split_default2
    }
  }
};

// ../../node_modules/compromise/src/1-one/pointers/api/lib/union.js
var getUnion = function(a2, b) {
  let both = a2.concat(b);
  let byN = indexN(both);
  let res = [];
  both.forEach((ptr) => {
    let [n3] = ptr;
    if (byN[n3].length === 1) {
      res.push(ptr);
      return;
    }
    let hmm = byN[n3].filter((m3) => doesOverlap(ptr, m3));
    hmm.push(ptr);
    let range = getExtent(hmm);
    res.push(range);
  });
  res = uniquePtrs(res);
  return res;
};
var union_default = getUnion;

// ../../node_modules/compromise/src/1-one/pointers/api/lib/difference.js
var subtract = function(refs, not) {
  let res = [];
  let found = split_default2(refs, not);
  found.forEach((o2) => {
    if (o2.passthrough) {
      res.push(o2.passthrough);
    }
    if (o2.before) {
      res.push(o2.before);
    }
    if (o2.after) {
      res.push(o2.after);
    }
  });
  return res;
};
var difference_default = subtract;

// ../../node_modules/compromise/src/1-one/pointers/api/lib/intersection.js
var intersection = function(a2, b) {
  let start2 = a2[1] < b[1] ? b[1] : a2[1];
  let end2 = a2[2] > b[2] ? b[2] : a2[2];
  if (start2 < end2) {
    return [a2[0], start2, end2];
  }
  return null;
};
var getIntersection = function(a2, b) {
  let byN = indexN(b);
  let res = [];
  a2.forEach((ptr) => {
    let hmm = byN[ptr[0]] || [];
    hmm = hmm.filter((p5) => doesOverlap(ptr, p5));
    if (hmm.length === 0) {
      return;
    }
    hmm.forEach((h2) => {
      let overlap = intersection(ptr, h2);
      if (overlap) {
        res.push(overlap);
      }
    });
  });
  return res;
};
var intersection_default = getIntersection;

// ../../node_modules/compromise/src/1-one/pointers/api/index.js
var isArray7 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var getDoc3 = (m3, view) => {
  if (typeof m3 === "string" || isArray7(m3)) {
    return view.match(m3);
  }
  if (!m3) {
    return view.none();
  }
  return m3;
};
var addIds3 = function(ptrs, docs) {
  return ptrs.map((ptr) => {
    let [n3, start2] = ptr;
    if (docs[n3] && docs[n3][start2]) {
      ptr[3] = docs[n3][start2].id;
    }
    return ptr;
  });
};
var methods14 = {};
methods14.union = function(m3) {
  m3 = getDoc3(m3, this);
  let ptrs = union_default(this.fullPointer, m3.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods14.and = methods14.union;
methods14.intersection = function(m3) {
  m3 = getDoc3(m3, this);
  let ptrs = intersection_default(this.fullPointer, m3.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods14.not = function(m3) {
  m3 = getDoc3(m3, this);
  let ptrs = difference_default(this.fullPointer, m3.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods14.difference = methods14.not;
methods14.complement = function() {
  let doc = this.all();
  let ptrs = difference_default(doc.fullPointer, this.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods14.settle = function() {
  let ptrs = this.fullPointer;
  ptrs.forEach((ptr) => {
    ptrs = union_default(ptrs, [ptr]);
  });
  ptrs = addIds3(ptrs, this.document);
  return this.update(ptrs);
};
var addAPI4 = function(View2) {
  Object.assign(View2.prototype, methods14);
};
var api_default6 = addAPI4;

// ../../node_modules/compromise/src/1-one/pointers/plugin.js
var plugin_default8 = {
  methods: methods_default5,
  api: api_default6
};

// ../../node_modules/compromise/src/1-one/sweep/lib.js
var lib_default3 = {
  // compile a list of matches into a match-net
  buildNet: function(matches3) {
    const methods18 = this.methods();
    let net3 = methods18.one.buildNet(matches3, this.world());
    net3.isNet = true;
    return net3;
  }
};

// ../../node_modules/compromise/src/1-one/sweep/api.js
var api = function(View2) {
  View2.prototype.sweep = function(net3, opts2 = {}) {
    const { world: world2, docs } = this;
    const { methods: methods18 } = world2;
    let found = methods18.one.bulkMatch(docs, net3, this.methods, opts2);
    if (opts2.tagger !== false) {
      methods18.one.bulkTagger(found, docs, this.world);
    }
    found = found.map((o2) => {
      let ptr = o2.pointer;
      let term = docs[ptr[0]][ptr[1]];
      let len = ptr[2] - ptr[1];
      if (term.index) {
        o2.pointer = [
          term.index[0],
          term.index[1],
          ptr[1] + len
        ];
      }
      return o2;
    });
    let ptrs = found.map((o2) => o2.pointer);
    found = found.map((obj) => {
      obj.view = this.update([obj.pointer]);
      delete obj.regs;
      delete obj.needs;
      delete obj.pointer;
      delete obj._expanded;
      return obj;
    });
    return {
      view: this.update(ptrs),
      found
    };
  };
};
var api_default7 = api;

// ../../node_modules/compromise/src/1-one/sweep/methods/buildNet/01-parse.js
var getTokenNeeds = function(reg) {
  if (reg.optional === true || reg.negative === true) {
    return null;
  }
  if (reg.tag) {
    return "#" + reg.tag;
  }
  if (reg.word) {
    return reg.word;
  }
  if (reg.switch) {
    return `%${reg.switch}%`;
  }
  return null;
};
var getNeeds = function(regs) {
  let needs = [];
  regs.forEach((reg) => {
    needs.push(getTokenNeeds(reg));
    if (reg.operator === "and" && reg.choices) {
      reg.choices.forEach((oneSide) => {
        oneSide.forEach((r2) => {
          needs.push(getTokenNeeds(r2));
        });
      });
    }
  });
  return needs.filter((str) => str);
};
var getWants = function(regs) {
  let wants = [];
  let count = 0;
  regs.forEach((reg) => {
    if (reg.operator === "or" && !reg.optional && !reg.negative) {
      if (reg.fastOr) {
        Array.from(reg.fastOr).forEach((w) => {
          wants.push(w);
        });
      }
      if (reg.choices) {
        reg.choices.forEach((rs) => {
          rs.forEach((r2) => {
            let n3 = getTokenNeeds(r2);
            if (n3) {
              wants.push(n3);
            }
          });
        });
      }
      count += 1;
    }
  });
  return { wants, count };
};
var parse = function(matches3, world2) {
  const parseMatch = world2.methods.one.parseMatch;
  matches3.forEach((obj) => {
    obj.regs = parseMatch(obj.match, {}, world2);
    if (typeof obj.ifNo === "string") {
      obj.ifNo = [obj.ifNo];
    }
    if (obj.notIf) {
      obj.notIf = parseMatch(obj.notIf, {}, world2);
    }
    obj.needs = getNeeds(obj.regs);
    let { wants, count } = getWants(obj.regs);
    obj.wants = wants;
    obj.minWant = count;
    obj.minWords = obj.regs.filter((o2) => !o2.optional).length;
  });
  return matches3;
};
var parse_default = parse;

// ../../node_modules/compromise/src/1-one/sweep/methods/buildNet/index.js
var buildNet = function(matches3, world2) {
  matches3 = parse_default(matches3, world2);
  let hooks2 = {};
  matches3.forEach((obj) => {
    obj.needs.forEach((str) => {
      hooks2[str] = hooks2[str] || [];
      hooks2[str].push(obj);
    });
    obj.wants.forEach((str) => {
      hooks2[str] = hooks2[str] || [];
      hooks2[str].push(obj);
    });
  });
  Object.keys(hooks2).forEach((k2) => {
    let already = {};
    hooks2[k2] = hooks2[k2].filter((obj) => {
      if (already[obj.match]) {
        return false;
      }
      already[obj.match] = true;
      return true;
    });
  });
  let always = matches3.filter((o2) => o2.needs.length === 0 && o2.wants.length === 0);
  return {
    hooks: hooks2,
    always
  };
};
var buildNet_default = buildNet;

// ../../node_modules/compromise/src/1-one/sweep/methods/sweep/01-getHooks.js
var getHooks = function(docCaches, hooks2) {
  return docCaches.map((set, i3) => {
    let maybe = [];
    Object.keys(hooks2).forEach((k2) => {
      if (docCaches[i3].has(k2)) {
        maybe = maybe.concat(hooks2[k2]);
      }
    });
    let already = {};
    maybe = maybe.filter((m3) => {
      if (already[m3.match]) {
        return false;
      }
      already[m3.match] = true;
      return true;
    });
    return maybe;
  });
};
var getHooks_default = getHooks;

// ../../node_modules/compromise/src/1-one/sweep/methods/sweep/02-trim-down.js
var localTrim = function(maybeList, docCache) {
  return maybeList.map((list4, n3) => {
    let haves = docCache[n3];
    list4 = list4.filter((obj) => {
      return obj.needs.every((need) => haves.has(need));
    });
    list4 = list4.filter((obj) => {
      if (obj.ifNo !== void 0 && obj.ifNo.some((no) => haves.has(no)) === true) {
        return false;
      }
      return true;
    });
    list4 = list4.filter((obj) => {
      if (obj.wants.length === 0) {
        return true;
      }
      let found = obj.wants.filter((str) => haves.has(str)).length;
      return found >= obj.minWant;
    });
    return list4;
  });
};
var trim_down_default = localTrim;

// ../../node_modules/compromise/src/1-one/sweep/methods/sweep/04-runMatch.js
var runMatch2 = function(maybeList, document, docCache, methods18, opts2) {
  let results = [];
  for (let n3 = 0; n3 < maybeList.length; n3 += 1) {
    for (let i3 = 0; i3 < maybeList[n3].length; i3 += 1) {
      let m3 = maybeList[n3][i3];
      let res = methods18.one.match([document[n3]], m3);
      if (res.ptrs.length > 0) {
        res.ptrs.forEach((ptr) => {
          ptr[0] = n3;
          let todo = Object.assign({}, m3, { pointer: ptr });
          if (m3.unTag !== void 0) {
            todo.unTag = m3.unTag;
          }
          results.push(todo);
        });
        if (opts2.matchOne === true) {
          return [results[0]];
        }
      }
    }
  }
  return results;
};
var runMatch_default = runMatch2;

// ../../node_modules/compromise/src/1-one/sweep/methods/sweep/index.js
var tooSmall = function(maybeList, document) {
  return maybeList.map((arr, i3) => {
    let termCount = document[i3].length;
    arr = arr.filter((o2) => {
      return termCount >= o2.minWords;
    });
    return arr;
  });
};
var sweep = function(document, net3, methods18, opts2 = {}) {
  let docCache = methods18.one.cacheDoc(document);
  let maybeList = getHooks_default(docCache, net3.hooks);
  maybeList = trim_down_default(maybeList, docCache, document);
  if (net3.always.length > 0) {
    maybeList = maybeList.map((arr) => arr.concat(net3.always));
  }
  maybeList = tooSmall(maybeList, document);
  let results = runMatch_default(maybeList, document, docCache, methods18, opts2);
  return results;
};
var sweep_default = sweep;

// ../../node_modules/compromise/src/1-one/sweep/methods/tagger/canBe.js
var canBe = function(terms, tag, model5) {
  let tagSet = model5.one.tagSet;
  if (!tagSet.hasOwnProperty(tag)) {
    return true;
  }
  let not = tagSet[tag].not || [];
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    let term = terms[i3];
    for (let k2 = 0; k2 < not.length; k2 += 1) {
      if (term.tags.has(not[k2]) === true) {
        return false;
      }
    }
  }
  return true;
};
var canBe_default = canBe;

// ../../node_modules/compromise/src/1-one/sweep/methods/tagger/index.js
var tagger = function(list4, document, world2) {
  const { model: model5, methods: methods18 } = world2;
  const { getDoc: getDoc4, setTag: setTag3, unTag: unTag2 } = methods18.one;
  const looksPlural2 = methods18.two.looksPlural;
  if (list4.length === 0) {
    return list4;
  }
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2.DEBUG_TAGS) {
    console.log(`

  \x1B[32m→ ${list4.length} post-tagger:\x1B[0m`);
  }
  return list4.map((todo) => {
    if (!todo.tag && !todo.chunk && !todo.unTag) {
      return;
    }
    let reason = todo.reason || todo.match;
    let terms = getDoc4([todo.pointer], document)[0];
    if (todo.safe === true) {
      if (canBe_default(terms, todo.tag, model5) === false) {
        return;
      }
      if (terms[terms.length - 1].post === "-") {
        return;
      }
    }
    if (todo.tag !== void 0) {
      setTag3(terms, todo.tag, world2, todo.safe, `[post] '${reason}'`);
      if (todo.tag === "Noun" && looksPlural2) {
        let term = terms[terms.length - 1];
        if (looksPlural2(term.text)) {
          setTag3([term], "Plural", world2, todo.safe, "quick-plural");
        } else {
          setTag3([term], "Singular", world2, todo.safe, "quick-singular");
        }
      }
    }
    if (todo.unTag !== void 0) {
      unTag2(terms, todo.unTag, world2, todo.safe, reason);
    }
    if (todo.chunk) {
      terms.forEach((t3) => t3.chunk = todo.chunk);
    }
  });
};
var tagger_default = tagger;

// ../../node_modules/compromise/src/1-one/sweep/methods/index.js
var methods_default6 = {
  buildNet: buildNet_default,
  bulkMatch: sweep_default,
  bulkTagger: tagger_default
};

// ../../node_modules/compromise/src/1-one/sweep/plugin.js
var plugin_default9 = {
  lib: lib_default3,
  api: api_default7,
  methods: {
    one: methods_default6
  }
};

// ../../node_modules/compromise/src/1-one/tag/methods/setTag.js
var isMulti = / /;
var addChunk = function(term, tag) {
  if (tag === "Noun") {
    term.chunk = tag;
  }
  if (tag === "Verb") {
    term.chunk = tag;
  }
};
var tagTerm = function(term, tag, tagSet, isSafe) {
  if (term.tags.has(tag) === true) {
    return null;
  }
  if (tag === ".") {
    return null;
  }
  let known = tagSet[tag];
  if (known) {
    if (known.not && known.not.length > 0) {
      for (let o2 = 0; o2 < known.not.length; o2 += 1) {
        if (isSafe === true && term.tags.has(known.not[o2])) {
          return null;
        }
        term.tags.delete(known.not[o2]);
      }
    }
    if (known.parents && known.parents.length > 0) {
      for (let o2 = 0; o2 < known.parents.length; o2 += 1) {
        term.tags.add(known.parents[o2]);
        addChunk(term, known.parents[o2]);
      }
    }
  }
  term.tags.add(tag);
  term.dirty = true;
  addChunk(term, tag);
  return true;
};
var multiTag = function(terms, tagString2, tagSet, isSafe) {
  let tags = tagString2.split(isMulti);
  terms.forEach((term, i3) => {
    let tag = tags[i3];
    if (tag) {
      tag = tag.replace(/^#/, "");
      tagTerm(term, tag, tagSet, isSafe);
    }
  });
};
var isArray8 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var log = (terms, tag, reason = "") => {
  const yellow = (str) => "\x1B[33m\x1B[3m" + str + "\x1B[0m";
  const i3 = (str) => "\x1B[3m" + str + "\x1B[0m";
  let word = terms.map((t3) => {
    return t3.text || "[" + t3.implicit + "]";
  }).join(" ");
  if (typeof tag !== "string" && tag.length > 2) {
    tag = tag.slice(0, 2).join(", #") + " +";
  }
  tag = typeof tag !== "string" ? tag.join(", #") : tag;
  console.log(` ${yellow(word).padEnd(24)} \x1B[32m→\x1B[0m #${tag.padEnd(22)}  ${i3(reason)}`);
};
var setTag = function(terms, tag, world2 = {}, isSafe, reason) {
  const tagSet = world2.model.one.tagSet || {};
  if (!tag) {
    return;
  }
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2 && env2.DEBUG_TAGS) {
    log(terms, tag, reason);
  }
  if (isArray8(tag) === true) {
    tag.forEach((tg) => setTag(terms, tg, world2, isSafe));
    return;
  }
  if (typeof tag !== "string") {
    console.warn(`compromise: Invalid tag '${tag}'`);
    return;
  }
  tag = tag.trim();
  if (isMulti.test(tag)) {
    multiTag(terms, tag, tagSet, isSafe);
    return;
  }
  tag = tag.replace(/^#/, "");
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    tagTerm(terms[i3], tag, tagSet, isSafe);
  }
};
var setTag_default = setTag;

// ../../node_modules/compromise/src/1-one/tag/methods/unTag.js
var unTag = function(terms, tag, tagSet) {
  tag = tag.trim().replace(/^#/, "");
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    let term = terms[i3];
    if (tag === "*") {
      term.tags.clear();
      continue;
    }
    let known = tagSet[tag];
    if (known && known.children.length > 0) {
      for (let o2 = 0; o2 < known.children.length; o2 += 1) {
        term.tags.delete(known.children[o2]);
      }
    }
    term.tags.delete(tag);
  }
};
var unTag_default = unTag;

// ../../node_modules/grad-school/builds/grad-school.mjs
var e = function(e2) {
  return e2.children = e2.children || [], e2._cache = e2._cache || {}, e2.props = e2.props || {}, e2._cache.parents = e2._cache.parents || [], e2._cache.children = e2._cache.children || [], e2;
};
var t2 = /^ *(#|\/\/)/;
var n = function(t3) {
  let n3 = t3.trim().split(/->/), r2 = [];
  n3.forEach((t4) => {
    r2 = r2.concat(function(t5) {
      if (!(t5 = t5.trim()))
        return null;
      if (/^\[/.test(t5) && /\]$/.test(t5)) {
        let n4 = (t5 = (t5 = t5.replace(/^\[/, "")).replace(/\]$/, "")).split(/,/);
        return n4 = n4.map((e2) => e2.trim()).filter((e2) => e2), n4 = n4.map((t6) => e({ id: t6 })), n4;
      }
      return [e({ id: t5 })];
    }(t4));
  }), r2 = r2.filter((e2) => e2);
  let i3 = r2[0];
  for (let e2 = 1; e2 < r2.length; e2 += 1)
    i3.children.push(r2[e2]), i3 = r2[e2];
  return r2[0];
};
var r = (e2, t3) => {
  let n3 = [], r2 = [e2];
  for (; r2.length > 0; ) {
    let e3 = r2.pop();
    n3.push(e3), e3.children && e3.children.forEach((n4) => {
      t3 && t3(e3, n4), r2.push(n4);
    });
  }
  return n3;
};
var i2 = (e2) => "[object Array]" === Object.prototype.toString.call(e2);
var c = (e2) => (e2 = e2 || "").trim();
var s = function(c2 = []) {
  return "string" == typeof c2 ? function(r2) {
    let i3 = r2.split(/\r?\n/), c3 = [];
    i3.forEach((e2) => {
      if (!e2.trim() || t2.test(e2))
        return;
      let r3 = ((e3) => {
        const t3 = /^( {2}|\t)/;
        let n3 = 0;
        for (; t3.test(e3); )
          e3 = e3.replace(t3, ""), n3 += 1;
        return n3;
      })(e2);
      c3.push({ indent: r3, node: n(e2) });
    });
    let s4 = function(e2) {
      let t3 = { children: [] };
      return e2.forEach((n3, r3) => {
        0 === n3.indent ? t3.children = t3.children.concat(n3.node) : e2[r3 - 1] && function(e3, t4) {
          let n4 = e3[t4].indent;
          for (; t4 >= 0; t4 -= 1)
            if (e3[t4].indent < n4)
              return e3[t4];
          return e3[0];
        }(e2, r3).node.children.push(n3.node);
      }), t3;
    }(c3);
    return s4 = e(s4), s4;
  }(c2) : i2(c2) ? function(t3) {
    let n3 = {};
    t3.forEach((e2) => {
      n3[e2.id] = e2;
    });
    let r2 = e({});
    return t3.forEach((t4) => {
      if ((t4 = e(t4)).parent)
        if (n3.hasOwnProperty(t4.parent)) {
          let e2 = n3[t4.parent];
          delete t4.parent, e2.children.push(t4);
        } else
          console.warn(`[Grad] - missing node '${t4.parent}'`);
      else
        r2.children.push(t4);
    }), r2;
  }(c2) : (r(s3 = c2).forEach(e), s3);
  var s3;
};
var h = (e2) => "\x1B[31m" + e2 + "\x1B[0m";
var o = (e2) => "\x1B[2m" + e2 + "\x1B[0m";
var l = function(e2, t3) {
  let n3 = "-> ";
  t3 && (n3 = o("→ "));
  let i3 = "";
  return r(e2).forEach((e3, r2) => {
    let c2 = e3.id || "";
    if (t3 && (c2 = h(c2)), 0 === r2 && !e3.id)
      return;
    let s3 = e3._cache.parents.length;
    i3 += "    ".repeat(s3) + n3 + c2 + "\n";
  }), i3;
};
var a = function(e2) {
  let t3 = r(e2);
  t3.forEach((e3) => {
    delete (e3 = Object.assign({}, e3)).children;
  });
  let n3 = t3[0];
  return n3 && !n3.id && 0 === Object.keys(n3.props).length && t3.shift(), t3;
};
var p = { text: l, txt: l, array: a, flat: a };
var d = function(e2, t3) {
  return "nested" === t3 || "json" === t3 ? e2 : "debug" === t3 ? (console.log(l(e2, true)), null) : p.hasOwnProperty(t3) ? p[t3](e2) : e2;
};
var u = (e2) => {
  r(e2, (e3, t3) => {
    e3.id && (e3._cache.parents = e3._cache.parents || [], t3._cache.parents = e3._cache.parents.concat([e3.id]));
  });
};
var f = (e2, t3) => (Object.keys(t3).forEach((n3) => {
  if (t3[n3] instanceof Set) {
    let r2 = e2[n3] || /* @__PURE__ */ new Set();
    e2[n3] = /* @__PURE__ */ new Set([...r2, ...t3[n3]]);
  } else {
    if (((e3) => e3 && "object" == typeof e3 && !Array.isArray(e3))(t3[n3])) {
      let r2 = e2[n3] || {};
      e2[n3] = Object.assign({}, t3[n3], r2);
    } else
      i2(t3[n3]) ? e2[n3] = t3[n3].concat(e2[n3] || []) : void 0 === e2[n3] && (e2[n3] = t3[n3]);
  }
}), e2);
var j = /\//;
var g = class _g {
  constructor(e2 = {}) {
    Object.defineProperty(this, "json", { enumerable: false, value: e2, writable: true });
  }
  get children() {
    return this.json.children;
  }
  get id() {
    return this.json.id;
  }
  get found() {
    return this.json.id || this.json.children.length > 0;
  }
  props(e2 = {}) {
    let t3 = this.json.props || {};
    return "string" == typeof e2 && (t3[e2] = true), this.json.props = Object.assign(t3, e2), this;
  }
  get(t3) {
    if (t3 = c(t3), !j.test(t3)) {
      let e2 = this.json.children.find((e3) => e3.id === t3);
      return new _g(e2);
    }
    let n3 = ((e2, t4) => {
      let n4 = ((e3) => "string" != typeof e3 ? e3 : (e3 = e3.replace(/^\//, "")).split(/\//))(t4 = t4 || "");
      for (let t5 = 0; t5 < n4.length; t5 += 1) {
        let r2 = e2.children.find((e3) => e3.id === n4[t5]);
        if (!r2)
          return null;
        e2 = r2;
      }
      return e2;
    })(this.json, t3) || e({});
    return new _g(n3);
  }
  add(t3, n3 = {}) {
    if (i2(t3))
      return t3.forEach((e2) => this.add(c(e2), n3)), this;
    t3 = c(t3);
    let r2 = e({ id: t3, props: n3 });
    return this.json.children.push(r2), new _g(r2);
  }
  remove(e2) {
    return e2 = c(e2), this.json.children = this.json.children.filter((t3) => t3.id !== e2), this;
  }
  nodes() {
    return r(this.json).map((e2) => (delete (e2 = Object.assign({}, e2)).children, e2));
  }
  cache() {
    return ((e2) => {
      let t3 = r(e2, (e3, t4) => {
        e3.id && (e3._cache.parents = e3._cache.parents || [], e3._cache.children = e3._cache.children || [], t4._cache.parents = e3._cache.parents.concat([e3.id]));
      }), n3 = {};
      t3.forEach((e3) => {
        e3.id && (n3[e3.id] = e3);
      }), t3.forEach((e3) => {
        e3._cache.parents.forEach((t4) => {
          n3.hasOwnProperty(t4) && n3[t4]._cache.children.push(e3.id);
        });
      }), e2._cache.children = Object.keys(n3);
    })(this.json), this;
  }
  list() {
    return r(this.json);
  }
  fillDown() {
    var e2;
    return e2 = this.json, r(e2, (e3, t3) => {
      t3.props = f(t3.props, e3.props);
    }), this;
  }
  depth() {
    u(this.json);
    let e2 = r(this.json), t3 = e2.length > 1 ? 1 : 0;
    return e2.forEach((e3) => {
      if (0 === e3._cache.parents.length)
        return;
      let n3 = e3._cache.parents.length + 1;
      n3 > t3 && (t3 = n3);
    }), t3;
  }
  out(e2) {
    return u(this.json), d(this.json, e2);
  }
  debug() {
    return u(this.json), d(this.json, "debug"), this;
  }
};
var _ = function(e2) {
  let t3 = s(e2);
  return new g(t3);
};
_.prototype.plugin = function(e2) {
  e2(this);
};

// ../../node_modules/compromise/src/1-one/tag/methods/addTags/_colors.js
var colors = {
  Noun: "blue",
  Verb: "green",
  Negative: "green",
  Date: "red",
  Value: "red",
  Adjective: "magenta",
  Preposition: "cyan",
  Conjunction: "cyan",
  Determiner: "cyan",
  Hyphenated: "cyan",
  Adverb: "cyan"
};
var colors_default = colors;

// ../../node_modules/compromise/src/1-one/tag/methods/addTags/02-fmt.js
var getColor = function(node) {
  if (colors_default.hasOwnProperty(node.id)) {
    return colors_default[node.id];
  }
  if (colors_default.hasOwnProperty(node.is)) {
    return colors_default[node.is];
  }
  let found = node._cache.parents.find((c2) => colors_default[c2]);
  return colors_default[found];
};
var fmt = function(nodes) {
  const res = {};
  nodes.forEach((node) => {
    let { not, also, is, novel } = node.props;
    let parents = node._cache.parents;
    if (also) {
      parents = parents.concat(also);
    }
    res[node.id] = {
      is,
      not,
      novel,
      also,
      parents,
      children: node._cache.children,
      color: getColor(node)
    };
  });
  Object.keys(res).forEach((k2) => {
    let nots = new Set(res[k2].not);
    res[k2].not.forEach((not) => {
      if (res[not]) {
        res[not].children.forEach((tag) => nots.add(tag));
      }
    });
    res[k2].not = Array.from(nots);
  });
  return res;
};
var fmt_default = fmt;

// ../../node_modules/compromise/src/1-one/tag/methods/addTags/01-validate.js
var toArr = function(input) {
  if (!input) {
    return [];
  }
  if (typeof input === "string") {
    return [input];
  }
  return input;
};
var addImplied = function(tags, already) {
  Object.keys(tags).forEach((k2) => {
    if (tags[k2].isA) {
      tags[k2].is = tags[k2].isA;
    }
    if (tags[k2].notA) {
      tags[k2].not = tags[k2].notA;
    }
    if (tags[k2].is && typeof tags[k2].is === "string") {
      if (!already.hasOwnProperty(tags[k2].is) && !tags.hasOwnProperty(tags[k2].is)) {
        tags[tags[k2].is] = {};
      }
    }
    if (tags[k2].not && typeof tags[k2].not === "string" && !tags.hasOwnProperty(tags[k2].not)) {
      if (!already.hasOwnProperty(tags[k2].not) && !tags.hasOwnProperty(tags[k2].not)) {
        tags[tags[k2].not] = {};
      }
    }
  });
  return tags;
};
var validate = function(tags, already) {
  tags = addImplied(tags, already);
  Object.keys(tags).forEach((k2) => {
    tags[k2].children = toArr(tags[k2].children);
    tags[k2].not = toArr(tags[k2].not);
  });
  Object.keys(tags).forEach((k2) => {
    let nots = tags[k2].not || [];
    nots.forEach((no) => {
      if (tags[no] && tags[no].not) {
        tags[no].not.push(k2);
      }
    });
  });
  return tags;
};
var validate_default = validate;

// ../../node_modules/compromise/src/1-one/tag/methods/addTags/index.js
var compute3 = function(allTags2) {
  const flatList = Object.keys(allTags2).map((k2) => {
    let o2 = allTags2[k2];
    const props = { not: new Set(o2.not), also: o2.also, is: o2.is, novel: o2.novel };
    return { id: k2, parent: o2.is, props, children: [] };
  });
  const graph = _(flatList).cache().fillDown();
  return graph.out("array");
};
var fromUser = function(tags) {
  Object.keys(tags).forEach((k2) => {
    tags[k2] = Object.assign({}, tags[k2]);
    tags[k2].novel = true;
  });
  return tags;
};
var addTags = function(tags, already) {
  if (Object.keys(already).length > 0) {
    tags = fromUser(tags);
  }
  tags = validate_default(tags, already);
  let allTags2 = Object.assign({}, already, tags);
  const nodes = compute3(allTags2);
  const res = fmt_default(nodes);
  return res;
};
var addTags_default = addTags;

// ../../node_modules/compromise/src/1-one/tag/methods/index.js
var methods_default7 = {
  one: {
    setTag: setTag_default,
    unTag: unTag_default,
    addTags: addTags_default
  }
};

// ../../node_modules/compromise/src/1-one/tag/api/tag.js
var isArray9 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var fns5 = {
  /** add a given tag, to all these terms */
  tag: function(input, reason = "", isSafe) {
    if (!this.found || !input) {
      return this;
    }
    let terms = this.termList();
    if (terms.length === 0) {
      return this;
    }
    const { methods: methods18, verbose: verbose2, world: world2 } = this;
    if (verbose2 === true) {
      console.log(" +  ", input, reason || "");
    }
    if (isArray9(input)) {
      input.forEach((tag) => methods18.one.setTag(terms, tag, world2, isSafe, reason));
    } else {
      methods18.one.setTag(terms, input, world2, isSafe, reason);
    }
    this.uncache();
    return this;
  },
  /** add a given tag, only if it is consistent */
  tagSafe: function(input, reason = "") {
    return this.tag(input, reason, true);
  },
  /** remove a given tag from all these terms */
  unTag: function(input, reason) {
    if (!this.found || !input) {
      return this;
    }
    let terms = this.termList();
    if (terms.length === 0) {
      return this;
    }
    const { methods: methods18, verbose: verbose2, model: model5 } = this;
    if (verbose2 === true) {
      console.log(" -  ", input, reason || "");
    }
    let tagSet = model5.one.tagSet;
    if (isArray9(input)) {
      input.forEach((tag) => methods18.one.unTag(terms, tag, tagSet));
    } else {
      methods18.one.unTag(terms, input, tagSet);
    }
    this.uncache();
    return this;
  },
  /** return only the terms that can be this tag  */
  canBe: function(tag) {
    tag = tag.replace(/^#/, "");
    let tagSet = this.model.one.tagSet;
    if (!tagSet.hasOwnProperty(tag)) {
      return this;
    }
    let not = tagSet[tag].not || [];
    let nope2 = [];
    this.document.forEach((terms, n3) => {
      terms.forEach((term, i3) => {
        let found = not.find((no) => term.tags.has(no));
        if (found) {
          nope2.push([n3, i3, i3 + 1]);
        }
      });
    });
    let noDoc = this.update(nope2);
    return this.difference(noDoc);
  }
};
var tag_default = fns5;

// ../../node_modules/compromise/src/1-one/tag/api/index.js
var tagAPI = function(View2) {
  Object.assign(View2.prototype, tag_default);
};
var api_default8 = tagAPI;

// ../../node_modules/compromise/src/1-one/tag/lib.js
var addTags2 = function(tags) {
  const { model: model5, methods: methods18 } = this.world();
  const tagSet = model5.one.tagSet;
  const fn = methods18.one.addTags;
  let res = fn(tags, tagSet);
  model5.one.tagSet = res;
  return this;
};
var lib_default4 = { addTags: addTags2 };

// ../../node_modules/compromise/src/1-one/tag/compute/tagRank.js
var boringTags = /* @__PURE__ */ new Set(["Auxiliary", "Possessive"]);
var sortByKids = function(tags, tagSet) {
  tags = tags.sort((a2, b) => {
    if (boringTags.has(a2) || !tagSet.hasOwnProperty(b)) {
      return 1;
    }
    if (boringTags.has(b) || !tagSet.hasOwnProperty(a2)) {
      return -1;
    }
    let kids = tagSet[a2].children || [];
    let aKids = kids.length;
    kids = tagSet[b].children || [];
    let bKids = kids.length;
    return aKids - bKids;
  });
  return tags;
};
var tagRank = function(view) {
  const { document, world: world2 } = view;
  const tagSet = world2.model.one.tagSet;
  document.forEach((terms) => {
    terms.forEach((term) => {
      let tags = Array.from(term.tags);
      term.tagRank = sortByKids(tags, tagSet);
    });
  });
};
var tagRank_default = tagRank;

// ../../node_modules/compromise/src/1-one/tag/plugin.js
var plugin_default10 = {
  model: {
    one: { tagSet: {} }
  },
  compute: {
    tagRank: tagRank_default
  },
  methods: methods_default7,
  api: api_default8,
  lib: lib_default4
};

// ../../node_modules/compromise/src/1-one/tokenize/methods/01-sentences/01-simple-split.js
var initSplit = /([.!?\u203D\u2E18\u203C\u2047-\u2049\u3002]+\s)/g;
var splitsOnly = /^[.!?\u203D\u2E18\u203C\u2047-\u2049\u3002]+\s$/;
var newLine = /((?:\r?\n|\r)+)/;
var basicSplit = function(text) {
  let all4 = [];
  let lines = text.split(newLine);
  for (let i3 = 0; i3 < lines.length; i3++) {
    let arr = lines[i3].split(initSplit);
    for (let o2 = 0; o2 < arr.length; o2++) {
      if (arr[o2 + 1] && splitsOnly.test(arr[o2 + 1]) === true) {
        arr[o2] += arr[o2 + 1];
        arr[o2 + 1] = "";
      }
      if (arr[o2] !== "") {
        all4.push(arr[o2]);
      }
    }
  }
  return all4;
};
var simple_split_default = basicSplit;

// ../../node_modules/compromise/src/1-one/tokenize/methods/01-sentences/02-simple-merge.js
var hasLetter = /[a-z0-9\u00C0-\u00FF\u00a9\u00ae\u2000-\u3300\ud000-\udfff]/i;
var hasSomething = /\S/;
var notEmpty = function(splits) {
  let chunks2 = [];
  for (let i3 = 0; i3 < splits.length; i3++) {
    let s3 = splits[i3];
    if (s3 === void 0 || s3 === "") {
      continue;
    }
    if (hasSomething.test(s3) === false || hasLetter.test(s3) === false) {
      if (chunks2[chunks2.length - 1]) {
        chunks2[chunks2.length - 1] += s3;
        continue;
      } else if (splits[i3 + 1]) {
        splits[i3 + 1] = s3 + splits[i3 + 1];
        continue;
      }
    }
    chunks2.push(s3);
  }
  return chunks2;
};
var simple_merge_default = notEmpty;

// ../../node_modules/compromise/src/1-one/tokenize/methods/01-sentences/03-smart-merge.js
var smartMerge = function(chunks2, world2) {
  const isSentence2 = world2.methods.one.tokenize.isSentence;
  const abbrevs = world2.model.one.abbreviations || /* @__PURE__ */ new Set();
  let sentences = [];
  for (let i3 = 0; i3 < chunks2.length; i3++) {
    let c2 = chunks2[i3];
    if (chunks2[i3 + 1] && isSentence2(c2, abbrevs) === false) {
      chunks2[i3 + 1] = c2 + (chunks2[i3 + 1] || "");
    } else if (c2 && c2.length > 0) {
      sentences.push(c2);
      chunks2[i3] = "";
    }
  }
  return sentences;
};
var smart_merge_default = smartMerge;

// ../../node_modules/compromise/src/1-one/tokenize/methods/01-sentences/04-quote-merge.js
var MAX_QUOTE = 280;
var pairs = {
  '"': '"',
  // 'StraightDoubleQuotes'
  "＂": "＂",
  // 'StraightDoubleQuotesWide'
  // '\u0027': '\u0027', // 'StraightSingleQuotes'
  "“": "”",
  // 'CommaDoubleQuotes'
  // '\u2018': '\u2019', // 'CommaSingleQuotes'
  "‟": "”",
  // 'CurlyDoubleQuotesReversed'
  // '\u201B': '\u2019', // 'CurlySingleQuotesReversed'
  "„": "”",
  // 'LowCurlyDoubleQuotes'
  "⹂": "”",
  // 'LowCurlyDoubleQuotesReversed'
  "‚": "’",
  // 'LowCurlySingleQuotes'
  "«": "»",
  // 'AngleDoubleQuotes'
  "‹": "›",
  // 'AngleSingleQuotes'
  "‵": "′",
  // 'PrimeSingleQuotes'
  "‶": "″",
  // 'PrimeDoubleQuotes'
  "‷": "‴",
  // 'PrimeTripleQuotes'
  "〝": "〞",
  // 'PrimeDoubleQuotes'
  // '\u0060': '\u00B4', // 'PrimeSingleQuotes'
  "〟": "〞"
  // 'LowPrimeDoubleQuotesReversed'
};
var openQuote = RegExp("[" + Object.keys(pairs).join("") + "]", "g");
var closeQuote = RegExp("[" + Object.values(pairs).join("") + "]", "g");
var closesQuote = function(str) {
  if (!str) {
    return false;
  }
  let m3 = str.match(closeQuote);
  if (m3 !== null && m3.length === 1) {
    return true;
  }
  return false;
};
var quoteMerge = function(splits) {
  let arr = [];
  for (let i3 = 0; i3 < splits.length; i3 += 1) {
    let split3 = splits[i3];
    let m3 = split3.match(openQuote);
    if (m3 !== null && m3.length === 1) {
      if (closesQuote(splits[i3 + 1]) && splits[i3 + 1].length < MAX_QUOTE) {
        splits[i3] += splits[i3 + 1];
        arr.push(splits[i3]);
        splits[i3 + 1] = "";
        i3 += 1;
        continue;
      }
      if (closesQuote(splits[i3 + 2])) {
        let toAdd = splits[i3 + 1] + splits[i3 + 2];
        if (toAdd.length < MAX_QUOTE) {
          splits[i3] += toAdd;
          arr.push(splits[i3]);
          splits[i3 + 1] = "";
          splits[i3 + 2] = "";
          i3 += 2;
          continue;
        }
      }
    }
    arr.push(splits[i3]);
  }
  return arr;
};
var quote_merge_default = quoteMerge;

// ../../node_modules/compromise/src/1-one/tokenize/methods/01-sentences/05-parens-merge.js
var MAX_LEN = 250;
var hasOpen = /\(/g;
var hasClosed = /\)/g;
var mergeParens = function(splits) {
  let arr = [];
  for (let i3 = 0; i3 < splits.length; i3 += 1) {
    let split3 = splits[i3];
    let m3 = split3.match(hasOpen);
    if (m3 !== null && m3.length === 1) {
      if (splits[i3 + 1] && splits[i3 + 1].length < MAX_LEN) {
        let m22 = splits[i3 + 1].match(hasClosed);
        if (m22 !== null && m3.length === 1 && !hasOpen.test(splits[i3 + 1])) {
          splits[i3] += splits[i3 + 1];
          arr.push(splits[i3]);
          splits[i3 + 1] = "";
          i3 += 1;
          continue;
        }
      }
    }
    arr.push(splits[i3]);
  }
  return arr;
};
var parens_merge_default = mergeParens;

// ../../node_modules/compromise/src/1-one/tokenize/methods/01-sentences/index.js
var hasSomething2 = /\S/;
var startWhitespace = /^\s+/;
var splitSentences = function(text, world2) {
  text = text || "";
  text = String(text);
  if (!text || typeof text !== "string" || hasSomething2.test(text) === false) {
    return [];
  }
  text = text.replace(" ", " ");
  let splits = simple_split_default(text);
  let sentences = simple_merge_default(splits);
  sentences = smart_merge_default(sentences, world2);
  sentences = quote_merge_default(sentences);
  sentences = parens_merge_default(sentences);
  if (sentences.length === 0) {
    return [text];
  }
  for (let i3 = 1; i3 < sentences.length; i3 += 1) {
    let ws = sentences[i3].match(startWhitespace);
    if (ws !== null) {
      sentences[i3 - 1] += ws[0];
      sentences[i3] = sentences[i3].replace(startWhitespace, "");
    }
  }
  return sentences;
};
var sentences_default = splitSentences;

// ../../node_modules/compromise/src/1-one/tokenize/methods/02-terms/01-hyphens.js
var hasHyphen2 = function(str, model5) {
  let parts = str.split(/[-–—]/);
  if (parts.length <= 1) {
    return false;
  }
  const { prefixes: prefixes2, suffixes: suffixes5 } = model5.one;
  if (parts[0].length === 1 && /[a-z]/i.test(parts[0])) {
    return false;
  }
  if (prefixes2.hasOwnProperty(parts[0])) {
    return false;
  }
  parts[1] = parts[1].trim().replace(/[.?!]$/, "");
  if (suffixes5.hasOwnProperty(parts[1])) {
    return false;
  }
  let reg = /^([a-z\u00C0-\u00FF`"'/]+)[-–—]([a-z0-9\u00C0-\u00FF].*)/i;
  if (reg.test(str) === true) {
    return true;
  }
  let reg2 = /^([0-9]{1,4})[-–—]([a-z\u00C0-\u00FF`"'/-]+$)/i;
  if (reg2.test(str) === true) {
    return true;
  }
  return false;
};
var splitHyphens2 = function(word) {
  let arr = [];
  const hyphens = word.split(/[-–—]/);
  let whichDash = "-";
  let found = word.match(/[-–—]/);
  if (found && found[0]) {
    whichDash = found;
  }
  for (let o2 = 0; o2 < hyphens.length; o2++) {
    if (o2 === hyphens.length - 1) {
      arr.push(hyphens[o2]);
    } else {
      arr.push(hyphens[o2] + whichDash);
    }
  }
  return arr;
};

// ../../node_modules/compromise/src/1-one/tokenize/methods/02-terms/03-ranges.js
var combineRanges = function(arr) {
  const startRange = /^[0-9]{1,4}(:[0-9][0-9])?([a-z]{1,2})? ?[-–—] ?$/;
  const endRange = /^[0-9]{1,4}([a-z]{1,2})? ?$/;
  for (let i3 = 0; i3 < arr.length - 1; i3 += 1) {
    if (arr[i3 + 1] && startRange.test(arr[i3]) && endRange.test(arr[i3 + 1])) {
      arr[i3] = arr[i3] + arr[i3 + 1];
      arr[i3 + 1] = null;
    }
  }
  return arr;
};
var ranges_default = combineRanges;

// ../../node_modules/compromise/src/1-one/tokenize/methods/02-terms/02-slashes.js
var isSlash = /\p{L} ?\/ ?\p{L}+$/u;
var combineSlashes = function(arr) {
  for (let i3 = 1; i3 < arr.length - 1; i3++) {
    if (isSlash.test(arr[i3])) {
      arr[i3 - 1] += arr[i3] + arr[i3 + 1];
      arr[i3] = null;
      arr[i3 + 1] = null;
    }
  }
  return arr;
};
var slashes_default = combineSlashes;

// ../../node_modules/compromise/src/1-one/tokenize/methods/02-terms/index.js
var wordlike = /\S/;
var isBoundary = /^[!?.]+$/;
var naiiveSplit = /(\S+)/;
var notWord = [
  ".",
  "?",
  "!",
  ":",
  ";",
  "-",
  "–",
  "—",
  "--",
  "...",
  "(",
  ")",
  "[",
  "]",
  '"',
  "'",
  "`",
  "«",
  "»",
  "*",
  "•"
];
notWord = notWord.reduce((h2, c2) => {
  h2[c2] = true;
  return h2;
}, {});
var isArray10 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var splitWords = function(str, model5) {
  let result = [];
  let arr = [];
  str = str || "";
  if (typeof str === "number") {
    str = String(str);
  }
  if (isArray10(str)) {
    return str;
  }
  const words = str.split(naiiveSplit);
  for (let i3 = 0; i3 < words.length; i3++) {
    if (hasHyphen2(words[i3], model5) === true) {
      arr = arr.concat(splitHyphens2(words[i3]));
      continue;
    }
    arr.push(words[i3]);
  }
  let carry = "";
  for (let i3 = 0; i3 < arr.length; i3++) {
    let word = arr[i3];
    if (wordlike.test(word) === true && notWord.hasOwnProperty(word) === false && isBoundary.test(word) === false) {
      if (result.length > 0) {
        result[result.length - 1] += carry;
        result.push(word);
      } else {
        result.push(carry + word);
      }
      carry = "";
    } else {
      carry += word;
    }
  }
  if (carry) {
    if (result.length === 0) {
      result[0] = "";
    }
    result[result.length - 1] += carry;
  }
  result = slashes_default(result);
  result = ranges_default(result);
  result = result.filter((s3) => s3);
  return result;
};
var terms_default = splitWords;

// ../../node_modules/compromise/src/1-one/tokenize/methods/03-whitespace/tokenize.js
var isLetter = /\p{Letter}/u;
var isNumber = /[\p{Number}\p{Currency_Symbol}]/u;
var hasAcronym = /^[a-z]\.([a-z]\.)+/i;
var chillin = /[sn]['’]$/;
var normalizePunctuation = function(str, model5) {
  let { prePunctuation: prePunctuation2, postPunctuation: postPunctuation2, emoticons: emoticons2 } = model5.one;
  let original = str;
  let pre = "";
  let post = "";
  let chars = Array.from(str);
  if (emoticons2.hasOwnProperty(str.trim())) {
    return { str: str.trim(), pre, post: " " };
  }
  let len = chars.length;
  for (let i3 = 0; i3 < len; i3 += 1) {
    let c2 = chars[0];
    if (prePunctuation2[c2] === true) {
      continue;
    }
    if ((c2 === "+" || c2 === "-") && isNumber.test(chars[1])) {
      break;
    }
    if (c2 === "'" && c2.length === 3 && isNumber.test(chars[1])) {
      break;
    }
    if (isLetter.test(c2) || isNumber.test(c2)) {
      break;
    }
    pre += chars.shift();
  }
  len = chars.length;
  for (let i3 = 0; i3 < len; i3 += 1) {
    let c2 = chars[chars.length - 1];
    if (postPunctuation2[c2] === true) {
      continue;
    }
    if (isLetter.test(c2) || isNumber.test(c2)) {
      break;
    }
    if (c2 === "." && hasAcronym.test(original) === true) {
      continue;
    }
    if (c2 === "'" && chillin.test(original) === true) {
      continue;
    }
    post = chars.pop() + post;
  }
  str = chars.join("");
  if (str === "") {
    original = original.replace(/ *$/, (after2) => {
      post = after2 || "";
      return "";
    });
    str = original;
    pre = "";
  }
  return { str, pre, post };
};
var tokenize_default = normalizePunctuation;

// ../../node_modules/compromise/src/1-one/tokenize/methods/03-whitespace/index.js
var parseTerm = (txt, model5) => {
  let { str, pre, post } = tokenize_default(txt, model5);
  const parsed = {
    text: str,
    pre,
    post,
    tags: /* @__PURE__ */ new Set()
  };
  return parsed;
};
var whitespace_default2 = parseTerm;

// ../../node_modules/compromise/src/1-one/tokenize/methods/unicode.js
var killUnicode = function(str, world2) {
  const unicode2 = world2.model.one.unicode || {};
  str = str || "";
  let chars = str.split("");
  chars.forEach((s3, i3) => {
    if (unicode2[s3]) {
      chars[i3] = unicode2[s3];
    }
  });
  return chars.join("");
};
var unicode_default = killUnicode;

// ../../node_modules/compromise/src/1-one/tokenize/compute/normal/01-cleanup.js
var clean = function(str) {
  str = str || "";
  str = str.toLowerCase();
  str = str.trim();
  let original = str;
  str = str.replace(/[,;.!?]+$/, "");
  str = str.replace(/\u2026/g, "...");
  str = str.replace(/\u2013/g, "-");
  if (/^[:;]/.test(str) === false) {
    str = str.replace(/\.{3,}$/g, "");
    str = str.replace(/[",.!:;?)]+$/g, "");
    str = str.replace(/^['"(]+/g, "");
  }
  str = str.replace(/[\u200B-\u200D\uFEFF]/g, "");
  str = str.trim();
  if (str === "") {
    str = original;
  }
  str = str.replace(/([0-9]),([0-9])/g, "$1$2");
  return str;
};
var cleanup_default = clean;

// ../../node_modules/compromise/src/1-one/tokenize/compute/normal/02-acronyms.js
var periodAcronym = /([A-Z]\.)+[A-Z]?,?$/;
var oneLetterAcronym = /^[A-Z]\.,?$/;
var noPeriodAcronym = /[A-Z]{2,}('s|,)?$/;
var lowerCaseAcronym = /([a-z]\.)+[a-z]\.?$/;
var isAcronym = function(str) {
  if (periodAcronym.test(str) === true) {
    return true;
  }
  if (lowerCaseAcronym.test(str) === true) {
    return true;
  }
  if (oneLetterAcronym.test(str) === true) {
    return true;
  }
  if (noPeriodAcronym.test(str) === true) {
    return true;
  }
  return false;
};
var doAcronym = function(str) {
  if (isAcronym(str)) {
    str = str.replace(/\./g, "");
  }
  return str;
};
var acronyms_default = doAcronym;

// ../../node_modules/compromise/src/1-one/tokenize/compute/normal/index.js
var normalize = function(term, world2) {
  const killUnicode2 = world2.methods.one.killUnicode;
  let str = term.text || "";
  str = cleanup_default(str);
  str = killUnicode2(str, world2);
  str = acronyms_default(str);
  term.normal = str;
};
var normal_default = normalize;

// ../../node_modules/compromise/src/1-one/tokenize/methods/parse.js
var parse2 = function(input, world2) {
  const { methods: methods18, model: model5 } = world2;
  const { splitSentences: splitSentences2, splitTerms, splitWhitespace } = methods18.one.tokenize;
  input = input || "";
  let sentences = splitSentences2(input, world2);
  input = sentences.map((txt) => {
    let terms = splitTerms(txt, model5);
    terms = terms.map((t3) => splitWhitespace(t3, model5));
    terms.forEach((t3) => {
      normal_default(t3, world2);
    });
    return terms;
  });
  return input;
};
var parse_default2 = parse2;

// ../../node_modules/compromise/src/1-one/tokenize/methods/01-sentences/is-sentence.js
var isAcronym2 = /[ .][A-Z]\.? *$/i;
var hasEllipse = /(?:\u2026|\.{2,}) *$/;
var hasLetter2 = /\p{L}/u;
var leadInit = /^[A-Z]\. $/;
var isSentence = function(str, abbrevs) {
  if (hasLetter2.test(str) === false) {
    return false;
  }
  if (isAcronym2.test(str) === true) {
    return false;
  }
  if (str.length === 3 && leadInit.test(str)) {
    return false;
  }
  if (hasEllipse.test(str) === true) {
    return false;
  }
  let txt = str.replace(/[.!?\u203D\u2E18\u203C\u2047-\u2049] *$/, "");
  let words = txt.split(" ");
  let lastWord = words[words.length - 1].toLowerCase();
  if (abbrevs.hasOwnProperty(lastWord) === true) {
    return false;
  }
  return true;
};
var is_sentence_default = isSentence;

// ../../node_modules/compromise/src/1-one/tokenize/methods/index.js
var methods_default8 = {
  one: {
    killUnicode: unicode_default,
    tokenize: {
      splitSentences: sentences_default,
      isSentence: is_sentence_default,
      splitTerms: terms_default,
      splitWhitespace: whitespace_default2,
      fromString: parse_default2
    }
  }
};

// ../../node_modules/compromise/src/1-one/tokenize/model/aliases.js
var aliases = {
  "&": "and",
  "@": "at",
  "%": "percent",
  "plz": "please",
  "bein": "being"
};
var aliases_default = aliases;

// ../../node_modules/compromise/src/1-one/tokenize/model/abbreviations/misc.js
var misc_default = [
  "approx",
  "apt",
  "bc",
  "cyn",
  "eg",
  "esp",
  "est",
  "etc",
  "ex",
  "exp",
  "prob",
  //probably
  "pron",
  // Pronunciation
  "gal",
  //gallon
  "min",
  "pseud",
  "fig",
  //figure
  "jd",
  "lat",
  //latitude
  "lng",
  //longitude
  "vol",
  //volume
  "fm",
  //not am
  "def",
  //definition
  "misc",
  "plz",
  //please
  "ea",
  //each
  "ps",
  "sec",
  //second
  "pt",
  "pref",
  //preface
  "pl",
  //plural
  "pp",
  //pages
  "qt",
  //quarter
  "fr",
  //french
  "sq",
  "nee",
  //given name at birth
  "ss",
  //ship, or sections
  "tel",
  "temp",
  "vet",
  "ver",
  //version
  "fem",
  //feminine
  "masc",
  //masculine
  "eng",
  //engineering/english
  "adj",
  //adjective
  "vb",
  //verb
  "rb",
  //adverb
  "inf",
  //infinitive
  "situ",
  // in situ
  "vivo",
  "vitro",
  "wr"
  //world record
];

// ../../node_modules/compromise/src/1-one/tokenize/model/abbreviations/honorifics.js
var honorifics_default = [
  "adj",
  "adm",
  "adv",
  "asst",
  "atty",
  "bldg",
  "brig",
  "capt",
  "cmdr",
  "comdr",
  "cpl",
  "det",
  "dr",
  "esq",
  "gen",
  "gov",
  "hon",
  "jr",
  "llb",
  "lt",
  "maj",
  "messrs",
  "mlle",
  "mme",
  "mr",
  "mrs",
  "ms",
  "mstr",
  "phd",
  "prof",
  "pvt",
  "rep",
  "reps",
  "res",
  "rev",
  "sen",
  "sens",
  "sfc",
  "sgt",
  "sir",
  "sr",
  "supt",
  "surg"
  //miss
  //misses
];

// ../../node_modules/compromise/src/1-one/tokenize/model/abbreviations/months.js
var months_default = ["jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "sept", "oct", "nov", "dec"];

// ../../node_modules/compromise/src/1-one/tokenize/model/abbreviations/nouns.js
var nouns_default = [
  "ad",
  "al",
  "arc",
  "ba",
  "bl",
  "ca",
  "cca",
  "col",
  "corp",
  "ft",
  "fy",
  "ie",
  "lit",
  "ma",
  "md",
  "pd",
  "tce"
];

// ../../node_modules/compromise/src/1-one/tokenize/model/abbreviations/organizations.js
var organizations_default = ["dept", "univ", "assn", "bros", "inc", "ltd", "co"];

// ../../node_modules/compromise/src/1-one/tokenize/model/abbreviations/places.js
var places_default = [
  "rd",
  "st",
  "dist",
  "mt",
  "ave",
  "blvd",
  "cl",
  // 'ct',
  "cres",
  "hwy",
  //states
  "ariz",
  "cal",
  "calif",
  "colo",
  "conn",
  "fla",
  "fl",
  "ga",
  "ida",
  "ia",
  "kan",
  "kans",
  "minn",
  "neb",
  "nebr",
  "okla",
  "penna",
  "penn",
  "pa",
  "dak",
  "tenn",
  "tex",
  "ut",
  "vt",
  "va",
  "wis",
  "wisc",
  "wy",
  "wyo",
  "usafa",
  "alta",
  "ont",
  "que",
  "sask"
];

// ../../node_modules/compromise/src/1-one/tokenize/model/abbreviations/units.js
var units_default = [
  "dl",
  "ml",
  "gal",
  // 'ft', //ambiguous
  "qt",
  "pt",
  "tbl",
  "tsp",
  "tbsp",
  "km",
  "dm",
  //decimeter
  "cm",
  "mm",
  "mi",
  "td",
  "hr",
  //hour
  "hrs",
  //hour
  "kg",
  "hg",
  "dg",
  //decigram
  "cg",
  //centigram
  "mg",
  //milligram
  "µg",
  //microgram
  "lb",
  //pound
  "oz",
  //ounce
  "sq ft",
  "hz",
  //hertz
  "mps",
  //meters per second
  "mph",
  "kmph",
  //kilometers per hour
  "kb",
  //kilobyte
  "mb",
  //megabyte
  // 'gb', //ambig
  "tb",
  //terabyte
  "lx",
  //lux
  "lm",
  //lumen
  // 'pa', //ambig
  "fl oz",
  //
  "yb"
];

// ../../node_modules/compromise/src/1-one/tokenize/model/lexicon.js
var list = [
  [misc_default],
  [units_default, "Unit"],
  [nouns_default, "Noun"],
  [honorifics_default, "Honorific"],
  [months_default, "Month"],
  [organizations_default, "Organization"],
  [places_default, "Place"]
];
var abbreviations = {};
var lexicon2 = {};
list.forEach((a2) => {
  a2[0].forEach((w) => {
    abbreviations[w] = true;
    lexicon2[w] = "Abbreviation";
    if (a2[1] !== void 0) {
      lexicon2[w] = [lexicon2[w], a2[1]];
    }
  });
});

// ../../node_modules/compromise/src/1-one/tokenize/model/prefixes.js
var prefixes_default = [
  "anti",
  "bi",
  "co",
  "contra",
  "de",
  "extra",
  "infra",
  "inter",
  "intra",
  "macro",
  "micro",
  "mis",
  "mono",
  "multi",
  "peri",
  "pre",
  "pro",
  "proto",
  "pseudo",
  "re",
  "sub",
  "supra",
  "trans",
  "tri",
  "un",
  "out",
  //out-lived
  "ex"
  //ex-wife
  // 'counter',
  // 'mid',
  // 'out',
  // 'non',
  // 'over',
  // 'post',
  // 'semi',
  // 'super', //'super-cool'
  // 'ultra', //'ulta-cool'
  // 'under',
  // 'whole',
].reduce((h2, str) => {
  h2[str] = true;
  return h2;
}, {});

// ../../node_modules/compromise/src/1-one/tokenize/model/suffixes.js
var suffixes_default = {
  "like": true,
  "ish": true,
  "less": true,
  "able": true,
  "elect": true,
  "type": true,
  "designate": true
  // 'fold':true,
};

// ../../node_modules/compromise/src/1-one/tokenize/model/unicode.js
var compact = {
  "!": "¡",
  "?": "¿Ɂ",
  '"': '“”"❝❞',
  "'": "‘‛❛❜’",
  "-": "—–",
  a: "ªÀÁÂÃÄÅàáâãäåĀāĂăĄąǍǎǞǟǠǡǺǻȀȁȂȃȦȧȺΆΑΔΛάαλАаѦѧӐӑӒӓƛæ",
  b: "ßþƀƁƂƃƄƅɃΒβϐϦБВЪЬвъьѢѣҌҍ",
  c: "¢©ÇçĆćĈĉĊċČčƆƇƈȻȼͻͼϲϹϽϾСсєҀҁҪҫ",
  d: "ÐĎďĐđƉƊȡƋƌ",
  e: "ÈÉÊËèéêëĒēĔĕĖėĘęĚěƐȄȅȆȇȨȩɆɇΈΕΞΣέεξϵЀЁЕеѐёҼҽҾҿӖӗ",
  f: "ƑƒϜϝӺӻҒғſ",
  g: "ĜĝĞğĠġĢģƓǤǥǦǧǴǵ",
  h: "ĤĥĦħƕǶȞȟΉΗЂЊЋНнђћҢңҤҥҺһӉӊ",
  I: "ÌÍÎÏ",
  i: "ìíîïĨĩĪīĬĭĮįİıƖƗȈȉȊȋΊΐΪίιϊІЇії",
  j: "ĴĵǰȷɈɉϳЈј",
  k: "ĶķĸƘƙǨǩΚκЌЖКжкќҚқҜҝҞҟҠҡ",
  l: "ĹĺĻļĽľĿŀŁłƚƪǀǏǐȴȽΙӀӏ",
  m: "ΜϺϻМмӍӎ",
  n: "ÑñŃńŅņŇňŉŊŋƝƞǸǹȠȵΝΠήηϞЍИЙЛПийлпѝҊҋӅӆӢӣӤӥπ",
  o: "ÒÓÔÕÖØðòóôõöøŌōŎŏŐőƟƠơǑǒǪǫǬǭǾǿȌȍȎȏȪȫȬȭȮȯȰȱΌΘΟθοσόϕϘϙϬϴОФоѲѳӦӧӨөӪӫ",
  p: "ƤΡρϷϸϼРрҎҏÞ",
  q: "Ɋɋ",
  r: "ŔŕŖŗŘřƦȐȑȒȓɌɍЃГЯгяѓҐґ",
  s: "ŚśŜŝŞşŠšƧƨȘșȿЅѕ",
  t: "ŢţŤťŦŧƫƬƭƮȚțȶȾΓΤτϮТт",
  u: "ÙÚÛÜùúûüŨũŪūŬŭŮůŰűŲųƯưƱƲǓǔǕǖǗǘǙǚǛǜȔȕȖȗɄΰυϋύ",
  v: "νѴѵѶѷ",
  w: "ŴŵƜωώϖϢϣШЩшщѡѿ",
  x: "×ΧχϗϰХхҲҳӼӽӾӿ",
  y: "ÝýÿŶŷŸƳƴȲȳɎɏΎΥΫγψϒϓϔЎУучўѰѱҮүҰұӮӯӰӱӲӳ",
  z: "ŹźŻżŽžƵƶȤȥɀΖ"
};
var unicode = {};
Object.keys(compact).forEach(function(k2) {
  compact[k2].split("").forEach(function(s3) {
    unicode[s3] = k2;
  });
});
var unicode_default2 = unicode;

// ../../node_modules/compromise/src/1-one/tokenize/model/punctuation.js
var prePunctuation = {
  "#": true,
  //#hastag
  "@": true,
  //@atmention
  "_": true,
  //underscore
  "°": true,
  // '+': true,//+4
  // '\\-',//-4  (escape)
  // '.',//.4
  // zero-width chars
  "​": true,
  "‌": true,
  "‍": true,
  "\uFEFF": true
};
var postPunctuation = {
  "%": true,
  //88%
  "_": true,
  //underscore
  "°": true,
  //degrees, italian ordinal
  // '\'',// sometimes
  // zero-width chars
  "​": true,
  "‌": true,
  "‍": true,
  "\uFEFF": true
};
var emoticons = {
  "<3": true,
  "</3": true,
  "<\\3": true,
  ":^P": true,
  ":^p": true,
  ":^O": true,
  ":^3": true
};

// ../../node_modules/compromise/src/1-one/tokenize/model/index.js
var model_default2 = {
  one: {
    aliases: aliases_default,
    abbreviations,
    prefixes: prefixes_default,
    suffixes: suffixes_default,
    prePunctuation,
    postPunctuation,
    lexicon: lexicon2,
    //give this one forward
    unicode: unicode_default2,
    emoticons
  }
};

// ../../node_modules/compromise/src/1-one/tokenize/compute/alias.js
var hasSlash = /\//;
var hasDomain = /[a-z]\.[a-z]/i;
var isMath = /[0-9]/;
var addAliases = function(term, world2) {
  let str = term.normal || term.text || term.machine;
  const aliases3 = world2.model.one.aliases;
  if (aliases3.hasOwnProperty(str)) {
    term.alias = term.alias || [];
    term.alias.push(aliases3[str]);
  }
  if (hasSlash.test(str) && !hasDomain.test(str) && !isMath.test(str)) {
    let arr = str.split(hasSlash);
    if (arr.length <= 2) {
      arr.forEach((word) => {
        word = word.trim();
        if (word !== "") {
          term.alias = term.alias || [];
          term.alias.push(word);
        }
      });
    }
  }
  return term;
};
var alias_default = addAliases;

// ../../node_modules/compromise/src/1-one/tokenize/compute/machine.js
var hasDash3 = /^\p{Letter}+-\p{Letter}+$/u;
var doMachine = function(term) {
  let str = term.implicit || term.normal || term.text;
  str = str.replace(/['’]s$/, "");
  str = str.replace(/s['’]$/, "s");
  str = str.replace(/([aeiou][ktrp])in'$/, "$1ing");
  if (hasDash3.test(str)) {
    str = str.replace(/-/g, "");
  }
  str = str.replace(/^[#@]/, "");
  if (str !== term.normal) {
    term.machine = str;
  }
};
var machine_default = doMachine;

// ../../node_modules/compromise/src/1-one/tokenize/compute/freq.js
var freq = function(view) {
  let docs = view.docs;
  let counts = {};
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t3 = 0; t3 < docs[i3].length; t3 += 1) {
      let term = docs[i3][t3];
      let word = term.machine || term.normal;
      counts[word] = counts[word] || 0;
      counts[word] += 1;
    }
  }
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t3 = 0; t3 < docs[i3].length; t3 += 1) {
      let term = docs[i3][t3];
      let word = term.machine || term.normal;
      term.freq = counts[word];
    }
  }
};
var freq_default = freq;

// ../../node_modules/compromise/src/1-one/tokenize/compute/offset.js
var offset = function(view) {
  let elapsed = 0;
  let index3 = 0;
  let docs = view.document;
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t3 = 0; t3 < docs[i3].length; t3 += 1) {
      let term = docs[i3][t3];
      term.offset = {
        index: index3,
        start: elapsed + term.pre.length,
        length: term.text.length
      };
      elapsed += term.pre.length + term.text.length + term.post.length;
      index3 += 1;
    }
  }
};
var offset_default = offset;

// ../../node_modules/compromise/src/1-one/tokenize/compute/reindex.js
var index2 = function(view) {
  let document = view.document;
  for (let n3 = 0; n3 < document.length; n3 += 1) {
    for (let i3 = 0; i3 < document[n3].length; i3 += 1) {
      document[n3][i3].index = [n3, i3];
    }
  }
};
var reindex_default = index2;

// ../../node_modules/compromise/src/1-one/tokenize/compute/wordCount.js
var wordCount2 = function(view) {
  let n3 = 0;
  let docs = view.docs;
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t3 = 0; t3 < docs[i3].length; t3 += 1) {
      if (docs[i3][t3].normal === "") {
        continue;
      }
      n3 += 1;
      docs[i3][t3].wordCount = n3;
    }
  }
};
var wordCount_default = wordCount2;

// ../../node_modules/compromise/src/1-one/tokenize/compute/index.js
var termLoop = function(view, fn) {
  let docs = view.docs;
  for (let i3 = 0; i3 < docs.length; i3 += 1) {
    for (let t3 = 0; t3 < docs[i3].length; t3 += 1) {
      fn(docs[i3][t3], view.world);
    }
  }
};
var methods15 = {
  alias: (view) => termLoop(view, alias_default),
  machine: (view) => termLoop(view, machine_default),
  normal: (view) => termLoop(view, normal_default),
  freq: freq_default,
  offset: offset_default,
  index: reindex_default,
  wordCount: wordCount_default
};
var compute_default6 = methods15;

// ../../node_modules/compromise/src/1-one/tokenize/plugin.js
var plugin_default11 = {
  compute: compute_default6,
  methods: methods_default8,
  model: model_default2,
  hooks: ["alias", "machine", "index", "id"]
};

// ../../node_modules/compromise/src/1-one/typeahead/compute.js
var typeahead = function(view) {
  const prefixes2 = view.model.one.typeahead;
  const docs = view.docs;
  if (docs.length === 0 || Object.keys(prefixes2).length === 0) {
    return;
  }
  let lastPhrase = docs[docs.length - 1] || [];
  let lastTerm = lastPhrase[lastPhrase.length - 1];
  if (lastTerm.post) {
    return;
  }
  if (prefixes2.hasOwnProperty(lastTerm.normal)) {
    let found = prefixes2[lastTerm.normal];
    lastTerm.implicit = found;
    lastTerm.machine = found;
    lastTerm.typeahead = true;
    if (view.compute.preTagger) {
      view.last().unTag("*").compute(["lexicon", "preTagger"]);
    }
  }
};
var compute_default7 = { typeahead };

// ../../node_modules/compromise/src/1-one/typeahead/api.js
var autoFill = function() {
  const docs = this.docs;
  if (docs.length === 0) {
    return this;
  }
  let lastPhrase = docs[docs.length - 1] || [];
  let term = lastPhrase[lastPhrase.length - 1];
  if (term.typeahead === true && term.machine) {
    term.text = term.machine;
    term.normal = term.machine;
  }
  return this;
};
var api2 = function(View2) {
  View2.prototype.autoFill = autoFill;
};
var api_default9 = api2;

// ../../node_modules/compromise/src/1-one/typeahead/lib/allPrefixes.js
var getPrefixes = function(arr, opts2, world2) {
  let index3 = {};
  let collisions = [];
  let existing = world2.prefixes || {};
  arr.forEach((str) => {
    str = str.toLowerCase().trim();
    let max3 = str.length;
    if (opts2.max && max3 > opts2.max) {
      max3 = opts2.max;
    }
    for (let size = opts2.min; size < max3; size += 1) {
      let prefix5 = str.substring(0, size);
      if (opts2.safe && world2.model.one.lexicon.hasOwnProperty(prefix5)) {
        continue;
      }
      if (existing.hasOwnProperty(prefix5) === true) {
        collisions.push(prefix5);
        continue;
      }
      if (index3.hasOwnProperty(prefix5) === true) {
        collisions.push(prefix5);
        continue;
      }
      index3[prefix5] = str;
    }
  });
  index3 = Object.assign({}, existing, index3);
  collisions.forEach((str) => {
    delete index3[str];
  });
  return index3;
};
var allPrefixes_default = getPrefixes;

// ../../node_modules/compromise/src/1-one/typeahead/lib/index.js
var isObject7 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var defaults2 = {
  safe: true,
  min: 3
};
var prepare = function(words = [], opts2 = {}) {
  let model5 = this.model();
  opts2 = Object.assign({}, defaults2, opts2);
  if (isObject7(words)) {
    Object.assign(model5.one.lexicon, words);
    words = Object.keys(words);
  }
  let prefixes2 = allPrefixes_default(words, opts2, this.world());
  Object.keys(prefixes2).forEach((str) => {
    if (model5.one.typeahead.hasOwnProperty(str)) {
      delete model5.one.typeahead[str];
      return;
    }
    model5.one.typeahead[str] = prefixes2[str];
  });
  return this;
};
var lib_default5 = {
  typeahead: prepare
};

// ../../node_modules/compromise/src/1-one/typeahead/plugin.js
var model3 = {
  one: {
    typeahead: {}
    //set a blank key-val
  }
};
var plugin_default12 = {
  model: model3,
  api: api_default9,
  lib: lib_default5,
  compute: compute_default7,
  hooks: ["typeahead"]
};

// ../../node_modules/compromise/src/one.js
nlp_default.extend(plugin_default2);
nlp_default.extend(plugin_default7);
nlp_default.extend(plugin_default6);
nlp_default.extend(plugin_default8);
nlp_default.extend(plugin_default10);
nlp_default.plugin(plugin_default3);
nlp_default.extend(plugin_default11);
nlp_default.plugin(plugin_default);
nlp_default.extend(plugin_default5);
nlp_default.extend(plugin_default12);
nlp_default.extend(plugin_default4);
nlp_default.extend(plugin_default9);
var one_default = nlp_default;

// ../../node_modules/compromise/src/2-two/preTagger/model/irregulars/plurals.js
var plurals_default = {
  // -a
  addendum: "addenda",
  corpus: "corpora",
  criterion: "criteria",
  curriculum: "curricula",
  genus: "genera",
  memorandum: "memoranda",
  opus: "opera",
  ovum: "ova",
  phenomenon: "phenomena",
  referendum: "referenda",
  // -ae
  alga: "algae",
  alumna: "alumnae",
  antenna: "antennae",
  formula: "formulae",
  larva: "larvae",
  nebula: "nebulae",
  vertebra: "vertebrae",
  // -is
  analysis: "analyses",
  axis: "axes",
  diagnosis: "diagnoses",
  parenthesis: "parentheses",
  prognosis: "prognoses",
  synopsis: "synopses",
  thesis: "theses",
  neurosis: "neuroses",
  // -x
  appendix: "appendices",
  index: "indices",
  matrix: "matrices",
  ox: "oxen",
  sex: "sexes",
  // -i
  alumnus: "alumni",
  bacillus: "bacilli",
  cactus: "cacti",
  fungus: "fungi",
  hippopotamus: "hippopotami",
  libretto: "libretti",
  modulus: "moduli",
  nucleus: "nuclei",
  octopus: "octopi",
  radius: "radii",
  stimulus: "stimuli",
  syllabus: "syllabi",
  // -ie
  cookie: "cookies",
  calorie: "calories",
  auntie: "aunties",
  movie: "movies",
  pie: "pies",
  rookie: "rookies",
  tie: "ties",
  zombie: "zombies",
  // -f
  leaf: "leaves",
  loaf: "loaves",
  thief: "thieves",
  // ee-
  foot: "feet",
  goose: "geese",
  tooth: "teeth",
  // -eaux
  beau: "beaux",
  chateau: "chateaux",
  tableau: "tableaux",
  // -ses
  bus: "buses",
  gas: "gases",
  circus: "circuses",
  crisis: "crises",
  virus: "viruses",
  database: "databases",
  excuse: "excuses",
  abuse: "abuses",
  avocado: "avocados",
  barracks: "barracks",
  child: "children",
  clothes: "clothes",
  echo: "echoes",
  embargo: "embargoes",
  epoch: "epochs",
  deer: "deer",
  halo: "halos",
  man: "men",
  woman: "women",
  mosquito: "mosquitoes",
  mouse: "mice",
  person: "people",
  quiz: "quizzes",
  rodeo: "rodeos",
  shoe: "shoes",
  sombrero: "sombreros",
  stomach: "stomachs",
  tornado: "tornados",
  tuxedo: "tuxedos",
  volcano: "volcanoes"
};

// ../../node_modules/compromise/src/2-two/preTagger/model/lexicon/_data.js
var data_default = {
  "Comparative": "true¦bett1f0;arth0ew0in0;er",
  "Superlative": "true¦earlier",
  "PresentTense": "true¦bests,sounds",
  "Condition": "true¦lest,unless",
  "PastTense": "true¦began,came,d4had,kneel3l2m0sa4we1;ea0sg2;nt;eap0i0;ed;id",
  "Participle": "true¦0:0A;a07b02c00dXeat0fSgQhPoJprov0rHs7t6u4w1;ak0ithdra03o2r1;i03uZ;k0v0;nd1pr05;ergoJoJ;ak0hHo3;e9h7lain,o6p5t4un3w1;o1um;rn;g,k;ol0reT;iRok0;ught,wn;ak0o1ruL;ne,wn;en,wn;ewriOi1uK;dd0s0;ut3ver1;do4se0t1;ak0h2;do2g1;roH;ne;ast0i7;iv0o1;ne,tt0;all0loCor1;bi3g2s1;ak0e0;iv0oA;dd0;ove,r1;a6eamt,iv0u1;nk;hos0lu1;ng;e4i3lo2ui1;lt;wn;tt0;at0en,gun;r2w1;ak0ok0;is0;en",
  "Gerund": "true¦accord0be0doin,go0result0stain0;ing",
  "Expression": "true¦a0Xb0Tc0Rd0Ne0Lg0FhZjeez,lWmVnToNpKsItHuEvDw6y0;a4e3i1u0;ck,p;k04p0;ee,pee;ah,p,s;!a,y;a5h2o1t0;af,f;rd up,w;atsoever,e1o0;a,ops;e,w;hoo,t;ery wEoi0L;gh,h0;! 0h,m;huh,oh;here nQsk,ut tut;h0ic;eesh,hh,it,oo;ff,h1l0ow,sst;ease,s,z;ew,ooey;h1i,mg,o0uch,w,y;h,o,ps;! 0h;h1my go0w1;d,sh;ell;ah,evertheless,o0;!pe;eh,mm;ah,eh,m1ol0;!s;ao,fao;aCeBi9o2u0;h,mph,rra0zzC;h,y;l1o0;r6y9;la,y0;! 0;c1moCsmok0;es;ow;!p hip hoor0;ay;ck,e,llo,y;ha1i,lleluj0;ah;!ha;ah,ee4o1r0;eat scott,r;l1od0sh; grief,bye;ly;! whiz;e0h,t cetera,ww,xcuse me;k,p;'oh,a0rat,uh;m0ng;mit,n0;!it;mon,o0;ngratulations,wabunga;a2oo1r0tw,ye;avo,r;!ya;h,m; 1h0ka,las,men,rgh,ye;!a,em,h,oy;la",
  "Negative": "true¦n0;ever,o0;n,t",
  "QuestionWord": "true¦how3wh0;at,e1ich,o0y;!m,se;n,re; come,'s",
  "Reflexive": "true¦h4it5my5o1the0your2;ir1m1;ne3ur0;sel0;f,ves;er0im0;self",
  "Plural": "true¦dick0gre0ones,records;ens",
  "Unit|Noun": "true¦cEfDgChBinchAk9lb,m6newt5oz,p4qt,t1y0;ardEd;able1b0ea1sp;!l,sp;spo1;a,t,x;on9;!b,g,i1l,m,p0;h,s;!les;!b,elvin,g,m;!es;g,z;al,b;eet,oot,t;m,up0;!s",
  "Value": "true¦a few",
  "Imperative": "true¦bewa0come he0;re",
  "Plural|Verb": "true¦leaves",
  "Demonym": "true¦0:15;1:12;a0Vb0Oc0Dd0Ce08f07g04h02iYjVkTlPmLnIomHpEqatari,rCs7t5u4v3welAz2;am0Gimbabwe0;enezuel0ietnam0I;gAkrai1;aiwTex0hai,rinida0Ju2;ni0Prkmen;a5cotti4e3ingapoOlovak,oma0Spaniard,udRw2y0W;ede,iss;negal0Cr09;sh;mo0uT;o5us0Jw2;and0;a2eru0Fhilippi0Nortugu07uerto r0S;kist3lesti1na2raguay0;ma1;ani;ami00i2orweP;caragu0geri2;an,en;a3ex0Lo2;ngo0Drocc0;cedo1la2;gasy,y07;a4eb9i2;b2thua1;e0Cy0;o,t01;azakh,eny0o2uwaiI;re0;a2orda1;ma0Ap2;anO;celandic,nd4r2sraeli,ta01vo05;a2iB;ni0qi;i0oneU;aiAin2ondur0unO;di;amEe2hanai0reek,uatemal0;or2rm0;gi0;ilipino,ren8;cuadoVgyp4mira3ngli2sto1thiopi0urope0;shm0;ti;ti0;aPominUut3;a9h6o4roat3ub0ze2;ch;!i0;lom2ngol5;bi0;a6i2;le0n2;ese;lifor1m2na3;bo2eroo1;di0;angladeshi,el6o4r3ul2;gaE;azi9it;li2s1;vi0;aru2gi0;si0;fAl7merBngol0r5si0us2;sie,tr2;a2i0;li0;genti2me1;ne;ba1ge2;ri0;ni0;gh0r2;ic0;an",
  "Organization": "true¦0:4D;a3Gb2Yc2Ed26e22f1Xg1Ph1Ki1Hj1Fk1Dl18m0Wn0Jo0Gp09qu08r01sTtGuBv8w3xiaomi,y1;amaha,m13ou1w13;gov,tu2Z;a3e1orld trade organizati2S;lls fargo,st1;fie28inghou2I;l1rner br3I;gree37l street journ29m17;an halOeriz2Nisa,o1;dafo2Ol1;kswagMvo;b4kip,n2ps,s1;a tod2Yps;es3Ai1;lev33ted natio30;er,s; mobi2Qaco beQd bNeAgi frida9h3im horto2Ymz,o1witt31;shi3Xy1;ota,s r 00;e 1in lizzy;b3carpen37daily ma31guess w2holli0rolling st1Rs1w2;mashing pumpki2Tuprem0;ho;ea1lack eyed pe3Lyrds;ch bo1tl0;ys;l2n3Ds1xas instrumen1J;co,la m15;efoni0Cus;a7e4ieme2Lnp,o2pice gir5quare04ta1ubaru;rbucks,to2R;ny,undgard1;en;a2x pisto1;ls;g1Nrs;few2Ainsbury2QlesforYmsu22;.e.m.,adiohead,b6e3oyal 1yana30;b1dutch she4;ank;aders dige1Gd 1max,vl1R;bu1c1Zhot chili peppe2Nlobst2C;ll;c,s;ant30izno2I;a5bs,e3fiz28hilip morrCi2r1;emier2Audenti16;nk floyd,zza hut;psi2Btro1uge0A;br2Vchina,n2V;lant2Nn1yp12; 2ason20da2I;ld navy,pec,range juli2xf1;am;us;aAb9e6fl,h5i4o1sa,vid3wa;k2tre dame,vart1;is;ia;ke,ntendo,ss0L;l,s;c,st1Htflix,w1; 1sweek;kids on the block,york09;a,c;nd1Vs2t1;ional aca2Io,we0Q;a,cYd0O;aBcdonaldAe7i5lb,o3tv,y1;spa1;ce;b1Mnsanto,ody blu0t1;ley crue,or0O;crosoft,t1;as,subisM;dica2rcedes benz,talli1;ca;id,re;'s,s;c's milk,tt14z1Z;'ore08a3e1g,ittle caesa1K;novo,x1;is,mark; 1bour party;pres0Bz boy;atv,fc,kk,m1od1J;art;iffy lu0Moy divisi0Gpmorgan1sa;! cha07;bm,hop,n1tv;g,te1;l,rpol;asbro,ewlett pack1Ri3o1sbc,yundai;me dep1n1L;ot;tac1zbollah;hi;eneral 6hq,ithub,l5mb,o2reen d0Lu1;cci,ns n ros0;ldman sachs,o1;dye1g0E;ar;axo smith kli03encoV;electr0Km1;oto0W;a4bi,da,edex,i2leetwood mac,o1rito l0D;rd,xcX;at,nancial1restoY; tim0;cebook,nnie mae;b08sa,u3xxon1; m1m1;ob0H;!rosceptics;aiml0Be6isney,o4u1;nkin donu2po0Xran dur1;an;ts;j,w j1;on0;a,f lepp0Zll,peche mode,r spiegZstiny's chi1;ld;aIbc,hEiCloudflaBnn,o3r1;aigsli5eedence clearwater reviv1ossra06;al;ca c7inba6l4m1o0Bst06;ca2p1;aq;st;dplPg1;ate;se;ola;re;a,sco1tigroup;! systems;ev2i1;ck fil-a,na daily;r1y;on;dbury,pital o1rl's jr;ne;aEbc,eBf9l5mw,ni,o1p,rexiteeU;ei3mbardiIston 1;glo1pizza;be;ng;o2ue c1;roV;ckbuster video,omingda1;le; g1g1;oodriL;cht2e ge0rkshire hathaw1;ay;el;idu,nana republ3s1xt5y5;f,kin robbi1;ns;ic;bYcTdidSerosmith,iRlKmEnheuser-busDol,pple9r6s3utodesk,v2y1;er;is,on;hland1sociated F; o1;il;by4g2m1;co;os; compu2bee1;'s;te1;rs;ch;c,d,erican3t1;!r1;ak; ex1;pre1;ss; 5catel2ta1;ir;!-lu1;ce1;nt;jazeera,qae1;da;g,rbnb;as;/dc,a3er,tivision1;! blizz1;ard;demy of scienc0;es;ba",
  "Possessive": "true¦its,my,our0thy;!s",
  "Noun|Verb": "true¦0:9U;1:A8;2:94;3:A1;4:9P;5:A0;6:9I;7:8L;8:7J;9:A6;A:91;B:8V;C:8B;a9Mb8Oc7Gd6Pe6Ef5Qg5Gh54i4Wj4Tk4Ql4Em40n3Vo3Sp2Squ2Rr21s0Jt02u00vVwGyFzD;ip,oD;ne,om;awn,e6Die66;aOeMhJiHoErD;ap,e9Mink2;nd0rDuB;kDry,sh5Fth;!shop;ck,nDpe,re,sh;!d,g;e84iD;p,sD;k,p0t2;aDed,lco8U;r,th0;it,lk,rEsDt4ve,x;h,te;!ehou1ra9;aGen5DiFoD;iDmAte,w;ce,d;be,ew,sA;cuum,l4A;pDr7;da5gra6Clo68;aReQhrPiOoMrGuEwiDy5X;n,st;nDrn;e,n7M;aGeFiEoDu6y;t,ub2;bu5ck4Igg0m,p;at,k,nd;ck,de,in,nsDp,v7H;f0i8P;ll,ne,p,r4Wss,t92uD;ch,r;ck,de,e,le,me,p,re;e5Uow,u6;ar,e,ll,mp0st,xt;g,lDng2rg7Ns5x;k,ly;a0Sc0Ne0Kh0Fi0Dk0Bl09m08n06o05pXquaCtKuFwD;ea86iD;ng,pe,t4;bGit,m,ppErD;fa3ge,pri1v2U;lDo6Q;e6Ny;!je8;aMeLiKoHrEuDy2;dy,ff,mb2;a83eEiDo5Nugg2;ke,ng;am,ss,t4;ckEop,p,rD;e,m;ing,pi2;ck,nk,t4;er,m,p;ck,ff,ge,in,ke,lEmp,nd,p2rDte,y;!e,t;k,l;aJeIiHlGoFrDur,y;ay,e54inDu3;g,k2;ns89t;a5Oit;ll,n,r85te;ed,ll;m,n,rk;b,uB;aDee1Tow;ke,p;a5He4Di2o51;eep,iDou4;ce,p,t;ateboa7HiD;!p;de,gnDl2Unk,p,ze;!al;aGeFiEoDuff2;ck,p,re,w;ft,p,v0;d,i3Wlt0;ck,de,pe,re,ve;aEed,nDrv1It;se,t2M;l,r4t;aGhedu2oCrD;aEeDibb2o3X;en,w;pe,t4;le,n,r2L;cDfegua70il,mp2;k,rifi3;aZeHhy6JiGoEuD;b,in,le,n,s5V;a6ck,ll,oDpe,u5;f,t;de,ng,ot,p,s1V;aTcSdo,el,fQgPje8lOmMnLo17pJque6sFturn,vDwa6T;eDi26;al,r1;er72oFpe8tEuD;lt,me;!a53;l6Zrt;air,eaDly,o51;l,t;dezvo2Xt;aDedy;ke,rk;ea1i4E;a6Gist0r5L;act6Wer1Uo6ZuD;nd,se;a36o6D;ch,s6E;c1Cge,iEke,lly,nDp1Vt1V;ge,k,t;n,se;es69iv0;a04e00hYiXlToNrEsy4uD;mp,n4rcha1sh;aKeIiHoDu4M;be,ceFdu3fi2grDje8mi1p,te6;amDe6U;!me;ed,ss;ce,de,nt;sDy;er6As;cti3i1;iHlFoEp,re,sDuBw0;e,i5Wt;l,p;iDl;ce,sh;nt,s5T;aEce,e30uD;g,mp,n7;ce,nDy;!t;ck,le,n16pe,tNvot;a1oD;ne,tograph;ak,eFnErDt;fu53mA;!c30;!l,r;ckJiInHrFsEtDu1y;ch,e9;s,te;k,tD;!y;!ic;nt,r,se;!a7;bje8ff0il,oErDutli3Over49;bAd0ie9;ze;a4PeFoDur1;d,tD;e,i3;ed,gle8tD;!work;aMeKiIoEuD;rd0;ck,d3Pld,nEp,uDve;nt,th;it5CkD;ey;lk,n49rr5AsDx;s,ta29;asuCn4SrDss;ge,it;il,nFp,rk3UsEtD;ch,t0;h,k,t0;da5n0oeuvC;aLeJiHoEuD;mp,st;aEbby,ck,g,oDve;k,t;d,n;cDft,mAnHst;en1k;aDc0Ne4vJ;ch,d,k,p,se;bEcDnd,p,t4un4;e,k;el,o2T;eEiDno4D;ck,d,ll,ss;el,y;aEo1NuD;i3mp;m,zz;mpJnEr45ssD;ue;c1Qdex,fluGha2k,se2GteDvoi3;nt,rD;e6fa3viD;ew;en3;a8le29;aJeHiGoEuD;g,nt;l39no2Cok,pDr1u1;!e;ghli1Eke,nt,re,t;aDd7lp;d,t;ck,mGndFrEsh,tDu9;ch,e;bo3Wm,ne4Dve6;!le;!m0;aLear,ift,lJossIrFuD;arDe49lp,n;antee,d;aEiDouBumb2;ll,nd,p;de,sp;ip;oDue;ss,w;g,in,me,ng,s,te,ze;aZeWiRlNoJrFuD;ck,el,nDss,zz;c38d;aEoDy;st,wn;cDgme,me,nchi1;tuC;cFg,il,ld,rD;ce,e29mDwa31;!at;us;aFe0Vip,oDy;at,ck,od,wD;!er;g,ke,me,re,sh,vo1E;eGgFlEnDre,sh,t,x;an3i0Q;e,m,t0;ht,uC;ld;aEeDn3;d,l;r,tuC;ce,il,ll,rm,vo2W;cho,d7ffe8nMsKxFyeD;!baD;ll;cGerci1hFpDtra8;eriDo0W;en3me9;au6ibA;el,han7u1;caDtima5;pe;count0d,vy;a01eSiMoJrEuDye;b,el,mp,pli2X;aGeFiEoD;ne,p;ft,ll,nk,p,ve;am,ss;ft,g,in;cEd7ubt,wnloD;ad;k,u0E;ge6p,sFt4vD;e,iDor3;de;char7gui1h,liEpD;at4lay,u5;ke;al,bKcJfeIlGmaBposAsEtaD;il;e07iD;gn,re;ay,ega5iD;ght;at,ct;li04rea1;a5ut;b,ma7n3rDte;e,t;a0Eent0Dh06irc2l03oKrFuD;be,e,rDt;b,e,l,ve;aGeFoEuDy;sh;p,ss,wd;dAep;ck,ft,sh;at,de,in,lTmMnFordina5py,re,st,uDv0;gh,nDp2rt;s01t;ceHdu8fli8glomeIsFtDveN;a8rD;a6ol;e9tru8;ct;ntDrn;ra5;bHfoGmFpD;leDouBromi1;me9;aBe9it,u5;rt;at,iD;ne;lap1oD;r,ur;aEiDoud,ub;ck,p;im,w;aEeDip;at,ck,er;iGllen7nErD;ge,m,t;ge,nD;el;n,r;er,re;ke,ll,mp,noe,pGrXsFtEuDve;se,ti0I;alog,ch;h,t;!tuC;re;a03eZiXlToPrHuEyD;pa11;bb2ck2dgEff0mp,rDst,zz;den,n;et;anJeHiFoadEuD;i1sh;ca6;be,d7;ge;aDed;ch,k;ch,d;aFg,mb,nEoDrd0tt2x,ycott;k,st,t;d,e;rd,st;aFeBiDoYur;nk,tz;nd;me;as,d,ke,nd,opsy,tD;!ch,e;aFef,lt,nDt;d,efA;it;r,t;ck,il,lan3nIrFsEtt2;le;e,h;!gDk;aDe;in;!d,g,k;bu1c05dZge,iYlVnTppQrLsIttGucEwaD;rd;tiD;on;aDempt;ck;k,sD;i6ocia5;st;chFmD;!oD;ur;!iD;ve;eEroa4;ch;al;chDg0sw0;or;aEt0;er;rm;d,m,r;dreHvD;an3oD;ca5;te;ce;ss;cDe,he,t;eFoD;rd,u9;nt;nt,ss;se",
  "Actor": "true¦0:7C;1:7H;2:6B;3:7G;4:7P;5:7L;6:72;a6Pb64c4Xd4De43f3Tg3Ch31i2Vj2Rkin2Ql2Lm27n20o1Tp0Wqu0Ur0KsRtKuIvFw9yo7;gi,ut7;h,ub0;aBeAi9o8r7;estl0it0;m2rk0;fe,nn0t2Cza2I;atherm2ld0;ge earn0it0nder0rri1;eter8i7oyG;ll5Sp,s41;an,ina2V;n7s0;c6Wder04;aoisea24eAherapi5iktok0o9r7ut1yco6;a7endseMo45;d0mp,nscri0Cvel0;ddl0u1H;a0Rchn8en7na4st0;ag0;i3Qo0E;aiYcVeShQiNki0mu27oKpHquaGtCu8wee7;p0theart;lt2per8r7;f0ge6viv1;h7inten0Jst5Kvis1;ero,um2;a9ep8r7;ang0eam0;bro2Oc2Pfa2Omo2Osi21;ff0tesm2;tt0;ec8ir2Eo7;kesp5Bu0N;ia5Lt3;l8me6Cn,rcere7ul;r,ss;di0oi5;n8s7;sy,t0;g0n0;am2ephe1Jow7;girl,m2r2R;cretJnior cit3Hr7;gea4v7;a4it1;hol4Zi8reen7ulpt1;wr2D;e02on;l1nt;aFeAo9u7;l0nn7;er up,ingF;g42le mod41of0;a51c9fug2Rpo34searRv7;ere4Wolution7;ary;e7luZru23;ptio3V;bbi,dic5Xpp0;arter7e31;back;aZeXhTiSlPoLr9sycho8u7;nk,p34;logi5;aHeEiCo7;dAfess1g8ph49s7;pe2Mtitu53;en7ramm0;it1y;igy,uc0;est4Pme mini0Vnce7s3G;!ss;a8si7;de4;ch0;ctiti3Bnk0Q;dca0Pet,li7pula52rnst44;c2Ktic7;al scie7i2;nti5;a7umb0;nn0y7;er,ma4Nwright;lgrim,one0;a9iloso8otogra8ra7ysi1X;se;ph0;ntom,rmaci5;r7ssi1V;form0s6;i3Gl,nel40r9st1tr7wn;i7on;arXot;ent4Yi44tn0;ccupa4ffCp9r8ut7;ca5l0C;ac4Kganiz0ig2Hph2;er3t7;i1Lomet7;ri5;ic0spring;aCeAie4Zo8u7;n,rser3L;b7mad,vi4X;le2Xo4F;i7mesis,phew;ce,ghb1;nny,rr3t20;aFeEiBo8u7yst21;m9si18;der3gul,m8n7th0;arEk;!my;ni8s7;f03s0Kt0;on,st0;chan1Tnt1rcha4;giAk0n9rtyr,t7y1;e,riar7;ch;ag0iac;ci2stra3K;a8e2Cieutena4o7;rd,s0v0;bor0d8ndlo7ss,urea3Hwy0ym2;rd;!y;!s2A;anitor ,e9o8u7;ggl0;gg0urna2W;st0;c6dol,llu3Wmmigra4n7;-lAc1Sfa4habi44nov3s8ve7;nt1stig3;pe0Pt7;a1Hig3ru0O;aw;airGeCistoBo9u7ygie1M;man7nt0sba2J;!ita9;bo,st7usekO;age,e3R;ri2;ir,r7;m8o7;!ine;it;dress0sty2E;aMeJhostHirl28ladi3oDrand8u7;e5ru;cAdaugTfa9m8pa7s6;!re4;a,o7;th0;hi1D;al8d7lf0;!de3C;ie,k7te28;eep0;!wr7;it0;isha,n7;i7tl06;us;mbl0rden0;aFella,iBo8r7;eela2Pie1R;e,re7ster pare4;be1Jm2r7st0;unn0;an31g9lmm19nanci0r7tt0;e7st la2J; marsh2Qfig7m2;ht0;rm0th0;conoFdElectriDm9n8x7;amin0cellency,i2B;emy,trepreneur,vironmenta1K;c9p7;er1loye7;e,r;ee;ci2;it1;mi5;aLeCi9ork,ri8u7we03;de,tche2I;ft0vK;ct3eti8plom2Ire7va;ct1;ci2ti2;aEcor3fencDi0JnBputAs8tectNvel7;op0;ce1He7ign0;rt0;ee,y;iz7;en;em2;c6l0;dAnc0redev9ught7;er7;! ;il;!dy;a06e04fo,hXitizenWlToCrAu7;r3stomer7;! representat7;ive;e3it7;ic;-work0lJmGnAord9rpor1Nu7wboy;n7ri0sin ;ciUte1R;in3;fidantBgressTsAt7;e0Lr7;ibut1o7;ll0;tab14ul1P;!e;edi2m7pos0rade;a0FeRissi7;on0;leag9on8um7;ni5;el;ue;e7own;an0r7;ic,k;!s;aAe8i7um;ld;erle7f;ad0;ir8nce7plGract0;ll1;m2wJ;lebri7o;ty;dCptBr7shi0;e8pe7;nt0;r,t7;ak0;ain;et;aNeMiKlogg0oFrCu7;dd0Gild0rglAsiness7;m2p8w7;om2;ers6;ar;i8o7;!k0th0;cklay0de,gadi0;hemi2oge9y7;!frie7;nd;ym2;an;cyc7sS;li5;atbox0ings;by,nk0r7;b0on8te7;nd0;!e08;c05dXge4nRpMrIsGtBu8yatull7;ah;nt8t7;h1oH;!ie;h9t7;e7orney;nda4;ie5le7;te;sis01tron7;aut,om0;chbis9isto8tis7;an,t;crV;hop;ostAp7;ari7rentiT;ti6;on;le;aAcest1im3nou9y7;bo7;dy;nc0;ly5rc7;hi5;mi9v7;entur0is1;er;ni8r7;al;str3;at1;or;counCquaintanBrobAt7;ivi5or,re7;ss;st;at;ce;ta4;nt",
  "Adj|Noun": "true¦0:1F;1:1M;a1Db17c0Vd0Se0Nf0Eg0Bh09i07ju06l03mXnVoTpOrJsCt8u5v2watershed;a2ision10;gabo5nilla,ria2;b0Wnt;ndergr2pstairs;adua14ou2;nd;a4e2oken,ri0;en,r2;min0rori13;boo,n;age,e6ilv0Glack,o4quat,ta3u2well;bordina0Xper6;b0Mndard;ciali0Yl2vereign;e,ve1;cret,n2ri0;ior;a5e3ou2ubbiM;nd,tiZ;ar,bCl0Ynt0p2side1;resent0Xublican;ci0Qsh;a5eriodic0last11otenti0r2;emi3incip0o2;!fession0;er,um;rall5st,tie1;ff2pposi0Hv0;ens0Qi0D;agg02ov2;el;a6e4iniatKo2;bi02der08r2;al,t0;di2tr0P;an,um;le,riH;attPi3u2;sh;ber0ght,qD;stice,veniU;de0mpressioZn2;cumbe1dividu0no0Fsta1terim;alf,o2umdrum;bby,melG;en3old,ra2;ph0Dve;er0ious;a8e6i5l4u2;git05t2;ure;uid;ne;llow,m2;aGiM;ir,t,vo2;riOuriO;l4p02x2;c2ecutWpeX;ess;d2iK;er;ar3e2;mographWrivQ;k,l3;hiGlassUo3rude,unn2;ing;m6n2operM;creCstitue1te3vertab2;le;mpor2nt;ary;ic,m3p2;anion,lex;er3u2;ni8;ci0;e6lank,o5r2;i3u2;te;ef;ttom,urgeois;st;cademCd9l5n3r2;ab,ctB;im0tarctA;al;e4tern2;at2;ive;rt;oles2ult;ce1;nt;ic",
  "Adj|Past": "true¦0:4C;1:40;2:45;3:42;4:3B;a3Tb3Ic2Vd2Ae22f1Wg1Th1Qi1Hj1Ekno1Dl18m13n10o0Vp0Lqu0Jr07sKtEuBvAw5yellow0;a8ea7o5rinkl0;r5u3N;n,ri0;k2Qth3;rp0sh0tY;ari0e1M;n5pd1s0;cov3derstood,i5;fi0t0;a8hreat2Ki7ouTr5urn0wi42;a5imm0ou28;ck0in0pp0;ed,r0;m0nn0r5;get0ni2K;aPcLeJhHimGm0Hoak0pEt8u5;bsid3Fgge3Vs5;pe5ta2P;ct0nd0;a9e8i26ok0r6u5;ff0nn0;ength28ip5;ed,p0;am0reotyp0;in0t0;eci5ik0oI;al35fi0;pSul1;a5ock0ut;d0r0;a5c1Dle2t2S;l0s3Jt0;a7or6r5;at5e1W;ch0;r0tt3;t5ut0;is4ur1;aFe6o5;tt0;cBdJf22gAje2l9m0Knew0p8qu7s5;eTpe2t5;or0ri2;e34ir0;e1lac0;at0e2H;ist3ul1;eiv0o5ycl0;mme2Crd0v3;in0lli0ti4;a5ot0;li4;aCer2RiBlAo9r5ump0;e7i2Go5;ce27d5lo14nou2Spos0te2v0;uc0;fe15ocDp0Fss0;i2Cli1D;ann0e24uT;ck0erc0ss0;ck0i29r5st0;allMk0;bse8c7rgan25ver5;lo5whelm0;ok0;cupi0;rv0;e6o5;t0uri12;ed0gle2;a7e6ix0o5ut0;di4t0Xu1Y;as07lt0;n5rk0;ag0ufact05;e7i6o5;ad0ck0st;cens0mit0st0;ft,v5;el0;tt0wn;a6o0Xu5;dg0s13;gg0;llumin1mpBn5sol1;br0cre1Ddebt0f9jUt6v5;it0olv0;e5ox0Q;gr1n5re1V;d0si4;e2l1o1O;li0oVr5;ov0;amm3e1o5;ok0r5;ri4;ift0r6u5;a14id0;i0Kown;a9e8i7lavo0Goc0Cr5;a5i0oz0S;ctEg13m0;ni04tt0x0;ar0;d0il0;duc1l1mBn9quipp0s8x5;agger1p5te0Q;a0Pe5os0;ct0rie1A;cap0tabliX;gFha18s5;ur0;a0Xbarra0L;aMeEi6r5;a00i0;gni4miniRre2s5;aAc7grun0Et5;o5re0Gurb0;rt0;iplVou5;nt0r5;ag0;bl0;cBdQf9l8pre0Ara7t6v5;elop0ot0;ail0ermP;ng0;ay0ight0;e5in0o0M;rr0;ay0enTor1;m5t0z0;ag0p5;en0;aQeMhJlIoAr7u5;lt5r0stom04;iv1;a6owd0u5;sh0;ck0mp0;d0loBm8n5ok0v3;centr1f6s5troD;id3olid1;us0;b6pl5;ic1;in0;r0ur0;assi4os0utt3;ar6i5;ll0;g0m0;lebr1n7r5;ti4;fi0;tralK;g0lcul1;aEiDlAo8r6urn5;ed,t;ok5uis0;en;il0r0t5und;tl0;e6i5;nd0;ss0;as0;k0laNs0tt3;bandQcOdLfJg0lGmaz0nEppCrm0ssAu6wa5;rd0;g6thor5;iz0;me5;nt0;o7u5;m0r0;li0re5;ci1;im1ticip1;at0;a6leg0t3;er0;rm0;fe2;ct0;ju6o8va5;nc0;st0;ce5knowledg0;pt0;on0;ed",
  "Singular": "true¦0:5J;1:5H;2:4W;3:52;4:4S;5:57;6:5L;7:56;a51b4Jc3Md34e2Wf2Mg2Gh25in21j20k1Zl1Sm1Kn1Go1Ap0Qqu0Pr0EsYtLuGvBw8x r57yo yo;a8ha3Oo3P;f4i4Qt0Fy8;! arou38;arBe9ideo ga2Po8;cabu4Hl5B;gNr8t;di4Yt1V;iety,ni4O;nAp2Zr9s 8;do42s5D;bani1in0;coordinat39der8;estima1to21we40; rex,aJeIhGiEoDrAu9v8;! show;m2Nn2rntKto1B;agedy,ib8o4D;e,u8;n0ta44;ni1p2rq3K;c,er,m8;etE;ing8ree25;!y;am,mp3E;ct2le6x return;aMcLeJhor4PiIkGoFpin off,tCuAy8;ll8ner7st4S;ab2W;b8i1n27per bowl,rro1W;st3Ktot0;at9ipe2Fo1Irate7udent8;! lo0H;i38u1;ft ser4Kmeo1F;elet5i8;ll,r3U;b37gn2Ste;ab2Ic8min3A;t,urity gua2M;e6ho2X;bbatic0la3Hndwi0Opi5;av5eChetor2i9o8;de6om,w;t9v8;erb2B;e,u0;bCcAf8publ2r0Xspi1;er8orm4;e6r0;i8ord label;p2Gt0;a1u45;estion mark,ot2E;aOeLhoKiHlFoDr9u8yram1E;ddi3GpDrpo1Is3I;eAo8;bl3Ys8;pe3Ita1;dic1Qmi1Ep1Proga3Uss relea1E;p8rt0;py;a8ebisci1;q2Cte;cn2e9g8;!gy;!r;ne call,tocoJ;anut,d9r8t0yo1;cen3Isp3J;al,est0;nop3r9t8;e,hog5;adi10i2U;atme0bj3EcApia1rde0thers,utspok5ve8wn4;n,r8;ti0Oview;cu9e8;an;pi4;arAit9ot8umb4;a2Dhi2Q;e,ra1;cot2ra36;aDeBi9o8ur0é0C;nopo3p17rni2Msq1Qti35uld;c,li10n08s8tt5;chief,si33;d8nu,t0;al,ic;gna1mm0nd15rsupi0te8yf3;ri0;aCegBiAu8;ddi1n8;ch;ght bulb,me,p09ving room; 9e0M;bor14y 8;up;eyno1itt5;el3ourn0;cAdices,itia2Oni26s9tel0Mvert8;eb1K;e29titu1;en2Li2U;aHeDighCo9u8;man right,s23;me8rmoEsp1Gtb0L;! r8;un; scho0ZriZ;a8i1O;d8v5; start,pho8;ne;ndful,sh brown,v5ze;aBelat0Jlaci4r9u8yp1T;l3y;an8enadi4id;a1Bd slam,ny;df3r8;l2ni1I;aGeti1HiFlu1oCr9un8;er0;ee market,i9on8;ti4;ga1;l3ur8;so8;me;eOref3;br2mi3n10;conoEffi7gg,lecto0Qmbas1DnBpidem2s1Yth2venAx9yel8;id;ampYempl0Mte6;i18t;er7terp8;ri8;se;my;eKiDoAr8ump tru0T;agonf3i8;er,ve thru;c9g7i3or,ssi4wn8;side;to0DumenD;aDgniCnn4s9vide8;nd;conte6incen1Dp8tri10;osi8;tion;ta0F;le0W;athAc9f8ni0terre6;ault 04err0;al,im0;!b8;ed;aVeShLiKlIoCr8;edit caAuc8;ib8;le;rd;efficCke,lBmmuniqKns9pi4rr0t0Wus8yo1;in;erv8uH;ato00;ic,lP;ie6;er7i8oth;e6n2;ty,vil wL;aCeqBick5ocoAr8;istmas car8ysanthemum;ol;la1;ue;ndeli4racteri8;st2;i9llDr8;e0tifica1;liY;hi4nEpDrBt8ucus;erpi8hedr0;ll8;ar;!bohyd8ri4;ra1;it0;a8e,nib0;l,ry;aMeLiop2leJoHrDu8;nBr8tterf3;g8i0;la8;ry;ny;eak9i8;ck;fa8throA;st;dy,ro8wl;ugh;mi8;sh;an,l3;nki9rri4;er;ng;cRdLlHnEppeti1rCsAtt2utop8;sy;ic;ce6pe8;ct;r8sen0;ay;ec9oma3ti9;ly;do1;i5l8;er7y;gy;en; hominCj9van8;tage;ec8;ti8;ve;em;cBe9qui8;tt0;ta1;te;i9ru0;al;de6;nt",
  "Person|Noun": "true¦a07b01cYdRePfOgMhJjFkiElDmBolive,p7r4s3trini00v1wa0;ng,rd;an,enus,iol0;a,et;ky,on5umm02;ay,e1o0uby;bin,d,se;ed,x;a2e0ol;aHn0;ny;ge,tM;a0eloR;x,ya;a9eo,iE;ng,tL;a2e1o0;lDy;an,w3;de,smi4y;a0iKol8;ll,z0;el;ail,e0;ne;aith,ern,lo;a0dDmir,ula,ve;rl;a4e3i1ol0;ly;ck,x0;ie;an,ja;i0wn;sy;h0liff,rystal;ari0in,ristian;ty;ak4e3i2r0;an0ook;dy;ll;nedict,rg;er;l0rt;fredo,ma",
  "Actor|Verb": "true¦aCb8c5doctor,engineAfool,g3host,judge,m2nerd,p1recruit,scout,ushAvolunteAwi0;mp,tneA;arent,ilot;an,ime;eek,oof,r0uide;adu8oom;ha1o0;ach,nscript,ok;mpion,uffeur;o2u0;lly,tch0;er;ss;ddi1ffili0rchite1;ate;ct",
  "MaleName": "true¦0:DO;1:CO;2:D7;3:AJ;4:CK;5:BZ;6:CF;7:D3;8:BS;9:AR;A:DB;B:D4;C:94;D:BM;aC9bB7cA7d98e8If82g7Fh6Si6Cj5Ek52l4Fm37n2Uo2Op2Gqu2Er1Ms12t0Gu0Fv08wUxTyJzE;aEor0;cEh9Jkaria,n0C;hFkE;!aC7;ar5UeC6;aMoGuE;sEu2LvBJ;if,uf;nGsFusE;ouf,sE;ef;aEg;s,tE;an,h0;hli,nB8ssY;avi3ho4;aNeLiGoEyaBN;jcie87lfgang,odrow,utE;!er;lEnst1;bGey,fredAlE;aAZiE;am,e,s;e97ur;i,nde9sE;!l8t1;lFyE;l1ne;lEt3;a9Xy;aHiEladimir,ojte7U;cFha0kt67nceErgA5va0;!nt;e3Xt65;lentEn9S;inE;!e;ghBElyss59nax,sm0;aXeShOiMoIrGuFyE;!l3ro6s1;n7r59;avAHeEist0oy,um0;ntA9v5Wy;bGd8RmEny;!as,mEoharu;aCCie,y;iCy;mEt5;!my,othy;adGeoFia0KomE;!as;!do8G;!de5;dHrE;en98rE;an97eEy;ll,n96;!dy;dgh,ha,iEnn3req,tsu4R;cAPka;aUcotSeQhMiKoIpenc3tEur1Xylve96zym1;anGeEua85;f0phBCvEwa84;e5Zie;!islaw,l8;lom1uE;leyma6ta;dElCm1yabonga;!dhart74n8;aGeE;lErm0;d1t1;h7Kne,qu11un,wn,y6;aEbasti0k2Cl4Prg4Mth,ymoAE;m5n;!tE;!ie,y;lFmEnti2Gq58ul;!ke5JmDu4;ik,vato7O;aZeVhe9ViRoIuFyE;an,ou;b7DdFf5pe7KssE;!elBJ;ol3Fy;an,bLc62dJel,geIh0landAmHnGry,sFyE;!ce;coe,s;!aA1nD;an,eo;l45r;er78g3n8olfo,riE;go;bDeAQ;cEl8;ar6Ic6HhFkEo;!ey,ie,y;a8Vie;gFid,ubByEza;an1KnZ;g9SiE;na9Os;ch6Qfa4lImHndGpha4sFul,wi2HyE;an,mo6U;h7Jm5;alAXol2U;iACon;f,ph;ent2inE;cy,t1;aJeHhilGier6TrE;aka18eE;m,st1;!ip,lip;dA4rcy,tE;ar,e3Er1Y;b4Hdra73tr6JulE;!o19;ctav3Di3liv3m9Yndrej,rIsFtEum7wB;is,to;aFc7k7m0vE;al5S;ma;i,vM;aMeKiGoEu38;aEel,j5l0ma0r3I;h,m;cFg4i46kEl2R;!au,h7Gola;hEkEolC;olC;al,d,il,ls1vE;il8J;hom,tE;e,hE;anEy;!a4i4;a00eXiNoIuFyE;l2Gr1;hamFr6KstaE;fa,p54;ed,mI;di0Xe,hamGis2CntFsEussa;es,he;e,y;ad,ed,mE;ad,ed;cJgu4hai,kHlGnFtchE;!e9;a7Uik;house,o0Ct1;ae5Oe9NolE;aj;ah,hE;aFeE;al,l;el,l;hFlv2rE;le,ri9v2;di,met;ay0hUjd,ks2AlSmadXnRrLs1tGuricFxE;imilianAwe9;e,io;eHhFiCtEus,yC;!eo,hew,ia;eEis;us,w;j,o;cIio,kHlGqu6Ysha9tEv2;iEy;!m,n;in,on;el,oQus;!el91oPus;iHu4;achEcolm,ik;ai,y;amFdi,eEmoud;sh;adEm5G;ou;aXeRiPlo39oLuFyE;le,nd1;cHiGkEth3uk;aEe;!s;gi,s,z;as,iaE;no;g0nn7BrenGuEv81we9;!iE;e,s;!zo;am,oE;n4r;a7Uevi,la4AnIonHst3thaGvE;eEi;nte;bo;!a6Del;!ny;mFnd1rEur54wr54;ry,s;ar,o4Y;aMeIhal7GiFristEu4Ky6J;i0o54;er0p,rE;k,ollE;os;en0iGnErmit,v3U;!dr3XnEt1;e18y;r,th;cp3j5m5Sna6OrFsp7them,uE;ri;im,l;a01eViToHuE;an,lEst2;en,iE;an,en,o,us;aOeMhnLkubCnJrHsE;eFhEi7Wue;!ua;!ph;dEge;i,on;!aEny;h,s,th55;!ath54ie,nD;!l,sEy;ph;o,qu2;an,mE;!mD;d,ffHrEs5;a5YemFmai6oEry;me,ni0Y;i7Gy;!e5OrE;ey,y;cLdBkJmIrGsFvi3yE;dBs1;on,p3;ed,od,rEv4V;e5Bod;al,es4Mis1;a,e,oEub;b,v;ob,quE;es;aXbRchiQgOkeNlija,nuMonut,rKsGtEv0;ai,suE;ki;aFha0i70maEsac;el,il;ac,iaE;h,s;a,vinEw2;!g;k,nngu5F;!r;nacEor;io;ka;ai,rahE;im;aQeKoJuEyd7;be2FgHmber4KsE;eyFsE;a2e2;in,n;h,o;m3ra36sse2wa40;aIctHitHnrFrE;be28m0;iEy;!q0Z;or;th;bMlLmza,nKo,rGsFyE;a47dB;an,s0;lGo4Nry,uEv8;hi44ki,tE;a,o;an,ey;k,s;!im;ib;aWeSiQlenPoMrIuE;ilFsE;!tavo;herme,lerE;mo;aGegEov3;!g,orE;io,y;dy,h5K;nzaFrE;an,d1;lo;!n;lbe4Xno,oE;rg37van4Y;oGrE;aEry;ld,rdA;ffr8rge;brFlBrEv2;la14r3Hth,y;e33ielE;!i5;aSePiNlLorrest,rE;anFedEitz;!dDer11r11;cGkE;ie,lE;in,yn;esLisE;!co,z2W;etch3oE;yd;d4lEonn;ip;deriFliEng,rnan05;pe,x;co;bi0di,hd;dYfrXit0lSmLnIo2rGsteb0th0uge6vEymBzra;an,eE;ns,re2X;gi,i0AnErol,v2w2;estAie;oFriqEzo;ue;ch;aJerIiFmE;aIe2Q;lErh0;!iE;o,s;s1y;nu4;be0Bd1iGliFm3t1viEwood;n,s;ot1Ss;!as,j4FsE;ha;a2en;!d2Vg7mHoFuFwE;a26in;arE;do;oWuW;a02eRiPoHrag0uGwFylE;an,l0;ay6ight;a6dl8nc0st2;minHnFri0ugEvydCy29;!lC;!a2HnEov0;e9ie,y;go,iFykC;as;cEk;!k;armuEll1on,rk;id;andNj0lbeMmetri5nKon,rIsGvFwExt3;ay6ey;en,in;hawn,moE;nd;ek,rE;ick;is,nE;is,y;rt;re;an,le,mLnKrGvE;e,iE;!d;en,iGne9rEyl;eEin,yl;l36n;n,o,us;!i4ny;iEon;an,en,on;a08e06hYiar0lOoJrHuFyrE;il,us;rtE;!is;aEistob0S;ig;dy,lHnFrE;ey,neli5y;or,rE;ad;by,e,in,l2t1;aIeGiEyK;fEnt;fo0Et1;meEt5;nt;rGuFyE;!t1;de;enE;ce;aIeGrisE;!toE;ph3;st3;er;d,rEs;b4leE;s,y;cEdric,s7;il;lHmer1rE;ey,lFro9y;ll;!os,t1;eb,v2;a07eZiVlaUoSrFuEyr1;ddy,rtL;aMeHiGuFyE;an,ce,on;ce,no;an,ce;nFtE;!t;dFtE;!on;an,on;dFndE;en,on;!foEl8y;rd;bby,rEyd;is;i6ke;bGlFshE;al;al,lD;ek;nIrEshoi;at,nFtE;!r1C;aEie;rdA;!iFjam2nD;ie,y;to;kaNlazs,nIrE;n8rEt;eEy;tt;ey;dEeF;ar,iE;le;ar17b0Vd0Rf0Pgust2hm0Mi0Jja0Il03mZnSputsiRrIsaHugust5veFyEziz;a0kh0;ry;us;hi;aLchKiJjun,maInGon,tEy0;hEu09;ur;av,oE;ld;an,ndA;!el,ki;ie;ta;aq;as,dIgelAtE;hony,oE;i6nE;!iAy;ne;er,reEy;!as,i,s,w;iGmaEos;nu4r;el;ne,r,t;aRbeQdBeKfIi,lHonGphZt1vE;aOin;on;so,zo;an,en;onVrE;ed;c,jaHksandGssaHxE;!andE;er,ru;ar,er;ndE;ro;rtA;dd2n;ni;dBm7;ar;en;ad,eE;d,t;in;onE;so;aFi,olfAri0vik;!o;mEn;!a;dIeHraFuE;!bakr,lfazl;hEm;am;!l;allJelGoulaye,ulE;!lErG;ah,o;! rE;ahm0;an;ah;av,on",
  "Uncountable": "true¦0:2Z;1:2F;2:2M;3:34;4:3D;a2Xb2Oc2Cd25e1Uf1Qg1Hh19i14j11k0Zl0Um0Kn0Go0Fp06r02sNtBuran2Mv9w5you gu0H;a7his1Ai6oo5;d,l;ldlife,ne;rmAt2;apor,ernacul2Ci5;neg2Bol1Rtae;eFhDiCoAr6un5yranny;a,gst1E;aff2Rea1No6ue nor5;th;o0Bu5;bleshoot0se1Wt;night,othpas1Ywn5;foGsfoG;me off,n;er5und2;e,mod2V;a,nnis;aGcFeEhCiBkiAo9p8t6u5weepstak1;g1Xnshi2Kshi;ati0Be5;am,el;ace2Neci1;ap,cc2meth0;n,ttl1;lk;eep,ingl1o5;pp0r1E;lf,na1Iri1;ene1Misso1E;d0Yfe3l6nd,t5;i0Kurn;m1Wt;abi1e6ic5;e,ke17;c5i03laxa13search;ogni12rea12;aBeAhys9luto,o7re5ut3;amble,mis1s5ten22;en21s0N;l5rk;i2Al0GyJ; 18i4;a26tr0H;nt5rk0ti0O;i1s;bstetri4vercrowd0xyg0B;a7e6owada5utella;ys;ptu1Qws;il poli01tional securi3;aCeAo7u5;m5s1J;ps;n5o1M;ey,o5;gamy;a5cha0Glancholy,rchandi1Jtallurgy;sl1t;chine5g1Cj1Jrs,thema1S; learn0ry;aught2e8i7ogi6u5;ck,g14;c,s1O;ce,ghtn0nguis1NteratYv2;ath2isXss;ara0GindergartRn5;icke0Cowled10;e5upit2;a5llyfiIwel0I;ns;ce,gnor8mp7n5;forma02ter5;net,sta09;atiUort5rov;an1A;a9e8isto0Bo5ung2;ckey,mework,ne6o5rseradiAspitali3use arrest;ky;s3y;adquarteZre;ir,libut,ppiJs5;hi5te;sh;eneAl8o7r5um,ymnas13;a5e01;niWss;lf,re;ut5yce0H;en; 5ti4;edit0po5;ol;aPeel0icHlour,o6urnit5;ure;od,rgive5uri2wl;ness;arEcono0NducaDlectrBn9quipAthi4very8x5;ist6per5;ti0D;en0L;body,o0Ath0;joy5tertain5;ment;ici3o5;ni4;tiU;nings,th;emi04i8o6raugh5ynas3;ts;pe,wnstai5;rs;abet1ce,s5;hon01repu5;te;aFelciEhCivi4lAo5urrency;al,ld w8mmenta7n5ral,ttKuscoD;fusiJt 5;ed;ry;ar;assi4oth1;es;aos,e5;eOw0;us;d,rQ;aAi8lood,owl0read7u5;nt0tt2;er;!th;lliarLs5;on;g5ss;ga5;ge;cMdviLeroIirHmDn8ppeal court,r6spi5thleN;rin;ithmet5sen5;ic;i8y5;o6th0;ing;ne;se;en7n5;es3;ty;ds;craft;bi4d5nau9;yna5;mi4;ce;id,ous5;ti4;cs",
  "Infinitive": "true¦0:9G;1:9T;2:AD;3:90;4:9Z;5:84;6:AH;7:A9;8:92;9:A0;A:AG;B:AI;C:9V;D:8R;E:8O;F:97;G:6H;H:7D;a94b8Hc7Jd68e4Zf4Mg4Gh4Ai3Qj3Nk3Kl3Bm34nou48o2Vp2Equ2Dr1Es0CtZuTvRwI;aOeNiLors5rI;eJiI;ng,te;ak,st3;d5e8TthI;draw,er;a2d,ep;i2ke,nIrn;d1t;aIie;liADniAry;nJpI;ho8Llift;cov1dJear8Hfound8DlIplug,rav82tie,ve94;eaAo3X;erIo;cut,go,staAFvalA3w2G;aSeQhNoMrIu73;aIe72;ffi3Smp3nsI;aBfo7CpI;i8oD;pp3ugh5;aJiJrIwaD;eat5i2;nk;aImA0;ch,se;ck3ilor,keImp1r8L;! paD;a0Ic0He0Fh0Bi0Al08mugg3n07o05p02qu01tUuLwI;aJeeIim;p,t5;ll7Wy;bNccMffLggeCmmKppJrI;mouFpa6Zvi2;o0re6Y;ari0on;er,i4;e7Numb;li9KmJsiIveD;de,st;er9it;aMe8MiKrI;ang3eIi2;ng27w;fIng;f5le;b,gg1rI;t3ve;a4AiA;a4UeJit,l7DoI;il,of;ak,nd;lIot7Kw;icEve;atGeak,i0O;aIi6;m,y;ft,ng,t;aKi6CoJriIun;nk,v6Q;ot,rt5;ke,rp5tt1;eIll,nd,que8Gv1w;!k,m;aven9ul8W;dd5tis1Iy;a0FeKiJoI;am,t,ut;d,p5;a0Ab08c06d05f01group,hea00iZjoi4lXmWnVpTq3MsOtMup,vI;amp,eJiIo3B;sEve;l,rI;e,t;i8rI;ie2ofE;eLiKpo8PtIurfa4;o24rI;aHiBuctu8;de,gn,st;mb3nt;el,hra0lIreseF;a4e71;d1ew,o07;aHe3Fo2;a7eFiIo6Jy;e2nq41ve;mbur0nf38;r0t;inKleBocus,rJuI;el,rbiA;aBeA;an4e;aBu4;ei2k8Bla43oIyc3;gni39nci3up,v1;oot,uI;ff;ct,d,liIp;se,ze;tt3viA;aAenGit,o7;aWerUinpoiFlumm1LoTrLuI;b47ke,niArIt;poDsuI;aFe;eMoI;cKd,fe4XhibEmo7noJpo0sp1tru6vI;e,i6o5L;un4;la3Nu8;aGclu6dJf1occupy,sup0JvI;a6BeF;etermi4TiB;aGllu7rtr5Ksse4Q;cei2fo4NiAmea7plex,sIva6;eve8iCua6;mp1rItrol,ve;a6It6E;bOccuNmEpMutLverIwe;l07sJtu6Yu0wI;helm;ee,h1F;gr5Cnu2Cpa4;era7i4Ipo0;py,r;ey,seItaH;r2ss;aMe0ViJoIultiply;leCu6Pw;micJnIspla4;ce,g3us;!k;iIke,na9;m,ntaH;aPeLiIo0u3N;e,ke,ng1quIv5;eIi6S;fy;aKnIss5;d,gI;th5;rn,ve;ng2Gu1N;eep,idnJnI;e4Cow;ap;oHuI;gg3xtaI;po0;gno8mVnIrk;cTdRfQgeChPitia7ju8q1CsNtKun6EvI;a6eIo11;nt,rt,st;erJimi6BoxiPrI;odu4u6;aBn,pr03ru6C;iCpi8tIu8;all,il,ruB;abEibE;eCo3Eu0;iIul9;ca7;i7lu6;b5Xmer0pI;aLer4Uin9ly,oJrI;e3Ais6Bo2;rt,se,veI;riA;le,rt;aLeKiIoiCuD;de,jaInd1;ck;ar,iT;mp1ng,pp5raIve;ng5Mss;ath1et,iMle27oLrI;aJeIow;et;b,pp3ze;!ve5A;gg3ve;aTer45i5RlSorMrJuI;lf4Cndrai0r48;eJiIolic;ght5;e0Qsh5;b3XeLfeEgJsI;a3Dee;eIi2;!t;clo0go,shIwa4Z;ad3F;att1ee,i36;lt1st5;a0OdEl0Mm0FnXquip,rWsVtGvTxI;aRcPeDhOiNpJtIu6;ing0Yol;eKi8lIo0un9;aHoI;it,re;ct,di7l;st,t;a3oDu3B;e30lI;a10u6;lt,mi28;alua7oI;ke,l2;chew,pou0tab19;a0u4U;aYcVdTfSgQhan4joy,lPqOrNsuMtKvI;e0YisI;a9i50;er,i4rI;aHenGuC;e,re;iGol0F;ui8;ar9iC;a9eIra2ulf;nd1;or4;ang1oIu8;r0w;irc3lo0ou0ErJuI;mb1;oaGy4D;b3ct;bKer9pI;hasiIow1;ze;aKody,rI;a4oiI;d1l;lm,rk;ap0eBuI;ci40de;rIt;ma0Rn;a0Re04iKo,rIwind3;aw,ed9oI;wn;agno0e,ff1g,mi2Kne,sLvI;eIul9;rIst;ge,t;aWbVcQlod9mant3pNru3TsMtI;iIoDu37;lJngI;uiA;!l;ol2ua6;eJlIo0ro2;a4ea0;n0r0;a2Xe36lKoIu0S;uIv1;ra9;aIo0;im;a3Kur0;b3rm;af5b01cVduBep5fUliTmQnOpMrLsiCtaGvI;eIol2;lop;ch;a20i2;aDiBloIoD;re,y;oIy;te,un4;eJoI;liA;an;mEv1;a4i0Ao06raud,y;ei2iMla8oKrI;ee,yI;!pt;de,mIup3;missi34po0;de,ma7ph1;aJrief,uI;g,nk;rk;mp5rk5uF;a0Dea0h0Ai09l08oKrIurta1G;a2ea7ipp3uI;mb3;ales4e04habEinci6ll03m00nIrro6;cXdUfQju8no7qu1sLtKvI;eIin4;ne,r9y;aHin2Bribu7;er2iLoli2Epi8tJuI;lt,me;itu7raH;in;d1st;eKiJoIroFu0;rm;de,gu8rm;ss;eJoI;ne;mn,n0;eIlu6ur;al,i2;buCe,men4pI;eIi3ly;l,te;eBi6u6;r4xiC;ean0iT;rcumveFte;eJirp,oI;o0p;riAw;ncIre5t1ulk;el;a02eSi6lQoPrKuI;iXrIy;st,y;aLeaKiJoad5;en;ng;stfeLtX;ke;il,l11mba0WrrMth1;eIow;ed;!coQfrie1LgPhMliLqueaKstJtrIwild1;ay;ow;th;e2tt3;a2eJoI;ld;ad;!in,ui3;me;bysEckfi8ff3tI;he;b15c0Rd0Iff0Ggree,l0Cm09n03ppZrXsQttOuMvJwaE;it;eDoI;id;rt;gIto0X;meF;aIeCraB;ch,in;pi8sJtoI;niA;aKeIi04u8;mb3rt,ss;le;il;re;g0Hi0ou0rI;an9i2;eaKly,oiFrI;ai0o2;nt;r,se;aMi0GnJtI;icipa7;eJoIul;un4y;al;ly0;aJu0;se;lga08ze;iKlI;e9oIu6;t,w;gn;ix,oI;rd;a03jNmiKoJsoI;rb;pt,rn;niIt;st1;er;ouJuC;st;rn;cLhie2knowled9quiItiva7;es4re;ce;ge;eQliOoKrJusI;e,tom;ue;mIst;moJpI;any,liA;da7;ma7;te;pt;andPduBet,i6oKsI;coKol2;ve;liArt,uI;nd;sh;de;ct;on",
  "Adjective": "true¦0:AI;1:BS;2:BI;3:BA;4:A8;5:84;6:AV;7:AN;8:AF;9:7H;A:BQ;B:AY;C:BC;D:BH;E:9Y;aA2b9Ec8Fd7We79f6Ng6Dh60i4Wj4Vk4Sl4Hm40n3Oo35p2Nquart7Pr2Cs1Dt14uSvOwFye28;aMeKhIiHoF;man5oFrth7G;dADzy;despreB1n w97s86;acked1HoleF;!sa6;ather1QeFll o70ste1D;!k5;nt1Jst6Ate4;aHeGiFola5S;bBUce versa,gi3Kle;ng67rsa5Q;ca1gBSluAV;lt0PnLpHrGsFttermoBL;ef9Ku3;b96ge1; Hb31pGsFtiAH;ca6et,ide d4Q;er,i85;f51to da2;a0Fbeco0Hc0Bd04e02f01gu1WheaBGiXkn4NmUnTopp06pRrNsJtHus0wF;aFiel3J;nt0rra0P;app0eXoF;ld,uS;eHi36o59pGuF;perv06spec38;e1ok9O;en,ttl0;eFu5;cogn06gul2QlGqu84sF;erv0olv0;at0en32;aFrecede0E;id,rallel0;am0otic0;aFet;rri0tF;ch0;nFq25vers3;sur0terFv7U;eFrupt0;st0;air,inish0orese98;mploy0n7Ov97xpF;ect0lain0;eHisFocume01ue;clFput0;os0;cid0rF;!a8Scov9ha8Jlyi8nea8Gprivileg0sMwF;aFei9I;t9y;hGircumcFonvin2T;is0;aFeck0;lleng0rt0;b1Zppea85ssuGttend0uthorF;iz0;mi8;i49ra;aLeIhoHip 24oGrF;anspare1encha1i2;geth9leADp notch,rpB;rny,ugh6H;ena8DmpGrFs6U;r48tia4;eCo8P;leFst4M;nt0;a0Cc08e06h05i03ki02l00mug,nobbi4XoWpSqueami4XtKuFymb94;bHccinAi generis,pFr5;erFre7N;! dup9b,vi70;du0li7Lp6IsFurb7J;eq9Atanda9X;aLeKi15o2PrGubboFy4Q;rn;aightGin5GungF; o2M; fFfF;or7U;adfa9Ori6;lwa6Etu81;arHeGir6MlendBot Fry;on;c3Oe1Q;k5se; call0lub6mb9phistic14rHuFviT;ndFth19;proof;dBry;e61ipF;pe4shod;ll0n d7S;g2HnF;ceEg6ist9;am3Te9;co1Zem5lfFn6Bre7; suf4Yi44;aGholFient3A;ar5;rlFt4B;et;cr0me,tisfac7G;aOeIheumatoBiGoF;bu90tt7Hy3;ghtFv3;-1Sf6Y;cJdu8QlInown0pro6AsGtF;ard0;is48oF;lu2na1;e1Suc46;alcit8Ye1ondi2;bBci3mpa1;aSePicayu7laOoNrGuF;bl7Unjabi,z36;eKiIoF;b7WfGmi4ApFxi2M;er,ort82;a7uD;maFor,sti7va2;!ry;ciDexis0Ima2CpaB;in56puli8H;cBid;ac2Znt 3JrFti2;ma41tFv7X;!i40;i2ZrFss7S;anoBtF;-5YiF;al,s5W;bSffQkPld OnMrLth9utKverF;!aIbMdHhGni76seas,t,wF;ei75rou75;a64e7B;ue;ll;do1Ger,si6B;d3Rg2Aotu60; bFbFe on o7g3Vli7;oa81;fashion0school;!ay; gua7YbFha5Vli7;eat;eHligGsF;ce7er0So1C;at0;diFse;a1e1;aOeNiMoGuF;anc0de; moEnHrthFt6W;!eFwe7M;a7Lrn;chaGdescri7Jprof31sF;top;la1;ght5;arby,cessa4ighbor5wlyw0xt;k0usiaFv3;ti8;aQeNiLoHuF;dIltiF;facet0p6;deHlGnFot,rbBst;ochro4Yth5;dy;rn,st;ddle ag0nF;dbloZi,or;ag9diocEga,naGrFtropolit4R;e,ry;ci8;cIgenta,inHj0Fkeshift,mmGnFri4Pscu62ver18;da5Ey;ali4Mo4V;!stream;abEho;aOeLiIoFumberi8;ngFuti1S;stan3StF;erm,i4I;ghtGteraF;l,ry,te;heart0wei5P;ft-JgFss9th3;al,eFi0M;nda4;nguBps0te5;apGind5noF;wi8;ut;ad0itte4uniW;ce co0Hgno6Nll0Cm04nHpso 2VrF;a2releF;va1; ZaYcoWdReQfOgrNhibi4Si05nMoLsHtFvalu5N;aAeF;nDrdepe2L;a7iGolFuboI;ub6ve1;de,gF;nifica1;rdi5O;a2er;own;eriIiLluenVrF;ar0eq5I;pt,rt;eHiGoFul1P;or;e,reA;fiFpe27termi5F;ni2;mpFnsideCrreA;le2;ccuCdeq5Fne,ppr4K;fFsitu,vitro;ro1;mJpF;arHeGl16oFrop9;li2r12;n2MrfeA;ti3;aGeFi19;d4CnD;tuE;egGiF;c0ZteC;al,iF;tiF;ma2;ld;aOelNiLoFuma7;a4meInHrrGsFur5;ti6;if4F;e59o3V; ma3HsF;ick;ghfalut2IspF;an4A;li01pf34;i4llow0ndGrdFtN; 06coEworki8;sy,y;aMener45iga3Clob3oLrGuF;il1Ong ho;aGea1GizF;zl0;cGtF;ef2Vis;ef2U;ld3Aod;iFuc2D;nf2R;aVeSiQlOoJrF;aGeFil5ug3;q43tf2O;gFnt3S;i6ra1;lk13oHrF; keeps,eFge0Vm9tu41;g0Ei2Ds3R;liF;sh;ag4Mowe4uF;e1or45;e4nF;al,i2;d Gmini7rF;ti6ve1;up;bl0lDmIr Fst pac0ux;oGreacF;hi8;ff;ed,ili0R;aXfVlTmQnOqu3rMthere3veryday,xF;aApIquisi2traHuF;be48lF;ta1;!va2L;edRlF;icF;it;eAstF;whi6; Famor0ough,tiE;rou2sui2;erGiF;ne1;ge1;dFe2Aoq34;er5;ficF;ie1;g9sF;t,ygF;oi8;er;aWeMiHoGrFue;ea4owY;ci6mina1ne,r31ti8ubQ;dact2Jfficult,m,sGverF;ge1se;creGePjoi1paCtF;a1inA;et,te; Nadp0WceMfiLgeneCliJmuEpeIreliAsGvoF;id,ut;pFtitu2ul1L;eCoF;nde1;ca2ghF;tf13;a1ni2;as0;facto;i5ngero0I;ar0Ce09h07i06l05oOrIuF;rmudgeon5stoma4teF;sy;ly;aIeHu1EystalF; cleFli7;ar;epy;fFv17z0;ty;erUgTloSmPnGrpoCunterclVveFy;rt;cLdJgr21jIsHtrF;aFi2;dic0Yry;eq1Yta1;oi1ug3;escenFuN;di8;a1QeFiD;it0;atoDmensuCpF;ass1SulF;so4;ni3ss3;e1niza1;ci1J;ockwiD;rcumspeAvil;eFintzy;e4wy;leGrtaF;in;ba2;diac,ef00;a00ePiLliJoGrFuck nak0;and new,isk,on22;gGldface,naF; fi05fi05;us;nd,tF;he;gGpartisFzarE;an;tiF;me;autifOhiNlLnHsFyoN;iWtselF;li8;eGiFt;gn;aFfi03;th;at0oF;v0w;nd;ul;ckwards,rF;e,rT; priori,b13c0Zd0Tf0Ng0Ihe0Hl09mp6nt06pZrTsQttracti0MuLvIwF;aGkF;wa1B;ke,re;ant garGeraF;ge;de;diIsteEtF;heFoimmu7;nt07;re;to4;hGlFtu2;eep;en;bitIchiv3roHtF;ifiFsy;ci3;ga1;ra4;ry;pFt;aHetizi8rF;oprF;ia2;llFre1;ed,i8;ng;iquFsy;at0e;ed;cohKiJkaHl,oGriFterX;ght;ne,of;li7;ne;ke,ve;olF;ic;ad;ain07gressiIi6rF;eeF;ab6;le;ve;fGraB;id;ectGlF;ue1;ioF;na2; JaIeGvF;erD;pt,qF;ua2;ma1;hoc,infinitum;cuCquiGtu3u2;al;esce1;ra2;erSjeAlPoNrKsGuF;nda1;e1olu2trF;aAuD;se;te;eaGuF;pt;st;aFve;rd;aFe;ze;ct;ra1;nt",
  "Pronoun": "true¦'em,elle,h3i2me,she4th0us,we,you;e0ou;e,m,y;!l,t;e0im;!'s",
  "Preposition": "true¦-,aPbMcLdKexcept,fIinGmid,notwithstandiWoDpXqua,sCt7u4v2w0;/o,hereSith0;! whHin,oW;ersus,i0;a,s-a-vis;n1p0;!on;like,til;h1ill,oward0;!s;an,ereby,r0;ough0u;!oM;ans,ince,o that,uch G;f1n0ut;!to;!f;! 0to;effect,part;or,r0;om;espite,own,u3;hez,irca;ar1e0oBy;sides,tween;ri7;bo8cross,ft7lo6m4propos,round,s1t0;!op;! 0;a whole,long 0;as;id0ong0;!st;ng;er;ut",
  "SportsTeam": "true¦0:1A;1:1H;2:1G;a1Eb16c0Td0Kfc dallas,g0Ihouston 0Hindiana0Gjacksonville jagua0k0El0Bm01newToQpJqueens parkIreal salt lake,sAt5utah jazz,vancouver whitecaps,w3yW;ashington 3est ham0Rh10;natio1Oredski2wizar0W;ampa bay 6e5o3;ronto 3ttenham hotspur;blue ja0Mrapto0;nnessee tita2xasC;buccanee0ra0K;a7eattle 5heffield0Kporting kansas0Wt3;. louis 3oke0V;c1Frams;marine0s3;eah15ounG;cramento Rn 3;antonio spu0diego 3francisco gJjose earthquak1;char08paA; ran07;a8h5ittsburgh 4ortland t3;imbe0rail blaze0;pirat1steele0;il3oenix su2;adelphia 3li1;eagl1philNunE;dr1;akland 3klahoma city thunder,rlando magic;athle0Mrai3;de0; 3castle01;england 7orleans 6york 3;city fc,g4je0FknXme0Fred bul0Yy3;anke1;ian0D;pelica2sain0C;patrio0Brevolut3;ion;anchester Be9i3ontreal impact;ami 7lwaukee b6nnesota 3;t4u0Fvi3;kings;imberwolv1wi2;rewe0uc0K;dolphi2heat,marli2;mphis grizz3ts;li1;cXu08;a4eicesterVos angeles 3;clippe0dodDla9; galaxy,ke0;ansas city 3nE;chiefs,roya0E; pace0polis colU;astr06dynamo,rockeTtexa2;olden state warrio0reen bay pac3;ke0;.c.Aallas 7e3i05od5;nver 5troit 3;lio2pisto2ti3;ge0;broncZnuggeM;cowbo4maver3;ic00;ys; uQ;arCelKh8incinnati 6leveland 5ol3;orado r3umbus crew sc;api5ocki1;brow2cavalie0india2;bengaWre3;ds;arlotte horAicago 3;b4cubs,fire,wh3;iteB;ea0ulR;diff3olina panthe0; c3;ity;altimore 9lackburn rove0oston 5rooklyn 3uffalo bilN;ne3;ts;cel4red3; sox;tics;rs;oriol1rave2;rizona Ast8tlanta 3;brav1falco2h4u3;nited;aw9;ns;es;on villa,r3;os;c5di3;amondbac3;ks;ardi3;na3;ls",
  "Unit": "true¦a09b06cZdYexXfTgRhePin00joule0DkMlJmDnan0AoCp9quart0Dsq ft,t7volts,w6y2ze3°1µ0;g,s;c,f,n;dXear1o0;ttT; 0s 0;old;att06b;erPon0;!ne04;ascals,e1i0;cZnt02;rcent,tL;hms,uI;/s,e4i0m²,²,³;/h,cro2l0;e0liM;!²;grNsT;gEtL;it1u0;menSx;erRreR;b5elvins,ilo1m0notQ;/h,ph,²;!byIgrGmEs;ct0rtzN;aLogrE;allonLb0ig5rD;ps;a2emtGl0t6; oz,uid ou0;nceH;hrenheit,radG;aby9;eci3m1;aratDe1m0oulombD;²,³;lsius,nti0;gr2lit1m0;et0;er8;am7;b1y0;te5;l,ps;c2tt0;os0;econd1;re0;!s",
  "PhrasalVerb": "true¦0:92;1:96;2:8H;3:8V;4:8A;5:83;6:85;7:98;8:90;9:8G;A:8X;B:8R;C:8U;D:8S;E:70;F:97;G:8Y;H:81;I:7H;J:79;K:4G;a9Gb7Vc6Sd6Me6Kf5Ig51h4Ciron0j48k41l3Fm32n2Zo2Xp2Dquiet Hr1Ys0Lt00uYvacuu6RwOyammerBzL;ero Dip MonL;e0k0;by,ov9up;aReNhMiLor0Nrit1A;mp0n3Gpe0r5s5;ackAeel Di0T;aMiLn34;gh 3Xrd0;n Dr L;do1in,oJ;it 7Ak5lk Mrm 6Ash Lt84v60;aw3do1o7up;aw3in,oC;rgeBsL;e 2herE;a01eZhWiSoRrNuLypQ;ckErn L;do1in,oJup;aMiLot0y 31;ckl80p F;ck HdL;e 5Z;n7Xp 3Fs5K;ck NdMe Lghten 6me0p o0Sre0;aw3ba4do1in,up;e Iy 2;by,oG;ink Mrow L;aw3ba4in,up;ba4ov9up;aLe 78ll63;m 2r 5N;ckBke Mlk L;ov9shit,u48;aLba4do1in,leave,o66up;ba4ft9pa6Aw3;a0Wc0Ue0Nh0Ji0Gl0Am09n08o07p02quar5HtRuPwL;earNiL;ngMtch L;aw3ba4o8L; by;cLi6Cm 2ss0;k 65;aSeRiQoOrLud36;aigh2Eet76iL;ke 7Tng L;al6Zup;p Lrm2G;by,in,oG;cKnKr 2tc4O;p F;cKmp0nd MrLveAy 2P;e Ht 2M;ba4do1up;arKeOiNlMrLurB;ead0ingBuc5;a49it 6I;c5ll o3Dn 2;ak Fe1Yll0;aKber 2rt0und like;ap 5Wow Duggl5;ash 6Ooke0;eep OiLow 6;cMp L;o6Eup;e 69;in,oL;ff,v9;de1Agn 4OnLt 6Hz5;gLkE; al6Ble0;aNoLu5X;ot Lut0w 7N;aw3ba4f48oC;cKdeEk6FveA;e Qll1Ond Prv5tL; Ltl5K;do1foMin,o7upL;!on;ot,r60;aw3ba4do1in,o4Wup;oCto;al67out0rL;ap66ew 6K;ilAv5;aYeViToPuL;b 5Zle0n Lstl5;aMba4do1inLo2Jth4Ou5Q;!to;c2Xr8w3;ll Not MpeAuL;g3Ind18;a2Wf3Po7;ar8in,o7up;ng 69p oLs5;ff,p19;aLelAinEnt0;c6Id L;o3Oup;cKt0;a00eZiXlUoRrPsyc35uL;ll Nn5Lt L;aLba4do1in,oJto48up;pa4Ew3;a3Kdo1in,o22to46up;attleBess LiOop 2;ah2Fon;iMp Lr50u1Hwer 6O;do1in,o6Oup;nt0;aMuL;gEmp 6;ce u21y 6E;ck Lg0le 4Bn 6p5C;oJup;el 5OncilE;c54ir 3An0ss NtMy L;ba4oG; Hc2R;aw3ba4in,oJ;pLw4Z;e4Yt D;aMerd0oL;dAt54;il Hrrow H;aUeRiQoMuL;ddl5ll I;cKnkeyNp 6uthAve L;aLdo1in,o4Mup;l4Ow3; wi4L;ss0x 2;asur5e3TlMss L;a21up;t 6;ke Mn 6rLs2Ax0;k 6ryA;do,fun,oCsure,up;a03eWiRoMuL;ck0st I;aOc4Gg NoLse0;k Lse4E;aft9ba4do1forw38in57o10u47;in,oJ;d 6;e OghtNnMsLve 01;ten F;e 2k 2; 2e47;ar8do1in;aNt MvelL; oC;do1go,in,o7up;nEve L;in,oL;pLut;en;c5p 2sh MtchBughAy L;do1o5A;in4Qo7;eNick Mnock L;do1oCup;oCup;eMy L;in,up;l Ip L;aw3ba4do1f05in,oJto,up;aNoMuL;ic5mpE;ke3Tt H;c44zz 2;a02eXiUoQuL;nMrrLsh 6;y 2;keMt L;ar8do1;r H;lLneErse3L;d Le 2;ba4dLfast,o25up;ear,o1;de Mt L;ba4on,up;aw3o7;aLlp0;d Nl Ir Lt 2;fLof;rom;f11in,o1WuX;cKm 2nMsh0ve Lz2Q;at,it,to;d Mg LkerQ;do1in,o2Uup;do1in,oL;ut,v9;k 2;aZeUive Sloss IoNrMunL; f0S;ab hold,in44ow 2V; Lof 2J;aNb1Nit,oMr8th1JuL;nd9;ff,n,v9;bo7ft9hQw3;aw3bLdo1in,oJrise,up,w3;a4ir2I;ar 6ek0t L;aLb1Gdo1in,o1Dr8up;cMhLl2Hr8t,w3;ead;ross;d aLng 2;bo7;a0Fe08iZlVoRrNuL;ck Le2P;ar8up;eMighten LownBy 2;aw3oG;eLshe29; 2z5;g 2lNol Lrk I;aLwi22;bo7r8;d 6low 2;aMeLip0;sh0;g 6ke0mLrLtten H;e F;gSlQnOrMsLzzle0;h F;e Lm 2;aw3ba4up;d0isL;h 2;e Ll 1V;aw3fQin,o7;ht ba4ure0;eQnMsL;s 2;cNd L;fLoG;or;e D;d06l 2;cPll Lrm0t1I;aNbMdo1in,oLsho0Gth0Avictim;ff,ut,v9;a4ehi2P;pa0D;e L;do1oGup;at Ldge0nd 13y5;in,o7up;aPi1IoOrL;aMess 6op LuO;aw3b04in,oC;gBwB; Ile0ubl1C;m 2;a0Bh06l03oPrMut L;aw3ba4do1oCup;ackBeep MoLy0;ss Dwd0;by,do1in,o0Vup;me OoMuntL; o2B;k 6l L;do1oG;aSbRforPin,oOtLu0P;hMoLrue;geth9;rough;ff,n,ut,v9;th,wL;ard;a4y;paLr8w3;rt;eaMose L;in,oCup;n 6r F;aOeMiL;ll0pE;ck Der Lw F;on,up;t 2;lSncel0rPsNtch MveE; in;o1Oup;h Dt L;doubt,oG;ry MvL;e 09;aw3oJ;l Lm H;aMba4do1oJup;ff,n,ut;r8w3;a0We0NiteAl0Go05rRuL;bblOckl06il0Elk 6ndl06rMsLtNy FzzA;t 01;n 0IsL;t D;e I;ov9;anXeaViMush L;oGup;ghRng L;aOba4do1forNin,oMuL;nd9p;n,ut;th;bo7lLr8w3;ong;teL;n 2;k L;do1in,o7up;ch0;arUg 6iSn5oQrOssNttlMunce Lx D;aw3ba4;e 6; ar8;e H;do1;k Dt 2;e 2;l 6;do1up;d 2;aQeed0oLurt0;cNw L;aw3ba4do1o7up;ck;k L;in,oC;ck0nk0stA; oRaOef 2lt0nd L;do1ov9up;er;up;r Mt L;do1in,oCup;do1o7;ff,nL;to;ck Qil0nNrgMsL;h D;ainBe D;g DkB; on;in,o7;aw3do1in,oCup;ff,ut;ay;ct FdRir0sk NuctionA; oG;ff;ar8o7;ouL;nd; o7;d L;do1oLup;ff,n;wn;o7up;ut",
  "Noun|Gerund": "true¦0:27;1:26;2:1X;3:1J;4:1Z;a25b1Oc1Cd16en14f0Yg0Wh0Ti0Rjog20k0Pl0Lm0In0Go0Cp05ques08rWsFtBu9volunt15w5y17zo2;a7ed1Si3or6r5;ap1Oest1Ci1;ki0r1O;i1r2s1Utc1U;nder5pri23;st1Mta4;al4e7hin4i6ra5y1J;c4di0i2v0Z;mi0p1H;a1Ys1;aKcHeGhEin1PkatClZmo4nowBpeAt8u6w5;ea3im1U;f02r5;fi0vi0J;a1Lretc1Ju5;d1BfJ;l0Xn1C;b6i0;eb5i0;oar19;ip15o5;rte2u1;a1r0At1;h6o3re5;a1He2;edu0Ooo0O;i0Nyi0;aCe8i11o6u5;li0n2;o5wi0;fi0;a7c6hear1Cnde3por1struct5;r1Au3;or0Vyc0G;di0so2;p0Qti0;aAeacek9la8o6r5ublis0X;a0Peten0Rin1oces16;iso2si5;tio2;n2yi0;ee0K;cka0Tin1rt0K;f7pe6rgani5vula1;si0zi0;ni0ra1;fe3;e5ur0W;gotia1twor4;a6e5i2onito3;e1ssa0L;nufactu3rke1;a7ea6i5od0Jyi0;cen0Qf1s1;r2si0;n09ug0E;i5n0J;c4lS;ci0magi2n5ro2;nova1terac1;andPea1i6o5un1;l03wO;ki0ri0;athe3rie5ui01;vi0;ar0CenHi7l6or5ros1unZ;ecas1mat1;ir1ooX;l6n5;anDdi0;i0li0;di0gin5;ee3;a8eba1irec1oub1r6umOw5;elB;awi0es04i5;n4vi0;n5ti0;ci0;aEelebra1hClAo7r5ur6;aw5osZ;li0;a6di0lo3mplai2n5o4pi0ve3;duc1sul1;cLti0;apCea3imHo5ubH;ni0tJ;a5ee3;n1t1;m8s1te3;ri0;aIeFitDlCoAr8u5;il8ll6r5;pi0;yi0;an5;di0;a1m5o4;bi0;esGoa1;c5i0;hi0;gin2lon5t1;gi0;ni0;bys6c4ki0;ki0;it1;c8dverti7gi0rg6ssu5;mi0;ui0;si0;coun1ti0;ti0;ng",
  "ProperNoun": "true¦barbie,c4diego,e3f2iron maiden,kirby,m0nis,riel,stevens;ercedes,i0;ckey,ssy;inn,lorence,ranco;lmo,uro;atalina,hristi",
  "Ordinal": "true¦eBf7nin5s3t0zeroE;enDhir1we0;lfCn7;d,t3;e0ixt8;cond,vent7;et0th;e6ie7;i2o0;r0urt3;tie4;ft1rst;ight0lev1;e0h,ie1;en0;th",
  "Cardinal": "true¦bEeBf5mEnine7one,s4t0zero;en,h2rDw0;e0o;lve,n5;irt6ousands,ree;even2ix2;i3o0;r1ur0;!t2;ty;ft0ve;e2y;ight0lev1;!e0y;en;illions",
  "Multiple": "true¦b3hundred,m3qu2se1t0;housand,r2;pt1xt1;adr0int0;illion",
  "City": "true¦0:77;1:64;2:6J;3:6M;4:5V;a6Bb56c4Ld4Be47f3Zg3Kh3Ci33j2Yk2Hl25m1Nn1Do1Ap0Xq0Vr0Os05tRuQvLwDxiBy9z5;a7h5i4Puri4R;a5e5ongsh0;ng3K;greb,nzib5J;ang2e5okoha3Vunfu;katerin3Krev0;a5n0R;m5Kn;arsBeAi6roclBu5;h0xi,zh5S;c7n5;d5nipeg,terth4;hoek,s1N;hi62kl3D;l66xford;aw;a8e6i5ladivost5Polgogr6O;en3lni6V;ni24r5;n2o3saill4Q;lenc4Zncouv3Vr3ughn;lan bat1Erumqi,trecht;aFbilisi,eEheDiBo9r7u5;l23n66r5;in,ku;i5ondh65;es54poli;kyo,m32ron1Rulo5;n,uS;an5jua3l2Wmisoa6Era3;j4Wshui; hag65ssaloni2K;gucigal28hr0l av1W;briz,i6llinn,mpe59ng5rtu,shk2U;i3Hsh0;an,chu1n0p2Hyu0;aEeDh8kopje,owe1It7u5;ra5zh50;ba0It;aten is58ockholm,rasbou6Auttga2Y;an8e6i5;jiazhua1llo1m60y0;f53n5;ya1zh4K;gh3Nt4T;att48o1Yv47;cramen18int ClBn5o paulo,ppo3Urajevo; 7aa,t5;a 5o domin3H;a3fe,m1O;antonBdie3Ffrancisco,j5ped3Qsalvad0L;o5u0;se;em,t lake ci5Iz28;lou5Bpeters27;aAe9i7o5;me,sar5t5C;io;ga,o5yadh;! de janei3H;cife,ims,nn3Lykjavik;b4Uip4lei2Knc2Rwalpindi;ingdao,u5;ez2i0R;aFeEhDiCo9r7u6yong5;ya1;eb5Bya1;a5etor3O;g54to;rt5zn0; 5la4Eo;au prin0Nelizabe26sa04;ls3Rrae5Ctts28;iladelph3Inom pe1Coenix;ki1r23tah tik3G;dua,lerZnaji,r4Qt5;na,r34;ak46des0Lm1Or6s5ttawa;a3Xlo;an,d07;a7ew5ing2Hovosibir1Lyc; 5cast38;del26orlea46taip16;g8iro4Yn5pl2Yshv35v0;ch6ji1t5;es,o1;a1o1;a6o5p4;ya;no,sa0Y;aFeCi9o6u5;mb2Cni28sc40;gadishu,nt6s5;c15ul;evideo,pelli1Tre31;ami,l6n16s5;kolc,sissauga;an,waukee;cca,d5lbour2Omph43ndo1Essi3;an,ell5i3;in,ín;cau,drAkass2Tl9n8r5shh4B;aca6ib5rakesh,se2M;or;i1Ty;a4FchFdal10i48;mo;id;aDeAi8o6u5vSy2;anMckn0Pdhia3;n5s angel27;d2g bea1O;brev2Ce3Mma5nz,sb2verpo29;!ss28; ma3Ai5;c5pzig;est17; p6g5ho2Xn0Dusan25;os;az,la34;aHharFiClaipeBo9rak0Eu7y5;iv,o5;to;ala lump4n5;mi1sh0;hi0Ilka2Ypavog4si5wlo2;ce;da;ev,n5rkuk;gst2sha5;sa;k5toum;iv;bIdu3llakuric0Rmpa3Gn6ohsiu1ra5un1Jwaguc0R;c0Qj;d5o,p4;ah1Uy;a7e6i5ohannesW;l1Wn0;dd37rusalem;ip4k5;ar2I;bad0mph1PnBrkutVs8taYz5̇zm7;m6tapala5;pa;ir;fah0l6tanb5;ul;am2Zi2H;che2d5;ianap2Mo20;aAe7o5yder2W; chi mi5ms,nolulu;nh;f6lsin5rakli2;ki;ei;ifa,lifax,mCn5rb1Dva3;g8nov01oi;aFdanEenDhCiPlasgBo9raz,u5;a5jr23;dal6ng5yaquil;zh1J;aja2Oupe;ld coa1Bthen5;bu2S;ow;ent;e0Uoa;sk;lw7n5za;dhi5gt1E;nag0U;ay;aisal29es,o8r6ukuya5;ma;ankfu5esno;rt;rt5sh0; wor6ale5;za;th;d5indhov0Pl paso;in5mont2;bur5;gh;aBe8ha0Xisp4o7resd0Lu5;b5esseldorf,nkirk,rb0shanbe;ai,l0I;ha,nggu0rtmu13;hradSl6nv5troit;er;hi;donghIe6k09l5masc1Zr es sala1KugavpiY;i0lU;gu,je2;aJebu,hAleve0Vo5raio02uriti1Q;lo7n6penhag0Ar5;do1Ok;akKst0V;gUm5;bo;aBen8i6ongqi1ristchur5;ch;ang m7ca5ttago1;go;g6n5;ai;du,zho1;ng5ttogr14;ch8sha,zh07;gliari,i9lga8mayenJn6pe town,r5tanO;acCdiff;ber1Ac5;un;ry;ro;aWeNhKirmingh0WoJr9u5;chareTdapeTenos air7r5s0tu0;g5sa;as;es;a9is6usse5;ls;ba6t5;ol;ne;sil8tisla7zzav5;il5;le;va;ia;goZst2;op6ubaneshw5;ar;al;iCl9ng8r5;g6l5n;in;en;aluru,hazi;fa6grade,o horizon5;te;st;ji1rut;ghd0BkFn9ot8r7s6yan n4;ur;el,r07;celo3i,ranquil09;ou;du1g6ja lu5;ka;alo6k5;ok;re;ng;ers5u;field;a05b02cc01ddis aba00gartaZhmedXizawl,lSmPnHqa00rEsBt7uck5;la5;nd;he7l5;an5;ta;ns;h5unci2;dod,gab5;at;li5;ngt2;on;a8c5kaOtwerp;hora6o3;na;ge;h7p5;ol5;is;eim;aravati,m0s5;terd5;am; 7buquerq6eppo,giers,ma5;ty;ue;basrah al qadim5mawsil al jadid5;ah;ab5;ad;la;ba;ra;idj0u dha5;bi;an;lbo6rh5;us;rg",
  "Region": "true¦0:2N;1:2T;2:2K;a2Qb2Dc1Zd1Ues1Tf1Rg1Lh1Hi1Cj18k13l10m0Pn07o05pZqWrTsKtFuCv9w5y3zacatec2U;akut0o0Du3;cat2k07;a4est 3isconsin,yomi1M;bengal,vi6;rwick2Bshington3;! dc;er4i3;rgin0;acruz,mont;dmurt0t3;ah,tar3; 2La0X;a5e4laxca1Rripu1Xu3;scaDva;langa1nnessee,x2F;bas0Vm3smNtar25;aulip2Dil nadu;a8i6o4taf11u3ylh1F;ffYrr04s1A;me1Cno1Quth 3;cVdU;ber0c3kkim,naloa;hu2ily;n4skatchew2xo3;ny; luis potosi,ta catari1;a3hode9;j3ngp07;asth2shahi;ingh25u3;e3intana roo;bec,en5reta0R;ara7e5rince edward3unjab; i3;sl0B;i,nnsylv3rnambu0B;an0;!na;axa0Ydisha,h3klaho20ntar3reg6ss0Bx0G;io;aJeDo5u3;evo le3nav0W;on;r3tt17va scot0;f8mandy,th3; 3ampton16;c5d4yo3;rk14;ako1N;aroli1;olk;bras1Mva0Cw3; 4foundland3;! and labrador;brunswick,hamp0Xjers4mexiSyork3;! state;ey;galOyarit;a9eghala0Mi5o3;nta1r3;dov0elos;ch5dlanCn4ss3zor11;issippi,ouri;as geraOneso18;ig2oac2;dhy12harasht0Gine,ni4r3ssachusetts;anhao,i el,ylF;p3toba;ur;anca0Ie3incoln0IouisH;e3iR;ds;a5e4h3omi;aka06ul1;ntucky,ra01;bardino,lmyk0ns0Qr3;achay,el0nata0X;alis5har3iangxi;kh3;and;co;daho,llino6n3owa;d4gush3;et0;ia1;is;a5ert4i3un2;dalFm0D;fordZ;mpYrya1waii;ansu,eorg0lou7oa,u3;an4erre3izhou,jarat;ro;ajuato,gdo3;ng;cesterS;lori3uji2;da;sex;ageTe6o4uran3;go;rs3;et;lawaLrbyK;aEeaDh8o3rimea ,umbr0;ahui6l5nnectic4rsi3ventry;ca;ut;i02orado;la;e4hattisgarh,i3uvash0;apQhuahua;chn4rke3;ss0;ya;ra;lFm3;bridge6peche;a8ihar,r7u3;ck3ryat0;ingham3;shi3;re;emen,itish columb0;h0ja cal7lk6s3v6;hkorto3que;st2;an;ar0;iforn0;ia;dygea,guascalientes,lAndhr8r4ss3;am;izo1kans4un3;achal 6;as;na;a 3;pradesh;a5ber4t3;ai;ta;ba4s3;ka;ma",
  "Country": "true¦0:39;1:2M;a2Xb2Ec22d1Ye1Sf1Mg1Ch1Ai14j12k0Zl0Um0Gn05om3DpZqat1KrXsKtCu6v4wal3yemTz2;a25imbabwe;es,lis and futu2Y;a2enezue32ietnam;nuatu,tican city;.5gTkraiZnited 3ruXs2zbeE;a,sr;arab emirat0Kkingdom,states2;! of am2Y;k.,s.2; 28a.;a7haBimor-les0Bo6rinidad4u2;nis0rk2valu;ey,me2Ys and caic1U; and 2-2;toba1K;go,kel0Znga;iw2Wji2nz2S;ki2U;aCcotl1eBi8lov7o5pa2Cri lanka,u4w2yr0;az2ed9itzerl1;il1;d2Rriname;lomon1Wmal0uth 2;afr2JkLsud2P;ak0en0;erra leoEn2;gapo1Xt maart2;en;negKrb0ychellY;int 2moa,n marino,udi arab0;hele25luc0mart20;epublic of ir0Dom2Duss0w2;an26;a3eHhilippinTitcairn1Lo2uerto riM;l1rtugE;ki2Cl3nama,pua new0Ura2;gu6;au,esti2;ne;aAe8i6or2;folk1Hth3w2;ay; k2ern mariana1C;or0N;caragua,ger2ue;!ia;p2ther19w zeal1;al;mib0u2;ru;a6exi5icro0Ao2yanm05;ldova,n2roc4zamb9;a3gol0t2;enegro,serrat;co;c9dagasc00l6r4urit3yot2;te;an0i15;shall0Wtin2;ique;a3div2i,ta;es;wi,ys0;ao,ed01;a5e4i2uxembourg;b2echtenste11thu1F;er0ya;ban0Hsotho;os,tv0;azakh1Ee3iriba03o2uwait,yrgyz1E;rWsovo;eling0Jnya;a2erF;ma15p1B;c6nd5r3s2taly,vory coast;le of m19rael;a2el1;n,q;ia,oI;el1;aiSon2ungary;dur0Mg kong;aAermany,ha0Pibralt9re7u2;a5ern4inea2ya0O;!-biss2;au;sey;deloupe,m,tema0P;e2na0M;ce,nl1;ar;bTmb0;a6i5r2;ance,ench 2;guia0Dpoly2;nes0;ji,nl1;lklandTroeT;ast tim6cu5gypt,l salv5ngl1quatorial3ritr4st2thiop0;on0; guin2;ea;ad2;or;enmark,jibou4ominica3r con2;go;!n B;ti;aAentral african 9h7o4roat0u3yprQzech2; 8ia;ba,racao;c3lo2morPngo-brazzaville,okFsta r03te d'ivoiK;mb0;osD;i2ristmasF;le,na;republic;m2naTpe verde,yman9;bod0ero2;on;aFeChut00o8r4u2;lgar0r2;kina faso,ma,undi;azil,itish 2unei;virgin2; is2;lands;liv0nai4snia and herzegoviGtswaGuvet2; isl1;and;re;l2n7rmuF;ar2gium,ize;us;h3ngladesh,rbad2;os;am3ra2;in;as;fghaFlCmAn5r3ustr2zerbaijH;al0ia;genti2men0uba;na;dorra,g4t2;arct6igua and barbu2;da;o2uil2;la;er2;ica;b2ger0;an0;ia;ni2;st2;an",
  "Place": "true¦a00bYcUdTeSfRgMhLiJjfk,kHlFmDnBorAp8r7s6t3u2vostok,wake isCy0;a0yz;kutGngtze;laanbaatar,pT;ahiti,h0;amWe 0;bronx,hamptons;akhalIeine,fo,oho,under5yd;ed sea,io grande;acifWek,h0itcairn;l,x;ange county,d,inoco;ew eng0ile;land;a0co,ekong,idIuc;gadSlibu,nhattS;a0gw,hr;s,x;osrae,rasnoyar0ul;sk;ax,cn,nd0st;ianLochina;arlem,kg,nd,ovd;a3odavari,re0;at 0enwich;brita0lakC;in;ngAy village;co,ra;urope,verglad8;anube,en,fw,own2xb;dg,gk,h0lt;a1ina0uuk;town;morro,tham;cn,e0kk,rooklyn;l air,verly hills;driadic,frica,m7n2r3sia,tl1zor0;es;!ant2;adyr,tar0;ct0;ic0; oce0;an;ericas,s",
  "WeekDay": "true¦fri2mon2s1t0wednesd3;hurs1ues1;aturd1und1;!d0;ay0;!s",
  "Month": "true¦dec0february,july,nov0octo1sept0;em0;ber",
  "Date": "true¦ago,on4som4t1week0yesterd5; end,ends;mr1o0;d2morrow;!w;ed0;ay",
  "Duration": "true¦centurAd8h7m5q4se3w1y0;ear8r8;eek0k7;!end,s;ason,c5;tr,uarter;i0onth3;llisecond2nute2;our1r1;ay0ecade0;!s;ies,y",
  "FemaleName": "true¦0:IS;1:IW;2:I5;3:I4;4:IM;5:I9;6:JD;7:GQ;8:J9;9:J5;A:HD;B:HN;C:IE;D:J2;E:II;F:H2;G:C4;H:HP;aGIbFDcDJdCSeBIfB0gAAh9Qi9Dj8Ck7Cl5Wm46n3Ko3Gp34qu33r2Bs16t0Fu0Dv03wWxiUyPzI;aMeJineb,oIsof2;e3Rf2la,ra;h3iLlJna,ynI;ab,ep;da,ma;da,h3iIra;nab;aLeKi0GolB3uJvI;etAonDH;i0na;le0sen2;el,gm3Gn,rGAs8T;aoIme0nyi;m5YyAA;aNendDRhiD8iI;dele9lKnI;if45niIo0;e,f44;a,helmi0lIma;a,ow;ka0nB;aOeLiIusa5;ck82kJlAole7viI;anGenIQ;ky,toriBE;da,lA5rIs0;a,nIoniGV;a,iFH;leInesGV;nI7rI;i1y;g9rIxGW;su5te;aZeVhSiOoMrJuIy3;i,la;acIPiIu0L;c2na,sI;hGta;nIr0H;iGya;aKffaEGnIs6;a,gtiI;ng;!nFHra;aJeIomasi0;a,l9Lo87res1;l2ndolwethu;g9Co85rJssI;!a,ie;eIi,ri8;sa,za;bPlNmLnJrIs6tia0wa0;a60yn;iIya;a,ka,s6;arGe3iIm75ra;!ka;a,iI;a,t6;at6it6;a0Gcarlett,e0ChYiUkye,neza0oStOuJyI;bI2lvi1;ha,mayI5ni7sJzI;an3KetAie,y;anIi8;!a,e,nI;aCe;aKeI;fIl5DphI;an4;cHQr5;b2fiA3m0MnIphi1;d3ia,ja,ya;er3lKmon1nJobh8MtI;a,i;dy;lEHv2;aNeJirIo0risEZy5;a,lDD;ba,e0i5lKrI;iIr6Gyl;!d8Efa;ia,lDP;hd,iNki3nKrJu0w0yI;la,ma,na;i,le9on,ron;aJda,ia,nIon;a,on;!ya;k6mI;!aa;lKrJtaye7YvI;da,inj;e0ife;en1i0ma;anA0bMd3Kh1PiBkLlKmJnd3rIs6vannaC;aCi0;ant6i3;lDEma,ome;ee0in8Ou3;in1ri0;a05e00hYiVoIuthDC;bTcSghRl8GnQsKwJxI;anAUie,y;an,e0;aJeIie,lD; merBIann8ll1marD6t7;!lInn1;iIyn;e,nI;a,dG;da,i,na;ayy8B;hel63io;bDFer7yn;a,cJkImas,nGta,ya;ki,o;helHki;ea,iannG7oI;da,n1L;an0bKemGgi0iJnIta,y0;a86ee;han81na;a,eI;cE5kaC;bi0chJe,i0mo0nIquEFy0;di,ia;aEDelIiB;!e,le;een4ia0;aOeNhLipaluk,oKrIute67;iIudenCL;scil3LyamvaB;lly,rt2;ilome0oebe,ylI;is,lis;ggy,nelope,r5t3;ige,m0UnLo5rvaDBtJulI;a,etAin1;ricIt4T;a,e,ia;do3i07;ctav2dJfCUis6lIphCUumBYyunbileg;a,ga,iv2;eIvA9;l2tA;aXeViNoJurIy5;!ay,ul;a,eKor,rJuI;f,r;aCeEma;ll1mi;aOcMhariBJkLlaKna,sIta,vi;anIha;ur;!y;a,iDNki;hoHk9SolI;a,eDE;!mh;hir,lIna,risFsreE;!a,lBO;asuMdLh2i6Cl5nKomi8rgEJtIzanin zah3;aIhal4;li1s6;cy,etA;e9iEP;nngu30;a0Ackenz4e02iNoKrignayani,uriD8yI;a,rI;a,lOna,tH;bi0i3llBDnI;a,iI;ca,ka,qCY;a,cUkaTlOmi,nMrJtzi,yI;ar;aJiam,lI;anEI;!l,nB;dy,eIh,n4;nhHrva;aLdKiCKlI;iIy;cent,e;red;!gros;!e5;ae5hI;ae5el40;ag5EgOi,lLrI;edi77iJjem,on,yI;em,l;em,sF;an4iIliF;nIsC9;a,da;!an,han;b0DcANd0Be,g09ha,i08ja,l06n04rMsoum5YtLuJv80x9FyIz4;bell,ra,soB4;de,rI;a,eE;h8Cild1t4;a,cYgUiLjor4l7Qn4s6tKwa,yI;!aIbe6Uja9lA9;m,nBC;a,ha,in1;!aKbC6eJja,lDna,sIt62;!a,ol,sa;!l1H;! Kh,mJnI;!a,e,n1;!awit,i;aliACcJeduarBfern5EjIlui5W;o6Dul2;ecil2la3;arKeJie,oIr46ueriA;!t;!ry;et44i39;el4Vi75y;dIon,ue5;akran7y;ak,en,iIlo3Q;a,ka,nB;a,re,s4te;daIg4;!l3C;alDd4elIge,isD6on0;ei9in1yn;el,le;a0Oe0DiZoRuMyI;d2la,nI;!a,dJeBCnIsCG;!a,eBB;a,sCE;aCRcKel0QiFlJna,pIz;e,i7;a,u,wa;iIy;a0Te,ja,l2LnB;is,l1TrKttJuIvel4;el5is1;e,ie;aLeJi8na,rI;a84i8;lIn1t7;ei;!in1;aTbb98dSepa,lNnKsJv2zI;!a,be5KetAz4;a,etA;!a,dI;a,sIy;ay,ey,i,y;a,iKja,lI;iIy;a9We;!aI;!nG;ia,ya;!nI;!a,ne;aQda,e0iOjZla,nNoLsKtIx4y5;iIt4;c2t2;e2NlCB;la,nIra;a,ie,o3;a,or1;a,gh,laI;!ni;!h,nI;a,d3e,n5O;cPdon93iOkes6mi96na,rNtKurJvIxmi,y5;ern1in2;a,e53ie,yn;as6iJoI;nya,ya;fa,s6;a,isF;a,la;ey,ie,y;a05e00hYiPlAFoOrKyI;lIra;a,ee,ie;istIy6B;a,en,iJyI;!na;!e,n58;nul,ri,urtnAV;aPerOlAUmKrIzzy;a,stI;en,in;!berlJmernI;aq;eIi,y;e,y;a,stE;!na,ra;aIei3ongordzol;dij1w5;el7MiLjsi,lKnJrI;a,i,ri;d3na,za;ey,i,lB8s4y;ra,s6;bi7cAEdiat7EeAXiSlRmQnyakuma1BrOss6HtLvi7yI;!e,lI;a,eI;e,i8H;a6BeJhIi4MlDri0y;ar69er69ie,leErAXy;!lyn8Cri0;a,en,iIl5Qoli0yn;!ma,nGsF;a5il1;ei8Ai,l4;a,tl6I;a09eZiWoOuI;anMdLliIst61;a8DeIsF;!n9tI;!a,te;e5Hi3Iy;a,i7;!anOcelDdNelHhan7NleMni,sJva0yI;a,ce;eIie;fIlDph5S;a,in1;en,n1;i8y;!a,e,n40;lIng;!i1DlI;!i1C;anOle0nLrKsI;i88sI;!e,i87;i,ri;!a,elHif2AnI;a,etAiIy;!e,f28;a,e89iJnI;a,e88iI;e,n1;cNda,mi,nJque4UsminGvie3y9zI;min8;a8eJiI;ce,e,n1s;!lIsFt0G;e,le;inJk4lDquelI;in1yn;da,ta;da,lSmQnPo0rOsJvaIzaro;!a0lu,na;aKiJlaIob7Z;!n9H;do3;belIdo3;!a,e,l37;a72en1i0ma;di3es,gr6Tji;a9elBogI;en1;a,e9iIo0se;a0na;aTePiKoIusFyacin29;da,ll4rten21snI;a,i9K;lJmaI;ri;aJdIlaJ;a,egard;ry;ath1AiKlJnriet7rmi9sI;sa,t19;en2Qga,mi;di;bi2Bil8ClOnNrKsJtIwa,yl8C;i5Nt4;n5Tti;iImo4Xri4Y;etI;!te;aCnaC;a,ey,l4;a03eXiSlQoOrLunKwI;enIyne1O;!dolD;ay,el;acieJetIiselB;a,chE;!la;ld19ogooI;sh;adys,enIor2yn2G;a,da,na;aLgi,lJna,ov84selIta;a,e,le;da,liI;an;!n0;mMnKorgJrI;ald3Ni,m3Atru86;etAi4S;a,eIna;s25vieve;ma;bJle,mIrnet,yH;al5Ji5;i5BrielI;a,l1;aUeRiQlorPoz2rI;anKeJiI;da,eB;da,ja;!cI;esJiIoi0N;n1s5X;!ca;a,enc2;en,o0;lJn0rnI;anB;ec2ic2;jr,n7rLtIy8;emJiIma,ouma7;ha,ma,n;eh;ah,iBrah,za0;cr4Ld0Oe0Ni0Mk7l05mXn4WrUsOtNuMvI;aKelJiI;!e,ta;inGyn;!ngel2S;geni1ni43;h5Qta;mMperanLtI;eJhIrel5;er;l2Zr8;za;a,eralB;iIma,nest2Jyn;cIka,n;a,ka;a,eNiKmI;aIie,y;!li9;lIn1;ee,iIy;a,e,ja;lIrald;da,y;aXeViOlNma,no3oLsKvI;a,iI;na,ra;a,ie;iIuiI;se;a,en,ie,y;a0c2da,f,nNsKzaI;!betIve7;e,h;aIe,ka;!beI;th;!a,or;anor,nG;!a;!in1na;leEs6;vi;eJiIna,wi0;e,th;l,n;aZeNh2iMjeneLoI;lor5Qminiq4Gn3DrItt4;a,eEis,la,othIthy;ea,y;ba;an0AnaCon9ya;anRbQde,ePiNlKmetr2nIsir5H;a,iI;ce,se;a,iJla,orIphi9;es,is;a,l6A;dIrdI;re;!d59na;!b2ForaCraC;a,d3nI;!a,e;hl2i0l0HmOnMphn1rJvi1WyI;le,na;a,by,cJia,lI;a,en1;ey,ie;a,etAiI;!ca,el1Bka,z;arIia;is;a0Se0Oh05i03lVoKristJynI;di,th2;al,i0;lQnNrJurI;tn1E;aKd2MiIn2Mri9;!nI;a,e,n1;!l4;cepci57n4sI;tanIuelo;ce,za;eIleE;en,tA;aKeoJotI;il4Z;!pat3;ir8rKudI;etAiI;a,ne;a,e,iI;ce,s00;a3er3ndI;i,y;aSeOloe,rI;isKyI;stI;al;sy,tI;a1Qen,iIy;an1e,n1;deKlseJrI;!i8yl;a,y;li9;nNrI;isLlJmI;ai9;a,eIotA;n1tA;!sa;d3elHtI;al,elH;cJlI;esAi42;el2ilI;e,ia,y;itlZlYmilXndWrOsMtIy5;aKeKhIri0;erIleErDy;in1;ri0;a32sI;a31ie;a,iOlMmeKolJrI;ie,ol;!e,in1yn;lIn;!a,la;a,eIie,o7y;ne,y;na,sF;a0Hi0H;a,e,l1;is7l4;in,yn;a0Ie02iZlXoUrI;andi8eRiKoJyI;an0nn;nwDoke;an3CdgMg0XtI;n2WtI;!aJnI;ey,i,y;ny;etI;!t8;an0e,nI;da,na;bbi8glarJlo06nI;i7n4;ka;ancIythe;a,he;an18lja0nIsm3I;i7tI;ou;aVcky,linUni7rQssPtKulaCvI;!erlI;ey,y;hKsy,tI;e,iIy8;e,na;!anI;ie,y;!ie;nIt6yl;adJiI;ce;etAi9;ay,da;!triI;ce,z;rbKyaI;rmI;aa;a3o3ra;a2Sb2Md23g1Zi1Qj5l16m0Xn0Aoi,r05sVtUuQvPwa,yJzI;ra,u0;aLes6gKlJseI;!l;in;un;!nI;a,na;a,i2I;drKgus1RrJsteI;ja;el2;a,ey,i,y;aahua,he0;hJi2Gja,mi7s2DtrI;id;aNlJraqIt21;at;eJi8yI;!n;e,iIy;gh;!nI;ti;iKleJo6pi7;ta;en,n1tA;aIelH;!n1J;a01dje5eZgViTjRnKohito,toIya;inetAnI;el5ia;!aLeJiImK;e,ka;!mItA;ar4;!belJliFmV;sa;!l1;a,eliI;ca;ka,sIta;a,sa;elIie;a,iI;a,ca,n1qI;ue;!tA;te;!bJmIstasiNya;ar2;el;aMberLeliKiIy;e,l2naI;!ta;a,ja;!ly;hHiJl2nB;da;a,ra;le;aXba,eQiNlLthKyI;a,c2sI;a,on,sa;ea;iIys0O;e,s0N;a,cJn1sIza;a,e,ha,on,sa;e,ia,ja;c2is6jaLksaLna,sKxI;aIia;!nd3;ia,saI;nd3;ra;ia;i0nJyI;ah,na;a,is,naCoud;la;c6da,leEmOnMsI;haClI;inIyZ;g,n;!h;a,o,slI;ey;ee;en;at6g4nJusI;ti0;es;ie;aXdiUelNrI;eKiI;anNenI;a,e,ne;an0;na;!aMeLiJyI;nn;a,n1;a,e;!ne;!iI;de;e,lDsI;on;yn;!lI;i9yn;ne;aLbJiIrM;!gaL;ey,i8y;!e;gaI;il;dLliyKradhJs6;ha;ya;ah;a,ya",
  "FirstName": "true¦aLblair,cHdevGgabrieFhinaEjCk9l8m4quinn,re3s0;h0umit;ay,e0iloh;a,lby;g6ne;a1el0ina,org5;!okuh9;naia,r0;ion,lo;ashawn,uca;asCe1ir0rE;an;lsAnyat2rry;am0ess6ie,ude;ie,m5;ta;le;an,on;as2h0;arl0eyenne;ie;ey,sidy;lex2ndr1ubr0;ey;a,ea;is",
  "Person": "true¦a0Ob0Hc08d05e02g01hZinez,jYkVlSmMnKoJpHr9s7t4v2w0xzibit,yanni;ar0ednesday adams,ill.i.am,oode;hol,rO;a0oltaiO;lentino rossi,n go7;a1heresa may,i0yra banks;ger woods,mbaQ;tum,ylor;a0carlett johanss03hakespeaJinbad,lobodan milosevic,ocratM;ddam hussain,ntigold;a6e5i4o2u0za;mi,n dmc,paul,sh limbau0;gh;d stewart,nald0thko;inho,o;hanYvaldo;ese witherspoVil9mbrandt;ffi,y roma03;a0e08ip07lato,oe,uff daddy;lm06ris hiltS;prah winfrWra;as,e0iles crane,ostradamP; yo,l3ttI;acklemo4essia3i1o0ubarek;by,lie3net,rrissS;randa ju0tt romnR;ly;en;re;ady gaga,e0iberaT;bron jam0e;es;anye west,e1iefer suther0obe bryant;land;ats,ndall,sha;aime,effersCk rowling;a0itlPulk hogan;lle berry,rrisA;ast9otye;ff1m0nya,zekiel;eril lagasse,inem;ie;a1e0ick wolf,rake;gas,nzel washingt4;lt3nB;ar5h3lint2o0;nfuci0olio;us;on;aucCy0;na;dinal wols1son0;! palm9;ey;a5e3o2ro0;ck,n0;te;no;ck,yon0;ce;nksy,rack obama;ristot1shton kutch0;er;le",
  "LastName": "true¦0:9G;1:9W;2:9Y;3:9O;4:9I;5:8L;6:9L;7:A1;8:9F;9:8A;A:78;B:6G;C:6K;a9Vb8Nc7Ld6Ye6Tf6Fg5Wh59i55j4Qk45l3Nm2Sn2Fo27p1Oquispe,r18s0Ft05vVwOxNyGzD;aytsAEhD;aDou,u;ng,o;aGeun81iDoshiAAun;!lD;diDmaz;rim,z;maDng;da,guc98mo6VsDzaA;aAhiA8;iao,u;aHeGiEoDright,u;jc8Tng;lDmm0nkl0sniewsA;liA2s2;b0iss,lt0;a5Tgn0lDtanabe;k0sh;aHeGiEoDukB;lk5roby5;dBllalDnogr2Zr10ss0val37;ba,obos;lasEsel7P;lGn dFrg8FsEzD;qu7;ily9Pqu7silj9P;en b35ijk,yk;enzue96verde;aLeix1KhHi3j6ka3IoGrFsui,uD;om50rD;c3n0un1;an,embl8UynisA;dor96lst31m4rr9th;at5Ni7NoD;mErD;are70laci65;ps2s0Z;hirBkah8Enaka;a01chXeUhQiNmKoItFuEvDzabo;en8Bobod34;ar7bot4lliv3zuA;aEein0oD;i68j3Myan8W;l6rm0;kol5lovy5re6Rsa,to,uD;ng,sa;iDy60;rn5tD;!h;l5ZmEnDrbu;at8gh;mo6Eo6K;aFeDimizu;hu,vchD;en7Duk;la,r17;gu8infeld,mDoh,pulve8Trra4S;jDyD;on5;evi6Giltz,miDneid0roed0ulz,warz;dEtD;!z;!t;ar42h6ito,lFnDr4saAto,v4;ch7d0AtDz;a4Pe,os;as,ihBm3Zo0Q;aOeNiKoGuEyD;a67oo,u;bio,iz,sD;so,u;bEc7Bdrigue57g03j73mDosevelt,ssi,ta7Nux,w3Z;a4Ce0O;ertsDins2;!on;bei0LcEes,vDzzo;as,e8;ci,hards2;ag3es,it0ut0y9;dFmEnDsmu7Zv5F;tan1;ir7os;ic,u;aSeLhJiGoErDut6;asad,if60ochazk1V;lishc23pDrti63u55we67;e2Tov48;cEe09nD;as,to;as61hl0;aDillips;k,m,n5L;de3AetIna,rGtD;ersErovDtersC;!a,ic;en,on;eDic,ry,ss2;i8ra,tz,z;ers;h71k,rk0tEvD;ic,l3T;el,t2O;bJconnor,g2ClGnei5QrEzD;demir,turk;ella3MtDwe5O;ega,iz;iDof6GsC;vDyn1E;ei8;aPri1;aLeJguy1iFoDune44ym3;rodahl,vDwak;ak3Uik5otn57;eEkolDlsCx2;ic,ov6X;ls1miD;!n1;ils2mD;co42ec;gy,kaEray3varD;ro;jiDmu8shiD;ma;aWcUeQiPoIuD;lGnFrDssoli5T;atDpTr68;i,ov4;oz,te4C;d0l0;h3lInr13o0GrEsDza0Y;er,s;aFeEiDoz5r3Ete4C;!n6F;au,i8no,t4N;!l9;i2Rl0;crac5Ohhail5kke3Qll0;hmeFij0j2FlEn2Xrci0ssiDyer19;!er;n0Io;dBti;cartDlaughl6;hy;dMe6Egnu5Fi0jer35kLmJnci5ArFtEyD;er,r;ei,ic,su1O;iEkBqu9roqu6tinD;ez,s;a55c,nD;!o;a53mD;ad5;e5Pin1;rig4Ps1;aSeMiIoGuEyD;!nch;k4nDo;d,gu;mbarDpe2Svr4;di;!nDu,yana1T;coln,dD;bDholm;erg;bed5UfeGhtFitn0kaEn6rDw2H;oy;!j;in1on1;bvDvD;re;iDmmy,rsCu,voie;ne,t12;aTennedy,h3iSlQnez48oJrGuEvar3woD;k,n;cerDmar59znets5;a,o2H;aDem0i31yeziu;sni3RvD;ch3W;bay4Grh0Ksk0UvaFwalDzl5;czDsA;yk;cFlD;!cDen3S;huk;!ev4ic,s;e6uiveD;rt;eff0l4mu8nnun1;hn,llFminsArEstra33to,ur,yDzl5;a,s0;j0HlsC;oe;aMenLha2Qim0RoEuD;ng,r4;e2KhFnErge2Ku2OvD;anB;es,ss2;anEnsD;en,on,t2;nesDsC;en,s1;ki27s1;cGkob3RnsDrv06;en,sD;enDon;!s;ks2obs1;brahimBglesi3Ake4Ll0DnoZoneFshikEto,vanoD;u,v4A;awa;scu;aPeIitchcock,jaltal6oFrist46uD;!aDb0gh9ynh;m3ng;a24dz4fEjga2Tk,rDx3B;ak0Yvat;er,fm3B;iGmingw3NnErD;nand7re8;dDriks1;ers2;kkiEnD;on1;la,n1;dz4g1lvoLmJnsCqIrr0SsFuEyD;as36es;g1ng;anEhiD;mo0Q;i,ov08;ue;alaD;in1;rs1;aNeorgMheorghe,iKjonJoGrEuDw2;o,staf2Utierr7zm3;ayDg4iffitVub0;li1H;lub3Rme0JnEodD;e,m3;calv9zale0H;aj,i;bs2l,mDordaL;en7;iev3A;gnJlGmaFnd2Mo,rDs2Muthi0;cDza;ia;ge;eaElD;agh0i,o;no;e,on;ab0erLiHjeldsted,lor9oFriedm3uD;cDent9ji3E;hs;ntaDrt6urni0;na;lipEsD;ch0;ovD;!ic;hatBnanFrD;arDei8;a,i;deS;ov4;dGinste6riksCsDva0D;cob2YpDtra2W;inoza,osiL;en,s2;er,is2wards;aUeMiKjurhuJoHrisco0ZuEvorakD;!oQ;arte,boEmitru,rDt2U;and,ic;is;g3he0Imingu7n2Ord1AtD;to;us;aDmitr29ssanayake;s,z; GbnaFlEmirDrvis1Lvi,w3;!ov4;gado,ic;th;bo0groot,jo04lEsilDvri9;va;a cruz,e2uD;ca;hl,mcevsAnEt2EviD;d5es,s;ieDku1S;ls1;ki;a06e01hOiobNlarkMoFrD;ivDuz;elli;h1lHntGoFrDs26x;byn,reD;a,ia;ke,p0;i,rer0N;em3liD;ns;!e;anu;aLeIiu,oGriDuJwe;stD;eDiaD;ns1;i,ng,uFwDy;!dhury;!n,onEuD;ng;!g;kEnDpm3tterjee,v7;!d,g;ma,raboD;rty;bGl08ng4rD;eghetEnD;a,y;ti;an,ota0L;cer9lder2mpbeIrFstDvadi07;iDro;llo;doEt0uDvalho;so;so,zo;ll;es;a08eWhTiRlNoGrFyD;rne,tyD;qi;ank5iem,ooks,yant;gdan5nFruya,su,uchEyHziD;c,n5;ard;darDik;enD;ko;ov;aEondD;al;nco,zD;ev4;ancRshwD;as;a01oDuiy3;umDwmD;ik;ckNethov1gu,ktLnJrD;gGisFnD;ascoDds1;ni;ha;er,mD;ann;gtDit7nett;ss2;asD;hi;er,ham;b4ch,ez,hMiley,kk0nHrDu0;bEnDua;es,i0;ieDosa;ri;dDik;a8yopadhyD;ay;ra;er;k,ng;ic;cosZdYguilXkhtXlSnJrGsl3tchis2yD;aEd6;in;la;aEsl3;an;ujo,ya;dFgelD;ovD;!a;ersGov,reD;aDjL;ss1;en;en,on,s2;on;eksejGiyGmeiFvD;ar7es;ez;da;ev;ar;ams;ta",
  "Honorific": "true¦director1field marsh2lieutenant1rear0sergeant major,vice0; admir1; gener0;al",
  "Adj|Gerund": "true¦0:3H;1:3J;2:33;3:2Z;4:37;5:35;6:3E;7:31;8:38;9:2J;a35b2Vc2Dd1Te1If17g11h0Yi0Rjud9l0Nm0Gnu0Fo0Ap04rYsKtEuBvAw18yiel3;ar6e08;nBpA;l1Rs0B;fol3n21sett2;aEeDhrBi4ouc7rAwis0;e0Bif2oub2us0yi1;ea1SiA;l2vi1;l2mp0rr1J;nt1Xxi1;aMcreec7enten2PhLkyrocke0lo1Tmi2oJpHtDuBweA;e1Sl2;pp2CrA;gi1pri5roun3;aBea8iAri2Jun25;mula0r4;gge4rA;t2vi1;ark2eAraw2;e3llb2H;aAot7;ki1ri1;i1Xoc2B;dYtisf6;aEeBive0oAus7;a4l2;assu4defi1Tfres7ig1Tjuve0QlaImai1Ts0vAwar3;ea2italiAol1I;si1zi1;gi1ll6mb2vi1;a6eDier25lun9rAun2E;eBoA;mi5vo21;ce3s5vai2;n3rpleA;xi1;ffCpWutBverAwi1;arc7lap12p0Pri3whel8;goi1l6st1L;en3sA;et0;m2Lrtu4;aEeDiCoBuAyst0L;mb2;t1Lvi1;s5tiga0;an1Tl0n3smeri28;dAtu4;de17;aCeaBiAo0W;fesa0Vmi0vi1;di1ni1;c1Hg9s0;llumiZmFnArri0T;cDfurGsCtBviA;go25ti1;e1Qimi23oxica0rig0X;pi4ul0;orpo22r0M;po5;arrowi1eaBorr03umilA;ia0;li1rtwar8;lErA;atiCip0BoBuelA;i1li1;undbrea13wi1;f6ng;a4ea8;aIetc7it0lEoCrBulfA;il2;ee1JighZust1P;rAun3;ebo3thco8;aCoA;a0wA;e4i1;mi1tte4;di1sciA;na0;lectrJmHnExA;aCci0hBis0pA;an3lo3;aOila1D;c0spe1C;ab2cBdu4ergi15ga9live06ric7s04tA;hral2i0L;han0oura9;barras5er9pA;owe4;if6;aSeIiBrA;if0;sAzz6;aEgDhearCsen0tA;rAur13;ac0es5;teU;us0;ppoin0r8;biliIcFfiRgra3ligh0mDpres5sCvA;asHeloA;pi1;erE;an3eaNorA;ali0L;a6eiBliLrA;ea5;vi1;ta0;ma9ri1s7un0zz2;aPhMlo5oAripp2ut0;mGnArrespon3;cerEfDspi4tAvinU;inBrA;as0ibu0ol2;ui1;lic0u5;ni1;fDmCpA;eAromi5;l2ti1;an3;or0;aAil2;llen9n9r8;gi1;l8ptAri1;iva0;aff2eGin3lFoDrBuA;d3st2;eathtaAui5;ki1;gg2i2o8ri1unA;ci1;in3;co8wiA;lAtc7;de4;bsorVcOgonMlJmHnno6ppea2rFsA;pi4su4toA;nBun3;di1;is7;hi1;res0;li1;aFu5;si1;ar8lu4;ri1;mi1;iAzi1;zi1;cAhi1;eleDomA;moBpan6;yi1;da0;ra0;ti1;bi1;ng",
  "Adverb": "true¦a08b05d00eYfSheQinPjustOkinda,likewiZmMnJoEpCquite,r9s5t2u0very,well;ltima01p0; to,wards5;h1iny bit,o0wiO;o,t6;en,us;eldom,o0uch;!me1rt0; of;how,times,w0C;a1e0;alS;ndomRth05;ar excellenEer0oint blank; Lhaps;f3n0utright;ce0ly;! 0;ag05moX; courGten;ewJo0; longWt 0;onHwithstand9;aybe,eanwhiNore0;!ovT;! aboX;deed,steY;lla,n0;ce;or3u0;ck1l9rther0;!moK;ing; 0evK;exampCgood,suH;n mas0vI;se;e0irect2; 2fini0;te0;ly;juAtrop;ackward,y 0;far,no0; means,w; GbroFd nauseam,gEl7ny5part,s4t 2w0;ay,hi0;le;be7l0mo7wor7;arge,ea6; soon,i4;mo0way;re;l 3mo2ongsi1ready,so,togeth0ways;er;de;st;b1t0;hat;ut;ain;ad;lot,posteriori",
  "Conjunction": "true¦aXbTcReNhowMiEjust00noBo9p8supposing,t5wh0yet;e1il0o3;e,st;n1re0thN; if,by,vM;evL;h0il,o;erefOo0;!uU;lus,rovided th9;r0therwiM;! not; mattEr,w0;! 0;since,th4w7;f4n0; 0asmuch;as mIcaForder t0;h0o;at;! 0;only,t0w0;hen;!ev3;ith2ven0;! 0;if,tB;er;o0uz;s,z;e0ut,y the time;cau1f0;ore;se;lt3nd,s 0;far1if,m0soon1t2;uch0; as;hou0;gh",
  "Currency": "true¦$,aud,bQcOdJeurIfHgbp,hkd,iGjpy,kElDp8r7s3usd,x2y1z0¢,£,¥,ден,лв,руб,฿,₡,₨,€,₭,﷼;lotyQł;en,uanP;af,of;h0t5;e0il5;k0q0;elK;oubleJp,upeeJ;e2ound st0;er0;lingG;n0soF;ceEnies;empi7i7;n,r0wanzaCyatC;!onaBw;ls,nr;ori7ranc9;!os;en3i2kk,o0;b0ll2;ra5;me4n0rham4;ar3;e0ny;nt1;aht,itcoin0;!s",
  "Determiner": "true¦aBboth,d9e6few,le5mu8neiDplenty,s4th2various,wh0;at0ich0;evC;a0e4is,ose;!t;everal,ome;!ast,s;a1l0very;!se;ch;e0u;!s;!n0;!o0y;th0;er",
  "Adj|Present": "true¦a07b04cVdQeNfJhollIidRlEmCnarrIoBp9qua8r7s3t2uttFw0;aKet,ro0;ng,u08;endChin;e2hort,l1mooth,our,pa9tray,u0;re,speU;i2ow;cu6da02leSpaN;eplica01i02;ck;aHerfePr0;eseUime,omV;bscu1pen,wn;atu0e3odeH;re;a2e1ive,ow0;er;an;st,y;ow;a2i1oul,r0;ee,inge;rm;iIke,ncy,st;l1mpty,x0;emHpress;abo4ic7;amp,e2i1oub0ry,ull;le;ffu9re6;fu8libe0;raE;alm,l5o0;mpleCn3ol,rr1unterfe0;it;e0u7;ct;juga8sum7;ea1o0;se;n,r;ankru1lu0;nt;pt;li2pproxi0rticula1;ma0;te;ght",
  "Comparable": "true¦0:3C;1:3Q;2:3F;a3Tb3Cc33d2Ue2Nf2Ag1Wh1Li1Fj1Ek1Bl13m0Xn0So0Rp0Iqu0Gr07sHtCug0vAw4y3za0Q;el10ouN;ary,e6hi5i3ry;ck0Cde,l3n1ry,se;d,y;ny,te;a3i3R;k,ry;a3erda2ulgar;gue,in,st;a6en2Xhi5i4ouZr3;anqu2Den1ue;dy,g36me0ny;ck,rs29;ll,me,rt,wd3I;aRcaPeOhMiLkin0BlImGoEpDt6u4w3;eet,ift;b3dd0Wperfi21rre29;sta27t22;a8e7iff,r4u3;pUr1;a4ict,o3;ng;ig2Vn0N;a1ep,rn;le,rk,te0;e1Si2Vright0;ci1Zft,l3on,re;emn,id;a3el0;ll,rt;e4i3y;g2Mm0Z;ek,nd2T;ck24l0mp1M;a3iRrill,y;dy,l01rp;ve0Jxy;n1Kr3;ce,y;d,fe,int0l1Iv0V;a8e6i5o3ude;mantic,o19sy,u3;gh;pe,t1P;a3d,mo0A;dy,l;gg4iFndom,p3re,w;id;ed;ai2i3;ck,et;hoAink,l9o8r5u3;ny,r3;e,p12;egna2ic4o3;fouSud;ey,k0;liXor;ain,easa2;ny;dd,i0ld,ranL;aive,e5i4o3u15;b0Tisy,rm0Zsy;bb0ce,mb0S;a3r1w;r,t;ad,e5ild,o4u3;nda12te;ist,o1;a4ek,l3;low;s0ty;a8e7i6o3ucky;f0Kn4o15u3ve0w10y0O;d,sy;e0g;ke0l,mp,tt0Fve0;e1Qwd;me,r3te;ge;e4i3;nd;en;ol0ui19;cy,ll,n3;secu6t3;e3ima4;llege2rmedia3;te;re;aAe7i6o5u3;ge,m3ng1C;bZid;me0t;gh,l0;a3fYsita2;dy,rXv3;en0y;nd13ppy,r3;d3sh;!y;aFenEhCiBlAoofy,r3;a8e6i5o3ue0Z;o3ss;vy;m,s0;at,e3y;dy,n;nd,y;ad,ib,ooD;a2d1;a3o3;st0;tEuiS;u1y;aDeebCi9l8o6r5u3;ll,n3r0N;!ny;aDesh,iend0;a3nd,rmE;my;at,ir8;erce4nan3;ciA;! ;le;r,ul3;ty;a6erie,sse4v3xtre0A;il;nti3;al;r4s3;tern,y;ly,th0;appYe8i4u3;mb;r5vi4z3;zy;ne;e,ty;a3ep,n9;d3f,r;!ly;agey,h8l7o5r4u3;dd0r0te;isp,uel;ar3ld,mmon,st0ward0zy;se;evKou1;e3il0;ap,e3;sy;aHiFlCoAr5u3;ff,r0sy;ly;a6i3oad;g4llia2;nt;ht;sh,ve;ld,un3;cy;a4o3ue;nd,o1;ck,nd;g,tt3;er;d,ld,w1;dy;bsu6ng5we3;so3;me;ry;rd",
  "Person|Adj": "true¦brown,du2earnest,frank,mi2r0sa1;a0ich,u1;ndy;sty",
  "Modal": "true¦c5lets,m4ought3sh1w0;ill,o5;a0o4;ll,nt;! to,a;ight,ust;an,o0;uld",
  "Verb": "true¦born,cannot,gonna,has,keep tabs,msg",
  "Person|Verb": "true¦b8ch7dr6foster,gra5ja9lan4ma2ni9ollie,p1rob,s0wade;pike,t5ue;at,eg,ier2;ck,r0;k,shal;ce;ce,nt;ew;ase,u1;iff,l1ob,u0;ck;aze,ossom",
  "Person|Place": "true¦a5darw6h3jordan,k2orlando,s0victo7;a0ydney;lvador,mara,ntiago;ent,obe;amil0ous0;ton;lexand1ust0;in;ria",
  "Person|Date": "true¦a2j0sep;an0une;!uary;p0ugust,v0;ril"
};

// ../../node_modules/efrt/src/pack/fns.js
var commonPrefix = function(w1, w2) {
  let len = Math.min(w1.length, w2.length);
  while (len > 0) {
    const prefix5 = w1.slice(0, len);
    if (prefix5 === w2.slice(0, len)) {
      return prefix5;
    }
    len -= 1;
  }
  return "";
};
var unique2 = function(a2) {
  a2.sort();
  for (let i3 = 1; i3 < a2.length; i3++) {
    if (a2[i3 - 1] === a2[i3]) {
      a2.splice(i3, 1);
    }
  }
};
var fns_default = {
  commonPrefix,
  unique: unique2
};

// ../../node_modules/efrt/src/pack/histogram.js
var Histogram = function() {
  this.counts = {};
};
var methods16 = {
  init: function(sym) {
    if (this.counts[sym] === void 0) {
      this.counts[sym] = 0;
    }
  },
  add: function(sym, n3) {
    if (n3 === void 0) {
      n3 = 1;
    }
    this.init(sym);
    this.counts[sym] += n3;
  },
  countOf: function(sym) {
    this.init(sym);
    return this.counts[sym];
  },
  highest: function(top) {
    let sorted = [];
    const keys = Object.keys(this.counts);
    for (let i3 = 0; i3 < keys.length; i3++) {
      const sym = keys[i3];
      sorted.push([sym, this.counts[sym]]);
    }
    sorted.sort(function(a2, b) {
      return b[1] - a2[1];
    });
    if (top) {
      sorted = sorted.slice(0, top);
    }
    return sorted;
  }
};
Object.keys(methods16).forEach(function(k2) {
  Histogram.prototype[k2] = methods16[k2];
});
var histogram_default = Histogram;

// ../../node_modules/efrt/src/encoding.js
var BASE = 36;
var seq = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var cache = seq.split("").reduce(function(h2, c2, i3) {
  h2[c2] = i3;
  return h2;
}, {});
var toAlphaCode = function(n3) {
  if (seq[n3] !== void 0) {
    return seq[n3];
  }
  let places2 = 1;
  let range = BASE;
  let s3 = "";
  for (; n3 >= range; n3 -= range, places2++, range *= BASE) {
  }
  while (places2--) {
    const d2 = n3 % BASE;
    s3 = String.fromCharCode((d2 < 10 ? 48 : 55) + d2) + s3;
    n3 = (n3 - d2) / BASE;
  }
  return s3;
};
var fromAlphaCode = function(s3) {
  if (cache[s3] !== void 0) {
    return cache[s3];
  }
  let n3 = 0;
  let places2 = 1;
  let range = BASE;
  let pow = 1;
  for (; places2 < s3.length; n3 += range, places2++, range *= BASE) {
  }
  for (let i3 = s3.length - 1; i3 >= 0; i3--, pow *= BASE) {
    let d2 = s3.charCodeAt(i3) - 48;
    if (d2 > 10) {
      d2 -= 7;
    }
    n3 += d2 * pow;
  }
  return n3;
};
var encoding_default = {
  toAlphaCode,
  fromAlphaCode
};

// ../../node_modules/efrt/src/pack/pack.js
var config = {
  NODE_SEP: ";",
  KEY_VAL: ":",
  STRING_SEP: ",",
  TERMINAL_PREFIX: "!",
  BASE: 36
};
var nodeLine = function(self2, node) {
  let line = "", sep = "";
  if (self2.isTerminal(node)) {
    line += config.TERMINAL_PREFIX;
  }
  const props = self2.nodeProps(node);
  for (let i3 = 0; i3 < props.length; i3++) {
    const prop = props[i3];
    if (typeof node[prop] === "number") {
      line += sep + prop;
      sep = config.STRING_SEP;
      continue;
    }
    if (self2.syms[node[prop]._n]) {
      line += sep + prop + self2.syms[node[prop]._n];
      sep = "";
      continue;
    }
    let ref = encoding_default.toAlphaCode(node._n - node[prop]._n - 1 + self2.symCount);
    if (node[prop]._g && ref.length >= node[prop]._g.length && node[node[prop]._g] === 1) {
      ref = node[prop]._g;
      line += sep + prop + ref;
      sep = config.STRING_SEP;
      continue;
    }
    line += sep + prop + ref;
    sep = "";
  }
  return line;
};
var analyzeRefs = function(self2, node) {
  if (self2.visited(node)) {
    return;
  }
  const props = self2.nodeProps(node, true);
  for (let i3 = 0; i3 < props.length; i3++) {
    const prop = props[i3];
    const ref = node._n - node[prop]._n - 1;
    if (ref < config.BASE) {
      self2.histRel.add(ref);
    }
    self2.histAbs.add(node[prop]._n, encoding_default.toAlphaCode(ref).length - 1);
    analyzeRefs(self2, node[prop]);
  }
};
var symbolCount = function(self2) {
  self2.histAbs = self2.histAbs.highest(config.BASE);
  const savings = [];
  savings[-1] = 0;
  let best = 0, sCount = 0;
  const defSize = 3 + encoding_default.toAlphaCode(self2.nodeCount).length;
  for (let sym = 0; sym < config.BASE; sym++) {
    if (self2.histAbs[sym] === void 0) {
      break;
    }
    savings[sym] = self2.histAbs[sym][1] - defSize - self2.histRel.countOf(config.BASE - sym - 1) + savings[sym - 1];
    if (savings[sym] >= best) {
      best = savings[sym];
      sCount = sym + 1;
    }
  }
  return sCount;
};
var numberNodes = function(self2, node) {
  if (node._n !== void 0) {
    return;
  }
  const props = self2.nodeProps(node, true);
  for (let i3 = 0; i3 < props.length; i3++) {
    numberNodes(self2, node[props[i3]]);
  }
  node._n = self2.pos++;
  self2.nodes.unshift(node);
};
var pack = function(self2) {
  self2.nodes = [];
  self2.nodeCount = 0;
  self2.syms = {};
  self2.symCount = 0;
  self2.pos = 0;
  self2.optimize();
  self2.histAbs = new histogram_default();
  self2.histRel = new histogram_default();
  numberNodes(self2, self2.root);
  self2.nodeCount = self2.nodes.length;
  self2.prepDFS();
  analyzeRefs(self2, self2.root);
  self2.symCount = symbolCount(self2);
  for (let sym = 0; sym < self2.symCount; sym++) {
    self2.syms[self2.histAbs[sym][0]] = encoding_default.toAlphaCode(sym);
  }
  for (let i3 = 0; i3 < self2.nodeCount; i3++) {
    self2.nodes[i3] = nodeLine(self2, self2.nodes[i3]);
  }
  for (let sym = self2.symCount - 1; sym >= 0; sym--) {
    self2.nodes.unshift(
      encoding_default.toAlphaCode(sym) + config.KEY_VAL + encoding_default.toAlphaCode(self2.nodeCount - self2.histAbs[sym][0] - 1)
    );
  }
  return self2.nodes.join(config.NODE_SEP);
};
var pack_default = pack;

// ../../node_modules/efrt/src/pack/methods.js
var NOT_ALLOWED = new RegExp("[0-9A-Z,;!:|¦]");
var internal = {
  _d: true,
  _v: true,
  _c: true,
  _g: true,
  _n: true
};
var methods17 = {
  // Insert words from one big string, or from an array.
  insertWords: function(words) {
    if (words === void 0) {
      return;
    }
    if (typeof words === "string") {
      words = words.split(/[^a-zA-Z]+/);
    }
    for (let i3 = 0; i3 < words.length; i3++) {
      words[i3] = words[i3].toLowerCase();
    }
    fns_default.unique(words);
    for (let i3 = 0; i3 < words.length; i3++) {
      if (words[i3].match(NOT_ALLOWED) === null) {
        this.insert(words[i3]);
      }
    }
  },
  insert: function(word) {
    this._insert(word, this.root);
    const lastWord = this.lastWord;
    this.lastWord = word;
    const prefix5 = fns_default.commonPrefix(word, lastWord);
    if (prefix5 === lastWord) {
      return;
    }
    const freeze = this.uniqueNode(lastWord, word, this.root);
    if (freeze) {
      this.combineSuffixNode(freeze);
    }
  },
  _insert: function(word, node) {
    let prefix5, next;
    if (word.length === 0) {
      return;
    }
    const keys = Object.keys(node);
    for (let i3 = 0; i3 < keys.length; i3++) {
      const prop = keys[i3];
      prefix5 = fns_default.commonPrefix(word, prop);
      if (prefix5.length === 0) {
        continue;
      }
      if (prop === prefix5 && typeof node[prop] === "object") {
        this._insert(word.slice(prefix5.length), node[prop]);
        return;
      }
      if (prop === word && typeof node[prop] === "number") {
        return;
      }
      next = {};
      next[prop.slice(prefix5.length)] = node[prop];
      this.addTerminal(next, word = word.slice(prefix5.length));
      delete node[prop];
      node[prefix5] = next;
      this.wordCount++;
      return;
    }
    this.addTerminal(node, word);
    this.wordCount++;
  },
  // Add a terminal string to node.
  // If 2 characters or less, just add with value == 1.
  // If more than 2 characters, point to shared node
  // Note - don't prematurely share suffixes - these
  // terminals may become split and joined with other
  // nodes in this part of the tree.
  addTerminal: function(node, prop) {
    if (prop.length <= 1) {
      node[prop] = 1;
      return;
    }
    const next = {};
    node[prop[0]] = next;
    this.addTerminal(next, prop.slice(1));
  },
  // Well ordered list of properties in a node (string or object properties)
  // Use nodesOnly==true to return only properties of child nodes (not
  // terminal strings.
  nodeProps: function(node, nodesOnly) {
    const props = [];
    for (const prop in node) {
      if (prop !== "" && !internal.hasOwnProperty(prop)) {
        if (!nodesOnly || typeof node[prop] === "object") {
          props.push(prop);
        }
      }
    }
    props.sort();
    return props;
  },
  optimize: function() {
    this.combineSuffixNode(this.root);
    this.prepDFS();
    this.countDegree(this.root);
    this.prepDFS();
    this.collapseChains(this.root);
  },
  // Convert Trie to a DAWG by sharing identical nodes
  combineSuffixNode: function(node) {
    if (node._c) {
      return node;
    }
    let sig = [];
    if (this.isTerminal(node)) {
      sig.push("!");
    }
    const props = this.nodeProps(node);
    for (let i3 = 0; i3 < props.length; i3++) {
      const prop = props[i3];
      if (typeof node[prop] === "object") {
        node[prop] = this.combineSuffixNode(node[prop]);
        sig.push(prop);
        sig.push(node[prop]._c);
      } else {
        sig.push(prop);
      }
    }
    sig = sig.join("-");
    const shared = this.suffixes[sig];
    if (shared) {
      return shared;
    }
    this.suffixes[sig] = node;
    node._c = this.cNext++;
    return node;
  },
  prepDFS: function() {
    this.vCur++;
  },
  visited: function(node) {
    if (node._v === this.vCur) {
      return true;
    }
    node._v = this.vCur;
    return false;
  },
  countDegree: function(node) {
    if (node._d === void 0) {
      node._d = 0;
    }
    node._d++;
    if (this.visited(node)) {
      return;
    }
    const props = this.nodeProps(node, true);
    for (let i3 = 0; i3 < props.length; i3++) {
      this.countDegree(node[props[i3]]);
    }
  },
  // Remove intermediate singleton nodes by hoisting into their parent
  collapseChains: function(node) {
    let prop, child, i3;
    if (this.visited(node)) {
      return;
    }
    const props = this.nodeProps(node);
    for (i3 = 0; i3 < props.length; i3++) {
      prop = props[i3];
      child = node[prop];
      if (typeof child !== "object") {
        continue;
      }
      this.collapseChains(child);
      if (child._g !== void 0 && (child._d === 1 || child._g.length === 1)) {
        delete node[prop];
        prop += child._g;
        node[prop] = child[child._g];
      }
    }
    if (props.length === 1 && !this.isTerminal(node)) {
      node._g = prop;
    }
  },
  isTerminal: function(node) {
    return !!node[""];
  },
  // Find highest node in Trie that is on the path to word
  // and that is NOT on the path to other.
  uniqueNode: function(word, other, node) {
    const props = this.nodeProps(node, true);
    for (let i3 = 0; i3 < props.length; i3++) {
      const prop = props[i3];
      if (prop === word.slice(0, prop.length)) {
        if (prop !== other.slice(0, prop.length)) {
          return node[prop];
        }
        return this.uniqueNode(word.slice(prop.length), other.slice(prop.length), node[prop]);
      }
    }
    return void 0;
  },
  pack: function() {
    return pack_default(this);
  }
};
var methods_default9 = methods17;

// ../../node_modules/efrt/src/pack/trie.js
var Trie = function(words) {
  this.root = {};
  this.lastWord = "";
  this.suffixes = {};
  this.suffixCounts = {};
  this.cNext = 1;
  this.wordCount = 0;
  this.insertWords(words);
  this.vCur = 0;
};
Object.keys(methods_default9).forEach(function(k2) {
  Trie.prototype[k2] = methods_default9[k2];
});

// ../../node_modules/efrt/src/unpack/symbols.js
var symbols = function(t3) {
  const reSymbol = new RegExp("([0-9A-Z]+):([0-9A-Z]+)");
  for (let i3 = 0; i3 < t3.nodes.length; i3++) {
    const m3 = reSymbol.exec(t3.nodes[i3]);
    if (!m3) {
      t3.symCount = i3;
      break;
    }
    t3.syms[encoding_default.fromAlphaCode(m3[1])] = encoding_default.fromAlphaCode(m3[2]);
  }
  t3.nodes = t3.nodes.slice(t3.symCount, t3.nodes.length);
};
var symbols_default = symbols;

// ../../node_modules/efrt/src/unpack/traverse.js
var indexFromRef = function(trie, ref, index3) {
  const dnode = encoding_default.fromAlphaCode(ref);
  if (dnode < trie.symCount) {
    return trie.syms[dnode];
  }
  return index3 + dnode + 1 - trie.symCount;
};
var toArray = function(trie) {
  const all4 = [];
  const crawl = (index3, pref) => {
    let node = trie.nodes[index3];
    if (node[0] === "!") {
      all4.push(pref);
      node = node.slice(1);
    }
    const matches3 = node.split(/([A-Z0-9,]+)/g);
    for (let i3 = 0; i3 < matches3.length; i3 += 2) {
      const str = matches3[i3];
      const ref = matches3[i3 + 1];
      if (!str) {
        continue;
      }
      const have = pref + str;
      if (ref === "," || ref === void 0) {
        all4.push(have);
        continue;
      }
      const newIndex = indexFromRef(trie, ref, index3);
      crawl(newIndex, have);
    }
  };
  crawl(0, "");
  return all4;
};
var unpack = function(str) {
  const trie = {
    nodes: str.split(";"),
    syms: [],
    symCount: 0
  };
  if (str.match(":")) {
    symbols_default(trie);
  }
  return toArray(trie);
};
var traverse_default = unpack;

// ../../node_modules/efrt/src/unpack/index.js
var unpack2 = function(str) {
  if (!str) {
    return {};
  }
  const obj = str.split("|").reduce((h2, s3) => {
    const arr = s3.split("¦");
    h2[arr[0]] = arr[1];
    return h2;
  }, {});
  const all4 = {};
  Object.keys(obj).forEach(function(cat) {
    const arr = traverse_default(obj[cat]);
    if (cat === "true") {
      cat = true;
    }
    for (let i3 = 0; i3 < arr.length; i3++) {
      const k2 = arr[i3];
      if (all4.hasOwnProperty(k2) === true) {
        if (Array.isArray(all4[k2]) === false) {
          all4[k2] = [all4[k2], cat];
        } else {
          all4[k2].push(cat);
        }
      } else {
        all4[k2] = cat;
      }
    }
  });
  return all4;
};
var unpack_default = unpack2;

// ../../node_modules/compromise/src/2-two/preTagger/model/lexicon/misc.js
var prp = ["Possessive", "Pronoun"];
var misc = {
  // numbers
  "20th century fox": "Organization",
  "7 eleven": "Organization",
  "motel 6": "Organization",
  g8: "Organization",
  vh1: "Organization",
  "km2": "Unit",
  "m2": "Unit",
  "dm2": "Unit",
  "cm2": "Unit",
  "mm2": "Unit",
  "mile2": "Unit",
  "in2": "Unit",
  "yd2": "Unit",
  "ft2": "Unit",
  "m3": "Unit",
  "dm3": "Unit",
  "cm3": "Unit",
  "in3": "Unit",
  "ft3": "Unit",
  "yd3": "Unit",
  // ampersands
  "at&t": "Organization",
  "black & decker": "Organization",
  "h & m": "Organization",
  "johnson & johnson": "Organization",
  "procter & gamble": "Organization",
  "ben & jerry's": "Organization",
  "&": "Conjunction",
  //pronouns
  i: ["Pronoun", "Singular"],
  he: ["Pronoun", "Singular"],
  she: ["Pronoun", "Singular"],
  it: ["Pronoun", "Singular"],
  they: ["Pronoun", "Plural"],
  we: ["Pronoun", "Plural"],
  was: ["Copula", "PastTense"],
  is: ["Copula", "PresentTense"],
  are: ["Copula", "PresentTense"],
  am: ["Copula", "PresentTense"],
  were: ["Copula", "PastTense"],
  // possessive pronouns
  her: prp,
  his: prp,
  hers: prp,
  their: prp,
  theirs: prp,
  themselves: prp,
  your: prp,
  our: prp,
  ours: prp,
  my: prp,
  its: prp,
  // misc
  vs: ["Conjunction", "Abbreviation"],
  if: ["Condition", "Preposition"],
  closer: "Comparative",
  closest: "Superlative",
  much: "Adverb",
  may: "Modal",
  // irregular conjugations with two forms
  babysat: "PastTense",
  blew: "PastTense",
  drank: "PastTense",
  drove: "PastTense",
  forgave: "PastTense",
  skiied: "PastTense",
  spilt: "PastTense",
  stung: "PastTense",
  swam: "PastTense",
  swung: "PastTense",
  guaranteed: "PastTense",
  shrunk: "PastTense",
  // support 'near', 'nears', 'nearing'
  nears: "PresentTense",
  nearing: "Gerund",
  neared: "PastTense",
  no: ["Negative", "Expression"]
  // there: 'There'
};
var misc_default2 = misc;

// ../../node_modules/compromise/src/2-two/preTagger/model/lexicon/emoticons.js
var emoticons_default = [
  ":(",
  ":)",
  ":P",
  ":p",
  ":O",
  ";(",
  ";)",
  ";P",
  ";p",
  ";O",
  ":3",
  ":|",
  ":/",
  ":\\",
  ":$",
  ":*",
  ":@",
  ":-(",
  ":-)",
  ":-P",
  ":-p",
  ":-O",
  ":-3",
  ":-|",
  ":-/",
  ":-\\",
  ":-$",
  ":-*",
  ":-@",
  ":^(",
  ":^)",
  ":^P",
  ":^p",
  ":^O",
  ":^3",
  ":^|",
  ":^/",
  ":^\\",
  ":^$",
  ":^*",
  ":^@",
  "):",
  "(:",
  "$:",
  "*:",
  ")-:",
  "(-:",
  "$-:",
  "*-:",
  ")^:",
  "(^:",
  "$^:",
  "*^:",
  "<3",
  "</3",
  "<\\3",
  "=("
];

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toPlural/_rules.js
var suffixes = {
  a: [
    [/(antenn|formul|nebul|vertebr|vit)a$/i, "$1ae"],
    [/ia$/i, "ia"]
  ],
  e: [
    [/(kn|l|w)ife$/i, "$1ives"],
    [/(hive)$/i, "$1s"],
    [/([m|l])ouse$/i, "$1ice"],
    [/([m|l])ice$/i, "$1ice"]
  ],
  f: [
    [/^(dwar|handkerchie|hoo|scar|whar)f$/i, "$1ves"],
    [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)f$/i, "$1ves"]
  ],
  i: [[/(octop|vir)i$/i, "$1i"]],
  m: [[/([ti])um$/i, "$1a"]],
  n: [[/^(oxen)$/i, "$1"]],
  o: [[/(al|ad|at|er|et|ed)o$/i, "$1oes"]],
  s: [
    [/(ax|test)is$/i, "$1es"],
    [/(alias|status)$/i, "$1es"],
    [/sis$/i, "ses"],
    [/(bu)s$/i, "$1ses"],
    [/(sis)$/i, "ses"],
    [/^(?!talis|.*hu)(.*)man$/i, "$1men"],
    [/(octop|vir|radi|nucle|fung|cact|stimul)us$/i, "$1i"]
  ],
  x: [
    [/(matr|vert|ind|cort)(ix|ex)$/i, "$1ices"],
    [/^(ox)$/i, "$1en"]
  ],
  y: [[/([^aeiouy]|qu)y$/i, "$1ies"]],
  z: [[/(quiz)$/i, "$1zes"]]
};
var rules_default = suffixes;

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toPlural/index.js
var addE = /([xsz]|ch|sh)$/;
var trySuffix = function(str) {
  let c2 = str[str.length - 1];
  if (rules_default.hasOwnProperty(c2) === true) {
    for (let i3 = 0; i3 < rules_default[c2].length; i3 += 1) {
      let reg = rules_default[c2][i3][0];
      if (reg.test(str) === true) {
        return str.replace(reg, rules_default[c2][i3][1]);
      }
    }
  }
  return null;
};
var pluralize = function(str = "", model5) {
  let { irregularPlurals, uncountable: uncountable2 } = model5.two;
  if (uncountable2.hasOwnProperty(str)) {
    return str;
  }
  if (irregularPlurals.hasOwnProperty(str)) {
    return irregularPlurals[str];
  }
  let plural2 = trySuffix(str);
  if (plural2 !== null) {
    return plural2;
  }
  if (addE.test(str)) {
    return str + "es";
  }
  return str + "s";
};
var toPlural_default = pluralize;

// ../../node_modules/compromise/src/2-two/preTagger/model/lexicon/index.js
var hasSwitch = /\|/;
var lexicon3 = misc_default2;
var switches = {};
var tmpModel = { two: { irregularPlurals: plurals_default, uncountable: {} } };
Object.keys(data_default).forEach((tag) => {
  let wordsObj = unpack_default(data_default[tag]);
  if (!hasSwitch.test(tag)) {
    Object.keys(wordsObj).forEach((w) => {
      lexicon3[w] = tag;
    });
    return;
  }
  Object.keys(wordsObj).forEach((w) => {
    switches[w] = tag;
    if (tag === "Noun|Verb") {
      let plural2 = toPlural_default(w, tmpModel);
      switches[plural2] = "Plural|Verb";
    }
  });
});
emoticons_default.forEach((str) => lexicon3[str] = "Emoticon");
delete lexicon3[""];
delete lexicon3[null];
delete lexicon3[" "];

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/_noun.js
var n2 = "Singular";
var noun_default = {
  beforeTags: {
    Determiner: n2,
    //the date
    Possessive: n2,
    //his date
    Acronym: n2,
    //u.s. state
    // ProperNoun:n,
    Noun: n2,
    //nasa funding
    Adjective: n2,
    //whole bottles
    // Verb:true, //save storm victims
    PresentTense: n2,
    //loves hiking
    Gerund: n2,
    //uplifting victims
    PastTense: n2,
    //saved storm victims
    Infinitive: n2,
    //profess love
    Date: n2,
    //9pm show
    Ordinal: n2,
    //first date
    Demonym: n2
    //dutch map
  },
  afterTags: {
    Value: n2,
    //date nine  -?
    Modal: n2,
    //date would
    Copula: n2,
    //fear is
    PresentTense: n2,
    //babysitting sucks
    PastTense: n2,
    //babysitting sucked
    // Noun:n, //talking therapy, planning process
    Demonym: n2,
    //american touch
    Actor: n2
    //dance therapist
  },
  // ownTags: { ProperNoun: n },
  beforeWords: {
    the: n2,
    //the brands
    with: n2,
    //with cakes
    without: n2,
    //
    // was:n, //was time  -- was working
    // is:n, //
    of: n2,
    //of power
    for: n2,
    //for rats
    any: n2,
    //any rats
    all: n2,
    //all tips
    on: n2,
    //on time
    // thing-ish verbs
    cut: n2,
    //cut spending
    cuts: n2,
    //cut spending
    increase: n2,
    // increase funding
    decrease: n2,
    //
    raise: n2,
    // 
    drop: n2,
    //
    // give: n,//give parents
    save: n2,
    //
    saved: n2,
    //
    saves: n2,
    //
    make: n2,
    //
    makes: n2,
    //
    made: n2,
    //
    minus: n2,
    //minus laughing
    plus: n2,
    //
    than: n2,
    //more than age
    another: n2,
    //
    versus: n2,
    //
    neither: n2,
    //
    about: n2,
    //about claims
    // strong adjectives
    favorite: n2,
    //
    best: n2,
    //
    daily: n2,
    //
    weekly: n2,
    //
    linear: n2,
    //
    binary: n2,
    //
    mobile: n2,
    //
    lexical: n2,
    //
    technical: n2,
    //
    computer: n2,
    //
    scientific: n2,
    //
    security: n2,
    //
    government: n2,
    //
    popular: n2,
    //
    formal: n2,
    no: n2,
    //no worries
    more: n2,
    //more details
    one: n2,
    //one flood
    let: n2,
    //let fear
    her: n2,
    //her boots
    his: n2,
    //
    their: n2,
    //
    our: n2,
    //
    us: n2
    //served us drinks
  },
  afterWords: {
    of: n2,
    //date of birth (preposition)
    system: n2,
    aid: n2,
    method: n2,
    utility: n2,
    tool: n2,
    reform: n2,
    therapy: n2,
    philosophy: n2,
    room: n2,
    authority: n2,
    says: n2,
    said: n2,
    wants: n2,
    wanted: n2,
    is: n2,
    did: n2,
    do: n2,
    can: n2,
    //parents can
    wise: n2
    //service-wise
    // they: n,//snakes they
  }
};

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/_verb.js
var v = "Infinitive";
var verb_default = {
  beforeTags: {
    Modal: v,
    //would date
    Adverb: v,
    //quickly date
    Negative: v,
    //not date
    Plural: v
    //characters drink
    // ProperNoun: vb,//google thought
  },
  afterTags: {
    Determiner: v,
    //flash the
    Adverb: v,
    //date quickly
    Possessive: v,
    //date his
    Reflexive: v,
    //resolve yourself
    // Noun:true, //date spencer
    Preposition: v,
    //date around, dump onto, grumble about
    // Conjunction: v, // dip to, dip through
    Cardinal: v,
    //cut 3 squares
    Comparative: v,
    //feel greater
    Superlative: v
    //feel greatest
  },
  beforeWords: {
    i: v,
    //i date
    we: v,
    //we date
    you: v,
    //you date
    they: v,
    //they date
    to: v,
    //to date
    please: v,
    //please check
    will: v,
    //will check
    have: v,
    had: v,
    would: v,
    could: v,
    should: v,
    do: v,
    did: v,
    does: v,
    can: v,
    must: v,
    us: v,
    me: v,
    let: v,
    even: v,
    when: v,
    help: v,
    //help combat
    // them: v,
    he: v,
    she: v,
    it: v,
    being: v,
    // prefixes
    bi: v,
    co: v,
    contra: v,
    de: v,
    inter: v,
    intra: v,
    mis: v,
    pre: v,
    out: v,
    counter: v,
    nobody: v,
    somebody: v,
    anybody: v,
    everybody: v
    // un: v,
    // over: v,
    // under: v,
  },
  afterWords: {
    the: v,
    //echo the
    me: v,
    //date me
    you: v,
    //date you
    him: v,
    //loves him
    us: v,
    //cost us
    her: v,
    //
    his: v,
    //
    them: v,
    //
    they: v,
    //
    it: v,
    //hope it
    himself: v,
    herself: v,
    itself: v,
    myself: v,
    ourselves: v,
    themselves: v,
    something: v,
    anything: v,
    a: v,
    //covers a
    an: v,
    //covers an
    // from: v, //ranges from
    up: v,
    //serves up
    down: v,
    //serves up
    by: v,
    // in: v, //bob in
    out: v,
    // on: v,
    off: v,
    under: v,
    what: v,
    //look what
    // when: v,//starts when
    // for:true, //settled for
    all: v,
    //shiver all night
    // conjunctions
    to: v,
    //dip to
    because: v,
    //
    although: v,
    //
    after: v,
    before: v,
    //
    how: v,
    //
    otherwise: v,
    //
    together: v,
    //fit together
    though: v,
    //
    into: v,
    //
    yet: v,
    //
    more: v,
    //kill more
    here: v,
    // look here
    there: v,
    //
    away: v
    //float away
  }
};

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/actor-verb.js
var clue = {
  beforeTags: Object.assign({}, verb_default.beforeTags, noun_default.beforeTags, {}),
  afterTags: Object.assign({}, verb_default.afterTags, noun_default.afterTags, {}),
  beforeWords: Object.assign({}, verb_default.beforeWords, noun_default.beforeWords, {}),
  afterWords: Object.assign({}, verb_default.afterWords, noun_default.afterWords, {})
};
var actor_verb_default = clue;

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/_adj.js
var jj = "Adjective";
var adj_default = {
  beforeTags: {
    Determiner: jj,
    //the detailed
    // Copula: jj, //is detailed
    Possessive: jj,
    //spencer's detailed
    Hyphenated: jj
    //rapidly-changing
  },
  afterTags: {
    // Noun: jj, //detailed plan, overwhelming evidence
    Adjective: jj
    //intoxicated little
  },
  beforeWords: {
    seem: jj,
    //seem prepared
    seemed: jj,
    seems: jj,
    feel: jj,
    //feel prepared
    feels: jj,
    felt: jj,
    stay: jj,
    appear: jj,
    appears: jj,
    appeared: jj,
    also: jj,
    over: jj,
    //over cooked
    under: jj,
    too: jj,
    //too insulting
    it: jj,
    //find it insulting
    but: jj,
    //nothing but frustrating
    still: jj,
    //still scared
    // adverbs that are adjective-ish
    really: jj,
    //really damaged
    quite: jj,
    well: jj,
    very: jj,
    how: jj,
    //how slow
    deeply: jj,
    hella: jj,
    // always: jj,
    // never: jj,
    profoundly: jj,
    extremely: jj,
    so: jj,
    badly: jj,
    mostly: jj,
    totally: jj,
    awfully: jj,
    rather: jj,
    nothing: jj,
    //nothing secret, 
    something: jj,
    //something wrong
    anything: jj,
    not: jj,
    //not swell
    me: jj,
    //called me swell
    is: jj
  },
  afterWords: {
    too: jj,
    //insulting too
    also: jj,
    //insulting too
    or: jj,
    //insulting or
    enough: jj,
    //cool enough
    about: jj
    //cool about
  }
};

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/_gerund.js
var g2 = "Gerund";
var gerund_default = {
  beforeTags: {
    // Verb: g, // loves shocking
    Adverb: g2,
    //quickly shocking
    Preposition: g2,
    //by insulting
    Conjunction: g2
    //to insulting
  },
  afterTags: {
    Adverb: g2,
    //shocking quickly
    Possessive: g2,
    //shocking spencer's
    Person: g2,
    //telling spencer
    Pronoun: g2,
    //shocking him
    Determiner: g2,
    //shocking the
    Copula: g2,
    //shocking is
    Preposition: g2,
    //dashing by, swimming in
    Conjunction: g2,
    //insulting to
    Comparative: g2
    //growing shorter
  },
  beforeWords: {
    been: g2,
    keep: g2,
    //keep going
    continue: g2,
    //
    stop: g2,
    //
    am: g2,
    //am watching
    be: g2,
    //be timing
    me: g2,
    //got me thinking
    // action-words
    began: g2,
    start: g2,
    starts: g2,
    started: g2,
    stops: g2,
    stopped: g2,
    help: g2,
    helps: g2,
    avoid: g2,
    avoids: g2,
    love: g2,
    //love painting
    loves: g2,
    loved: g2,
    hate: g2,
    hates: g2,
    hated: g2
    // was:g,//was working
    // is:g,
    // be:g,
  },
  afterWords: {
    you: g2,
    //telling you
    me: g2,
    //
    her: g2,
    //
    him: g2,
    //
    his: g2,
    //
    them: g2,
    //
    their: g2,
    // fighting their
    it: g2,
    //dumping it
    this: g2,
    //running this
    there: g2,
    // swimming there
    on: g2,
    // landing on
    about: g2,
    // talking about
    for: g2,
    // paying for
    up: g2,
    //speeding up
    down: g2
    //
  }
};

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/adj-gerund.js
var clue2 = {
  beforeTags: Object.assign({}, adj_default.beforeTags, gerund_default.beforeTags, {
    // Copula: 'Adjective', 
    Imperative: "Gerund",
    //recommend living in
    Infinitive: "Adjective",
    //say charming things
    PresentTense: "Gerund",
    Plural: "Gerund"
    //kids cutting
  }),
  afterTags: Object.assign({}, adj_default.afterTags, gerund_default.afterTags, {
    Singular: "Adjective"
    //shocking ignorance
  }),
  beforeWords: Object.assign({}, adj_default.beforeWords, gerund_default.beforeWords, {
    is: "Adjective",
    was: "Adjective",
    of: "Adjective",
    //of varying
    suggest: "Gerund",
    recommend: "Gerund"
  }),
  afterWords: Object.assign({}, adj_default.afterWords, gerund_default.afterWords, {
    to: "Gerund",
    not: "Gerund",
    //trying not to car
    the: "Gerund"
    //sweeping the country
  })
};
var adj_gerund_default = clue2;

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/adj-noun.js
var misc2 = {
  beforeTags: {
    Determiner: void 0,
    //the premier university
    Cardinal: "Noun",
    //1950 convertable
    PhrasalVerb: "Adjective"
    //starts out fine
  },
  afterTags: {
    // Pronoun: 'Noun'//as an adult i
  }
};
var clue3 = {
  beforeTags: Object.assign({}, adj_default.beforeTags, noun_default.beforeTags, misc2.beforeTags),
  afterTags: Object.assign({}, adj_default.afterTags, noun_default.afterTags, misc2.afterTags),
  beforeWords: Object.assign({}, adj_default.beforeWords, noun_default.beforeWords, {
    // are representative
    are: "Adjective",
    is: "Adjective",
    was: "Adjective",
    be: "Adjective",
    // phrasals
    off: "Adjective",
    //start off fine
    out: "Adjective"
    //comes out fine
  }),
  afterWords: Object.assign({}, adj_default.afterWords, noun_default.afterWords)
};
var adj_noun_default = clue3;

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/adj-past.js
var past = "PastTense";
var adjPast = {
  beforeTags: {
    Adverb: past,
    //quickly detailed
    Pronoun: past,
    //he detailed
    ProperNoun: past,
    //toronto closed
    Auxiliary: past,
    Noun: past
    //eye closed  -- i guess.
  },
  afterTags: {
    Possessive: past,
    //hooked him
    Pronoun: past,
    //hooked me
    Determiner: past,
    //hooked the
    Adverb: past,
    //cooked perfectly
    Comparative: past,
    //closed higher
    Date: past,
    // alleged thursday
    Gerund: past
    //left dancing
  },
  beforeWords: {
    be: past,
    //be hooked vs be embarrassed
    who: past,
    //who lost
    get: "Adjective",
    //get charged
    had: past,
    has: past,
    have: past,
    been: past,
    it: past,
    //it intoxicated him
    as: past,
    //as requested
    for: "Adjective",
    //for discounted items
    more: "Adjective"
    //more broken promises
  },
  afterWords: {
    by: past,
    //damaged by
    back: past,
    //charged back
    out: past,
    //charged out
    in: past,
    //crowded in
    up: past,
    //heated up
    down: past,
    //hammered down
    before: past,
    //
    after: past,
    //
    for: past,
    //settled for
    the: past,
    //settled the
    with: past,
    //obsessed with
    as: past,
    //known as
    on: past,
    //focused on
    at: past,
    //recorded at
    between: past,
    //settled between
    to: past,
    //dedicated to
    into: past,
    //pumped into
    us: past,
    //charged us
    them: past,
    //charged us
    his: past,
    //shared his
    her: past,
    //
    their: past,
    //
    our: past,
    //
    me: past
    //
  }
};
var adj_past_default = {
  beforeTags: Object.assign({}, adj_default.beforeTags, adjPast.beforeTags),
  afterTags: Object.assign({}, adj_default.afterTags, adjPast.afterTags),
  beforeWords: Object.assign({}, adj_default.beforeWords, adjPast.beforeWords),
  afterWords: Object.assign({}, adj_default.afterWords, adjPast.afterWords)
};

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/adj-present.js
var misc3 = {
  afterTags: {
    Noun: "Adjective",
    //ruling party
    Conjunction: void 0
    //clean and excellent
  }
};
var clue4 = {
  beforeTags: Object.assign({}, adj_default.beforeTags, verb_default.beforeTags, {
    // always clean
    Adverb: void 0,
    Negative: void 0
  }),
  afterTags: Object.assign({}, adj_default.afterTags, verb_default.afterTags, misc3.afterTags),
  beforeWords: Object.assign({}, adj_default.beforeWords, verb_default.beforeWords, {
    // have seperate contracts
    have: void 0,
    had: void 0,
    not: void 0,
    //went wrong, got wrong
    went: "Adjective",
    goes: "Adjective",
    got: "Adjective",
    // be sure
    be: "Adjective"
  }),
  afterWords: Object.assign({}, adj_default.afterWords, verb_default.afterWords, {
    to: void 0,
    //slick to the touch
    as: "Adjective"
    //pale as
  })
};
var adj_present_default = clue4;

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/noun-gerund.js
var misc4 = {
  beforeTags: {
    Copula: "Gerund",
    PastTense: "Gerund",
    PresentTense: "Gerund",
    Infinitive: "Gerund"
  },
  afterTags: {},
  beforeWords: {
    are: "Gerund",
    were: "Gerund",
    be: "Gerund",
    no: "Gerund",
    without: "Gerund",
    //are you playing
    you: "Gerund",
    we: "Gerund",
    they: "Gerund",
    he: "Gerund",
    she: "Gerund",
    //stop us playing
    us: "Gerund",
    them: "Gerund"
  },
  afterWords: {
    // offering the
    the: "Gerund",
    this: "Gerund",
    that: "Gerund",
    //got me thinking
    me: "Gerund",
    us: "Gerund",
    them: "Gerund"
  }
};
var clue5 = {
  beforeTags: Object.assign({}, gerund_default.beforeTags, noun_default.beforeTags, misc4.beforeTags),
  afterTags: Object.assign({}, gerund_default.afterTags, noun_default.afterTags, misc4.afterTags),
  beforeWords: Object.assign({}, gerund_default.beforeWords, noun_default.beforeWords, misc4.beforeWords),
  afterWords: Object.assign({}, gerund_default.afterWords, noun_default.afterWords, misc4.afterWords)
};
var noun_gerund_default = clue5;

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/noun-verb.js
var nn = "Singular";
var vb = "Infinitive";
var clue6 = {
  beforeTags: Object.assign({}, verb_default.beforeTags, noun_default.beforeTags, {
    // Noun: undefined
    Adjective: nn,
    //great name
    Particle: nn
    //brought under control
  }),
  afterTags: Object.assign({}, verb_default.afterTags, noun_default.afterTags, {
    ProperNoun: vb,
    Gerund: vb,
    Adjective: vb,
    Copula: nn
  }),
  beforeWords: Object.assign({}, verb_default.beforeWords, noun_default.beforeWords, {
    // is time
    is: nn,
    was: nn,
    //balance of power
    of: nn,
    have: null
    //have cash
  }),
  afterWords: Object.assign({}, verb_default.afterWords, noun_default.afterWords, {
    // for: vb,//work for
    instead: vb,
    // that: nn,//subject that was
    // for: vb,//work for
    about: vb,
    //talk about
    his: vb,
    //shot his
    her: vb,
    //
    to: null,
    by: null,
    in: null
  })
};
var noun_verb_default = clue6;

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/_person.js
var p2 = "Person";
var person_default = {
  beforeTags: {
    Honorific: p2,
    Person: p2
    // Preposition: p, //with sue
  },
  afterTags: {
    Person: p2,
    ProperNoun: p2,
    Verb: p2
    //bob could
    // Modal:true, //bob could
    // Copula:true, //bob is
    // PresentTense:true, //bob seems
  },
  ownTags: {
    ProperNoun: p2
    //capital letter
  },
  beforeWords: {
    hi: p2,
    hey: p2,
    yo: p2,
    dear: p2,
    hello: p2
  },
  afterWords: {
    // person-usually verbs
    said: p2,
    says: p2,
    told: p2,
    tells: p2,
    feels: p2,
    felt: p2,
    seems: p2,
    thinks: p2,
    thought: p2,
    spends: p2,
    spendt: p2,
    plays: p2,
    played: p2,
    sing: p2,
    sang: p2,
    learn: p2,
    learned: p2,
    wants: p2,
    wanted: p2
    // and:true, //sue and jeff
  }
};

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/person-date.js
var m = "Month";
var p3 = "Person";
var month = {
  beforeTags: {
    Date: m,
    Value: m
  },
  afterTags: {
    Date: m,
    Value: m
  },
  beforeWords: {
    by: m,
    in: m,
    on: m,
    during: m,
    after: m,
    before: m,
    between: m,
    until: m,
    til: m,
    sometime: m,
    of: m,
    //5th of april
    this: m,
    //this april
    next: m,
    last: m,
    previous: m,
    following: m,
    with: p3
    // for: p,
  },
  afterWords: {
    sometime: m,
    in: m,
    of: m,
    until: m,
    the: m
    //june the 4th
  }
};
var person_date_default = {
  beforeTags: Object.assign({}, person_default.beforeTags, month.beforeTags),
  afterTags: Object.assign({}, person_default.afterTags, month.afterTags),
  beforeWords: Object.assign({}, person_default.beforeWords, month.beforeWords),
  afterWords: Object.assign({}, person_default.afterWords, month.afterWords)
};

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/person-noun.js
var clue7 = {
  beforeTags: Object.assign({}, noun_default.beforeTags, person_default.beforeTags),
  afterTags: Object.assign({}, noun_default.afterTags, person_default.afterTags),
  beforeWords: Object.assign({}, noun_default.beforeWords, person_default.beforeWords, { i: "Infinitive", we: "Infinitive" }),
  afterWords: Object.assign({}, noun_default.afterWords, person_default.afterWords)
};
var person_noun_default = clue7;

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/person-verb.js
var clues = {
  beforeTags: Object.assign({}, noun_default.beforeTags, person_default.beforeTags, verb_default.beforeTags),
  afterTags: Object.assign({}, noun_default.afterTags, person_default.afterTags, verb_default.afterTags),
  beforeWords: Object.assign({}, noun_default.beforeWords, person_default.beforeWords, verb_default.beforeWords),
  afterWords: Object.assign({}, noun_default.afterWords, person_default.afterWords, verb_default.afterWords)
};
var person_verb_default = clues;

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/person-place.js
var p4 = "Place";
var place = {
  beforeTags: {
    Place: p4
  },
  afterTags: {
    Place: p4,
    Abbreviation: p4
  },
  beforeWords: {
    in: p4,
    by: p4,
    near: p4,
    from: p4,
    to: p4
  },
  afterWords: {
    in: p4,
    by: p4,
    near: p4,
    from: p4,
    to: p4,
    government: p4,
    council: p4,
    region: p4,
    city: p4
  }
};
var clue8 = {
  beforeTags: Object.assign({}, place.beforeTags, person_default.beforeTags),
  afterTags: Object.assign({}, place.afterTags, person_default.afterTags),
  beforeWords: Object.assign({}, place.beforeWords, person_default.beforeWords),
  afterWords: Object.assign({}, place.afterWords, person_default.afterWords)
};
var person_place_default = clue8;

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/person-adj.js
var clues2 = {
  beforeTags: Object.assign({}, person_default.beforeTags, adj_default.beforeTags),
  afterTags: Object.assign({}, person_default.afterTags, adj_default.afterTags),
  beforeWords: Object.assign({}, person_default.beforeWords, adj_default.beforeWords),
  afterWords: Object.assign({}, person_default.afterWords, adj_default.afterWords)
};
var person_adj_default = clues2;

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/unit-noun.js
var un = "Unit";
var clues3 = {
  beforeTags: { Value: un },
  afterTags: {},
  beforeWords: {
    per: un,
    every: un,
    each: un,
    square: un,
    //square km
    cubic: un,
    sq: un,
    metric: un
    //metric ton
  },
  afterWords: {
    per: un,
    squared: un,
    cubed: un,
    long: un
    //foot long
  }
};
var unit_noun_default = clues3;

// ../../node_modules/compromise/src/2-two/preTagger/model/clues/index.js
var clues4 = {
  "Actor|Verb": actor_verb_default,
  "Adj|Gerund": adj_gerund_default,
  "Adj|Noun": adj_noun_default,
  "Adj|Past": adj_past_default,
  "Adj|Present": adj_present_default,
  "Noun|Verb": noun_verb_default,
  "Noun|Gerund": noun_gerund_default,
  "Person|Noun": person_noun_default,
  "Person|Date": person_date_default,
  "Person|Verb": person_verb_default,
  "Person|Place": person_place_default,
  "Person|Adj": person_adj_default,
  "Unit|Noun": unit_noun_default
};
var copy = (obj, more) => {
  let res = Object.keys(obj).reduce((h2, k2) => {
    h2[k2] = obj[k2] === "Infinitive" ? "PresentTense" : "Plural";
    return h2;
  }, {});
  return Object.assign(res, more);
};
clues4["Plural|Verb"] = {
  beforeWords: copy(clues4["Noun|Verb"].beforeWords, {
    had: "Plural",
    //had tears
    have: "Plural"
  }),
  afterWords: copy(clues4["Noun|Verb"].afterWords, {
    his: "PresentTense",
    her: "PresentTense",
    its: "PresentTense",
    in: null,
    to: null,
    is: "PresentTense",
    //the way it works is
    by: "PresentTense"
    //it works by
  }),
  beforeTags: copy(clues4["Noun|Verb"].beforeTags, {
    Conjunction: "PresentTense",
    //and changes
    Noun: void 0,
    //the century demands
    ProperNoun: "PresentTense"
    //john plays
  }),
  afterTags: copy(clues4["Noun|Verb"].afterTags, {
    Gerund: "Plural",
    //ice caps disappearing
    Noun: "PresentTense",
    //changes gears
    Value: "PresentTense"
    //changes seven gears
  })
};
var clues_default = clues4;

// ../../node_modules/compromise/src/2-two/preTagger/model/patterns/suffixes.js
var Adj = "Adjective";
var Inf = "Infinitive";
var Pres = "PresentTense";
var Sing = "Singular";
var Past = "PastTense";
var Avb = "Adverb";
var Plrl = "Plural";
var Actor = "Actor";
var Vb = "Verb";
var Noun = "Noun";
var Last = "LastName";
var Modal = "Modal";
var Place = "Place";
var Prt = "Participle";
var suffixes_default2 = [
  null,
  null,
  {
    //2-letter
    ea: Sing,
    ia: Noun,
    ic: Adj,
    ly: Avb,
    "'n": Vb,
    "'t": Vb
  },
  {
    //3-letter
    oed: Past,
    ued: Past,
    xed: Past,
    " so": Avb,
    "'ll": Modal,
    "'re": "Copula",
    azy: Adj,
    eer: Noun,
    end: Vb,
    ped: Past,
    ffy: Adj,
    ify: Inf,
    ing: "Gerund",
    ize: Inf,
    ibe: Inf,
    lar: Adj,
    mum: Adj,
    nes: Pres,
    nny: Adj,
    // oid: Adj,
    ous: Adj,
    que: Adj,
    ger: Noun,
    ber: Noun,
    rol: Sing,
    sis: Sing,
    ogy: Sing,
    oid: Sing,
    ian: Sing,
    zes: Pres,
    eld: Past,
    ken: Prt,
    //awoken
    ven: Prt,
    //woven
    ten: Prt,
    //brighten
    ect: Inf,
    ict: Inf,
    // ide: Inf,
    ign: Inf,
    oze: Inf,
    ful: Adj,
    bal: Adj,
    ton: Noun
  },
  {
    //4-letter
    amed: Past,
    aped: Past,
    ched: Past,
    lked: Past,
    rked: Past,
    reed: Past,
    nded: Past,
    mned: Adj,
    cted: Past,
    dged: Past,
    ield: Sing,
    akis: Last,
    cede: Inf,
    chuk: Last,
    czyk: Last,
    ects: Pres,
    iend: Sing,
    ends: Vb,
    enko: Last,
    ette: Sing,
    iary: Sing,
    wner: Sing,
    //owner
    fies: Pres,
    fore: Avb,
    gate: Inf,
    gone: Adj,
    ices: Plrl,
    ints: Plrl,
    ruct: Inf,
    ines: Plrl,
    ions: Plrl,
    ners: Plrl,
    pers: Plrl,
    lers: Plrl,
    less: Adj,
    llen: Adj,
    made: Adj,
    nsen: Last,
    oses: Pres,
    ould: Modal,
    some: Adj,
    sson: Last,
    ians: Plrl,
    // tage: Inf,
    tion: Sing,
    tage: Noun,
    ique: Sing,
    tive: Adj,
    tors: Noun,
    vice: Sing,
    lier: Sing,
    fier: Sing,
    wned: Past,
    gent: Sing,
    tist: Actor,
    pist: Actor,
    rist: Actor,
    mist: Actor,
    yist: Actor,
    vist: Actor,
    ists: Actor,
    lite: Sing,
    site: Sing,
    rite: Sing,
    mite: Sing,
    bite: Sing,
    mate: Sing,
    date: Sing,
    ndal: Sing,
    vent: Sing,
    uist: Actor,
    gist: Actor,
    note: Sing,
    cide: Sing,
    //homicide
    ence: Sing,
    //absence
    wide: Adj,
    //nationwide
    // side: Adj,//alongside
    vide: Inf,
    //provide
    ract: Inf,
    duce: Inf,
    pose: Inf,
    eive: Inf,
    lyze: Inf,
    lyse: Inf,
    iant: Adj,
    nary: Adj,
    ghty: Adj,
    uent: Adj,
    erer: Actor,
    //caterer
    bury: Place,
    dorf: Noun,
    esty: Noun,
    wych: Place,
    dale: Place,
    folk: Place
  },
  {
    //5-letter
    elist: Actor,
    holic: Sing,
    phite: Sing,
    tized: Past,
    urned: Past,
    eased: Past,
    ances: Plrl,
    bound: Adj,
    ettes: Plrl,
    fully: Avb,
    ishes: Pres,
    ities: Plrl,
    marek: Last,
    nssen: Last,
    ology: Noun,
    osome: Sing,
    tment: Sing,
    ports: Plrl,
    rough: Adj,
    tches: Pres,
    tieth: "Ordinal",
    tures: Plrl,
    wards: Avb,
    where: Avb,
    archy: Noun,
    pathy: Noun,
    opoly: Noun,
    embly: Noun,
    phate: Noun,
    ndent: Sing,
    scent: Sing,
    onist: Actor,
    anist: Actor,
    alist: Actor,
    olist: Actor,
    icist: Actor,
    ounce: Inf,
    iable: Adj,
    borne: Adj,
    gnant: Adj,
    inant: Adj,
    igent: Adj,
    atory: Adj,
    // ctory: Adj,
    rient: Sing,
    dient: Sing,
    maker: Actor,
    burgh: Place,
    mouth: Place,
    ceter: Place,
    ville: Place,
    worth: Noun
  },
  {
    //6-letter
    auskas: Last,
    parent: Sing,
    cedent: Sing,
    ionary: Sing,
    cklist: Sing,
    keeper: Actor,
    logist: Actor,
    teenth: "Value",
    worker: Actor,
    master: Actor,
    writer: Actor,
    brough: Place,
    cester: Place
  },
  {
    //7-letter
    logists: Actor,
    opoulos: Last,
    borough: Place,
    sdottir: Last
    //swedish female
  }
];

// ../../node_modules/compromise/src/2-two/preTagger/model/patterns/prefixes.js
var Adj2 = "Adjective";
var Noun2 = "Noun";
var Verb = "Verb";
var prefixes_default2 = [
  null,
  null,
  {
    // 2-letter
  },
  {
    // 3-letter
    neo: Noun2,
    bio: Noun2,
    // pre: Noun,
    "de-": Verb,
    "re-": Verb,
    "un-": Verb,
    "ex-": Noun2
  },
  {
    // 4-letter
    anti: Noun2,
    auto: Noun2,
    faux: Adj2,
    hexa: Noun2,
    kilo: Noun2,
    mono: Noun2,
    nano: Noun2,
    octa: Noun2,
    poly: Noun2,
    semi: Adj2,
    tele: Noun2,
    "pro-": Adj2,
    "mis-": Verb,
    "dis-": Verb,
    "pre-": Adj2
    //hmm
  },
  {
    // 5-letter
    anglo: Noun2,
    centi: Noun2,
    ethno: Noun2,
    ferro: Noun2,
    grand: Noun2,
    hepta: Noun2,
    hydro: Noun2,
    intro: Noun2,
    macro: Noun2,
    micro: Noun2,
    milli: Noun2,
    nitro: Noun2,
    penta: Noun2,
    quasi: Adj2,
    radio: Noun2,
    tetra: Noun2,
    "omni-": Adj2,
    "post-": Adj2
  },
  {
    // 6-letter
    pseudo: Adj2,
    "extra-": Adj2,
    "hyper-": Adj2,
    "inter-": Adj2,
    "intra-": Adj2,
    "deca-": Adj2
    // 'trans-': Noun,
  },
  {
    // 7-letter
    electro: Noun2
  }
];

// ../../node_modules/compromise/src/2-two/preTagger/model/patterns/endsWith.js
var Adj3 = "Adjective";
var Inf2 = "Infinitive";
var Pres2 = "PresentTense";
var Sing2 = "Singular";
var Past2 = "PastTense";
var Adverb = "Adverb";
var Exp = "Expression";
var Actor2 = "Actor";
var Verb2 = "Verb";
var Noun3 = "Noun";
var Last2 = "LastName";
var endsWith_default = {
  a: [
    [/.[aeiou]na$/, Noun3, "tuna"],
    [/.[oau][wvl]ska$/, Last2],
    [/.[^aeiou]ica$/, Sing2, "harmonica"],
    [/^([hyj]a+)+$/, Exp, "haha"]
    //hahah
  ],
  c: [[/.[^aeiou]ic$/, Adj3]],
  d: [
    //==-ed==
    //double-consonant
    [/[aeiou](pp|ll|ss|ff|gg|tt|rr|bb|nn|mm)ed$/, Past2, "popped"],
    //double-vowel
    [/.[aeo]{2}[bdgmnprvz]ed$/, Past2, "rammed"],
    //-hed
    [/.[aeiou][sg]hed$/, Past2, "gushed"],
    //-rd
    [/.[aeiou]red$/, Past2, "hired"],
    [/.[aeiou]r?ried$/, Past2, "hurried"],
    // ard
    [/[^aeiou]ard$/, Sing2, "steward"],
    // id
    [/[aeiou][^aeiou]id$/, Adj3, ""],
    [/.[vrl]id$/, Adj3, "livid"],
    // ===== -ed ======
    //-led
    [/..led$/, Past2, "hurled"],
    //-sed
    [/.[iao]sed$/, Past2, ""],
    [/[aeiou]n?[cs]ed$/, Past2, ""],
    //-med
    [/[aeiou][rl]?[mnf]ed$/, Past2, ""],
    //-ked
    [/[aeiou][ns]?c?ked$/, Past2, "bunked"],
    //-gned
    [/[aeiou]gned$/, Past2],
    //-ged
    [/[aeiou][nl]?ged$/, Past2],
    //-ted
    [/.[tdbwxyz]ed$/, Past2],
    [/[^aeiou][aeiou][tvx]ed$/, Past2],
    //-ied
    [/.[cdflmnprstv]ied$/, Past2, "emptied"]
  ],
  e: [
    [/.[lnr]ize$/, Inf2, "antagonize"],
    [/.[^aeiou]ise$/, Inf2, "antagonise"],
    [/.[aeiou]te$/, Inf2, "bite"],
    [/.[^aeiou][ai]ble$/, Adj3, "fixable"],
    [/.[^aeiou]eable$/, Adj3, "maleable"],
    [/.[ts]ive$/, Adj3, "festive"],
    [/[a-z]-like$/, Adj3, "woman-like"]
  ],
  h: [
    [/.[^aeiouf]ish$/, Adj3, "cornish"],
    [/.v[iy]ch$/, Last2, "..ovich"],
    [/^ug?h+$/, Exp, "ughh"],
    [/^uh[ -]?oh$/, Exp, "uhoh"],
    [/[a-z]-ish$/, Adj3, "cartoon-ish"]
  ],
  i: [[/.[oau][wvl]ski$/, Last2, "polish-male"]],
  k: [
    [/^(k){2}$/, Exp, "kkkk"]
    //kkkk
  ],
  l: [
    [/.[gl]ial$/, Adj3, "familial"],
    [/.[^aeiou]ful$/, Adj3, "fitful"],
    [/.[nrtumcd]al$/, Adj3, "natal"],
    [/.[^aeiou][ei]al$/, Adj3, "familial"]
  ],
  m: [
    [/.[^aeiou]ium$/, Sing2, "magnesium"],
    [/[^aeiou]ism$/, Sing2, "schism"],
    [/^[hu]m+$/, Exp, "hmm"],
    [/^\d+ ?[ap]m$/, "Date", "3am"]
  ],
  n: [
    [/.[lsrnpb]ian$/, Adj3, "republican"],
    [/[^aeiou]ician$/, Actor2, "musician"],
    [/[aeiou][ktrp]in'$/, "Gerund", "cookin'"]
    // 'cookin', 'hootin'
  ],
  o: [
    [/^no+$/, Exp, "noooo"],
    [/^(yo)+$/, Exp, "yoo"],
    [/^wo{2,}[pt]?$/, Exp, "woop"]
    //woo
  ],
  r: [
    [/.[bdfklmst]ler$/, "Noun"],
    [/[aeiou][pns]er$/, Sing2],
    [/[^i]fer$/, Inf2],
    [/.[^aeiou][ao]pher$/, Actor2],
    [/.[lk]er$/, "Noun"],
    [/.ier$/, "Comparative"]
  ],
  t: [
    [/.[di]est$/, "Superlative"],
    [/.[icldtgrv]ent$/, Adj3],
    [/[aeiou].*ist$/, Adj3],
    [/^[a-z]et$/, Verb2]
  ],
  s: [
    [/.[^aeiou]ises$/, Pres2],
    [/.[rln]ates$/, Pres2],
    [/.[^z]ens$/, Verb2],
    [/.[lstrn]us$/, Sing2],
    [/.[aeiou]sks$/, Pres2],
    [/.[aeiou]kes$/, Pres2],
    [/[aeiou][^aeiou]is$/, Sing2],
    [/[a-z]'s$/, Noun3],
    [/^yes+$/, Exp]
    //yessss
  ],
  v: [
    [/.[^aeiou][ai][kln]ov$/, Last2]
    //east-europe
  ],
  y: [
    [/.[cts]hy$/, Adj3],
    [/.[st]ty$/, Adj3],
    [/.[tnl]ary$/, Adj3],
    [/.[oe]ry$/, Sing2],
    [/[rdntkbhs]ly$/, Adverb],
    [/.(gg|bb|zz)ly$/, Adj3],
    [/...lly$/, Adverb],
    [/.[gk]y$/, Adj3],
    [/[bszmp]{2}y$/, Adj3],
    [/.[ai]my$/, Adj3],
    [/[ea]{2}zy$/, Adj3],
    [/.[^aeiou]ity$/, Sing2]
  ]
};

// ../../node_modules/compromise/src/2-two/preTagger/model/patterns/neighbours.js
var vb2 = "Verb";
var nn2 = "Noun";
var neighbours_default = {
  // looking at the previous word's tags:
  leftTags: [
    ["Adjective", nn2],
    ["Possessive", nn2],
    ["Determiner", nn2],
    ["Adverb", vb2],
    ["Pronoun", vb2],
    ["Value", nn2],
    ["Ordinal", nn2],
    ["Modal", vb2],
    ["Superlative", nn2],
    ["Demonym", nn2],
    ["Honorific", "Person"]
    //dr. Smith
  ],
  // looking at the previous word:
  leftWords: [
    ["i", vb2],
    ["first", nn2],
    ["it", vb2],
    ["there", vb2],
    ["not", vb2],
    ["because", nn2],
    ["if", nn2],
    ["but", nn2],
    ["who", vb2],
    ["this", nn2],
    ["his", nn2],
    ["when", nn2],
    ["you", vb2],
    ["very", "Adjective"],
    ["old", nn2],
    ["never", vb2],
    ["before", nn2],
    ["a", nn2],
    ["the", nn2],
    ["been", vb2]
  ],
  // looking at the next word's tags:
  rightTags: [
    ["Copula", nn2],
    ["PastTense", nn2],
    ["Conjunction", nn2],
    ["Modal", nn2]
  ],
  // looking at the next word:
  rightWords: [
    ["there", vb2],
    ["me", vb2],
    ["man", "Adjective"],
    // ['only', vb],
    ["him", vb2],
    ["it", vb2],
    //relaunch it
    ["were", nn2],
    ["took", nn2],
    ["himself", vb2],
    ["went", nn2],
    ["who", nn2],
    ["jr", "Person"]
  ]
};

// ../../node_modules/compromise/src/2-two/preTagger/model/models/_data.js
var data_default2 = {
  "Comparative": {
    "fwd": "3:ser,ier¦1er:h,t,f,l,n¦1r:e¦2er:ss,or,om",
    "both": "3er:ver,ear,alm¦3ner:hin¦3ter:lat¦2mer:im¦2er:ng,rm,mb¦2ber:ib¦2ger:ig¦1er:w,p,k,d¦ier:y",
    "rev": "1:tter,yer¦2:uer,ver,ffer,oner,eler,ller,iler,ster,cer,uler,sher,ener,gher,aner,adder,nter,eter,rter,hter,rner,fter¦3:oser,ooler,eafer,user,airer,bler,maler,tler,eater,uger,rger,ainer,urer,ealer,icher,pler,emner,icter,nser,iser¦4:arser,viner,ucher,rosser,somer,ndomer,moter,oother,uarer,hiter¦5:nuiner,esser,emier¦ar:urther",
    "ex": "worse:bad¦better:good¦4er:fair,gray,poor¦1urther:far¦3ter:fat,hot,wet¦3er:lay,shy,fun¦3der:mad,sad¦4der:glad¦:¦4r:cute,dire,fake,fine,free,lame,late,pale,rare,ripe,rude,safe,sore,tame,wide¦5r:eerie,stale"
  },
  "Gerund": {
    "fwd": "1:nning,tting,rring,pping,eing,mming,gging,dding,bbing,kking¦2:eking,oling,eling,eming¦3:velling,siting,uiting,fiting,loting,geting,ialing,celling¦4:graming",
    "both": "1:aing,iing,fing,xing,ying,oing,hing,wing¦2:tzing,rping,izzing,bting,mning,sping,wling,rling,wding,rbing,uping,lming,wning,mping,oning,lting,mbing,lking,fting,hting,sking,gning,pting,cking,ening,nking,iling,eping,ering,rting,rming,cting,lping,ssing,nting,nding,lding,sting,rning,rding,rking¦3:belling,siping,toming,yaking,uaking,oaning,auling,ooping,aiding,naping,euring,tolling,uzzing,ganing,haning,ualing,halling,iasing,auding,ieting,ceting,ouling,voring,ralling,garing,joring,oaming,oaking,roring,nelling,ooring,uelling,eaming,ooding,eaping,eeting,ooting,ooming,xiting,keting,ooking,ulling,airing,oaring,biting,outing,oiting,earing,naling,oading,eeding,ouring,eaking,aiming,illing,oining,eaning,onging,ealing,aining,eading¦4:thoming,melling,aboring,ivoting,weating,dfilling,onoring,eriting,imiting,tialling,rgining,otoring,linging,winging,lleting,louding,spelling,mpelling,heating,feating,opelling,choring,welling,ymaking,ctoring,calling,peating,iloring,laiting,utoring,uditing,mmaking,loating,iciting,waiting,mbating,voiding,otalling,nsoring,nselling,ocusing,itoring,eloping¦5:rselling,umpeting,atrolling,treating,tselling,rpreting,pringing,ummeting,ossoming,elmaking,eselling,rediting,totyping,onmaking,rfeiting,ntrolling¦5e:chmaking,dkeeping,severing,erouting,ecreting,ephoning,uthoring,ravening,reathing,pediting,erfering,eotyping,fringing,entoring,ombining,ompeting¦4e:emaking,eething,twining,rruling,chuting,xciting,rseding,scoping,edoring,pinging,lunging,agining,craping,pleting,eleting,nciting,nfining,ncoding,tponing,ecoding,writing,esaling,nvening,gnoring,evoting,mpeding,rvening,dhering,mpiling,storing,nviting,ploring¦3e:tining,nuring,saking,miring,haling,ceding,xuding,rining,nuting,laring,caring,miling,riding,hoking,piring,lading,curing,uading,noting,taping,futing,paring,hading,loding,siring,guring,vading,voking,during,niting,laning,caping,luting,muting,ruding,ciding,juring,laming,caling,hining,uoting,liding,ciling,duling,tuting,puting,cuting,coring,uiding,tiring,turing,siding,rading,enging,haping,buting,lining,taking,anging,haring,uiring,coming,mining,moting,suring,viding,luding¦2e:tring,zling,uging,oging,gling,iging,vring,fling,lging,obing,psing,pling,ubing,cling,dling,wsing,iking,rsing,dging,kling,ysing,tling,rging,eging,nsing,uning,osing,uming,using,ibing,bling,aging,ising,asing,ating¦2ie:rlying¦1e:zing,uing,cing,ving",
    "rev": "ying:ie¦1ing:se,ke,te,we,ne,re,de,pe,me,le,c,he¦2ing:ll,ng,dd,ee,ye,oe,rg,us¦2ning:un¦2ging:og,ag,ug,ig,eg¦2ming:um¦2bing:ub,ab,eb,ob¦3ning:lan,can,hin,pin,win¦3ring:cur,lur,tir,tar,pur,car¦3ing:ait,del,eel,fin,eat,oat,eem,lel,ool,ein,uin¦3ping:rop,rap,top,uip,wap,hip,hop,lap,rip,cap¦3ming:tem,wim,rim,kim,lim¦3ting:mat,cut,pot,lit,lot,hat,set,pit,put¦3ding:hed,bed,bid¦3king:rek¦3ling:cil,pel¦3bing:rib¦4ning:egin¦4ing:isit,ruit,ilot,nsit,dget,rkel,ival,rcel¦4ring:efer,nfer¦4ting:rmit,mmit,ysit,dmit,emit,bmit,tfit,gret¦4ling:evel,xcel,ivel¦4ding:hred¦5ing:arget,posit,rofit¦5ring:nsfer¦5ting:nsmit,orget,cquit¦5ling:ancel,istil",
    "ex": "3:adding,eating,aiming,aiding,airing,outing,gassing,setting,getting,putting,cutting,winning,sitting,betting,mapping,tapping,letting,bidding,hitting,tanning,netting,popping,fitting,capping,lapping,barring,banning,vetting,topping,rotting,tipping,potting,wetting,pitting,dipping,budding,hemming,pinning,jetting,kidding,padding,podding,sipping,wedding,bedding,donning,warring,penning,gutting,cueing,wadding,petting,ripping,napping,matting,tinning,binning,dimming,hopping,mopping,nodding,panning,rapping,ridding,sinning¦4:selling,falling,calling,waiting,editing,telling,rolling,heating,boating,hanging,beating,coating,singing,tolling,felling,polling,discing,seating,voiding,gelling,yelling,baiting,reining,ruining,seeking,spanning,stepping,knitting,emitting,slipping,quitting,dialing,omitting,clipping,shutting,skinning,abutting,flipping,trotting,cramming,fretting,suiting¦5:bringing,treating,spelling,stalling,trolling,expelling,rivaling,wringing,deterring,singeing,befitting,refitting¦6:enrolling,distilling,scrolling,strolling,caucusing,travelling¦7:installing,redefining,stencilling,recharging,overeating,benefiting,unraveling,programing¦9:reprogramming¦is:being¦2e:using,aging,owing¦3e:making,taking,coming,noting,hiring,filing,coding,citing,doping,baking,coping,hoping,lading,caring,naming,voting,riding,mining,curing,lining,ruling,typing,boring,dining,firing,hiding,piling,taping,waning,baling,boning,faring,honing,wiping,luring,timing,wading,piping,fading,biting,zoning,daring,waking,gaming,raking,ceding,tiring,coking,wining,joking,paring,gaping,poking,pining,coring,liming,toting,roping,wiring,aching¦4e:writing,storing,eroding,framing,smoking,tasting,wasting,phoning,shaking,abiding,braking,flaking,pasting,priming,shoring,sloping,withing,hinging¦5e:defining,refining,renaming,swathing,fringing,reciting¦1ie:dying,tying,lying,vying¦7e:sunbathing"
  },
  "Participle": {
    "fwd": "1:mt¦2:llen¦3:iven,aken¦:ne¦y:in",
    "both": "1:wn¦2:me,aten¦3:seen,bidden,isen¦4:roven,asten¦3l:pilt¦3d:uilt¦2e:itten¦1im:wum¦1eak:poken¦1ine:hone¦1ose:osen¦1in:gun¦1ake:woken¦ear:orn¦eal:olen¦eeze:ozen¦et:otten¦ink:unk¦ing:ung",
    "rev": "2:un¦oken:eak¦ought:eek¦oven:eave¦1ne:o¦1own:ly¦1den:de¦1in:ay¦2t:am¦2n:ee¦3en:all¦4n:rive,sake,take¦5n:rgive",
    "ex": "2:been¦3:seen,run¦4:given,taken¦5:shaken¦2eak:broken¦1ive:dove¦2y:flown¦3e:hidden,ridden¦1eek:sought¦1ake:woken¦1eave:woven"
  },
  "PastTense": {
    "fwd": "1:tted,wed,gged,nned,een,rred,pped,yed,bbed,oed,dded,rd,wn,mmed¦2:eed,nded,et,hted,st,oled,ut,emed,eled,lded,ken,rt,nked,apt,ant,eped,eked¦3:eared,eat,eaded,nelled,ealt,eeded,ooted,eaked,eaned,eeted,mited,bid,uit,ead,uited,ealed,geted,velled,ialed,belled¦4:ebuted,hined,comed¦y:ied¦ome:ame¦ear:ore¦ind:ound¦ing:ung,ang¦ep:pt¦ink:ank,unk¦ig:ug¦all:ell¦ee:aw¦ive:ave¦eeze:oze¦old:eld¦ave:ft¦ake:ook¦ell:old¦ite:ote¦ide:ode¦ine:one¦in:un,on¦eal:ole¦im:am¦ie:ay¦and:ood¦1ise:rose¦1eak:roke¦1ing:rought¦1ive:rove¦1el:elt¦1id:bade¦1et:got¦1y:aid¦1it:sat¦3e:lid¦3d:pent",
    "both": "1:aed,fed,xed,hed¦2:sged,xted,wled,rped,lked,kied,lmed,lped,uped,bted,rbed,rked,wned,rled,mped,fted,mned,mbed,zzed,omed,ened,cked,gned,lted,sked,ued,zed,nted,ered,rted,rmed,ced,sted,rned,ssed,rded,pted,ved,cted¦3:cled,eined,siped,ooned,uked,ymed,jored,ouded,ioted,oaned,lged,asped,iged,mured,oided,eiled,yped,taled,moned,yled,lit,kled,oaked,gled,naled,fled,uined,oared,valled,koned,soned,aided,obed,ibed,meted,nicked,rored,micked,keted,vred,ooped,oaded,rited,aired,auled,filled,ouled,ooded,ceted,tolled,oited,bited,aped,tled,vored,dled,eamed,nsed,rsed,sited,owded,pled,sored,rged,osed,pelled,oured,psed,oated,loned,aimed,illed,eured,tred,ioned,celled,bled,wsed,ooked,oiled,itzed,iked,iased,onged,ased,ailed,uned,umed,ained,auded,nulled,ysed,eged,ised,aged,oined,ated,used,dged,doned¦4:ntied,efited,uaked,caded,fired,roped,halled,roked,himed,culed,tared,lared,tuted,uared,routed,pited,naked,miled,houted,helled,hared,cored,caled,tired,peated,futed,ciled,called,tined,moted,filed,sided,poned,iloted,honed,lleted,huted,ruled,cured,named,preted,vaded,sured,talled,haled,peded,gined,nited,uided,ramed,feited,laked,gured,ctored,unged,pired,cuted,voked,eloped,ralled,rined,coded,icited,vided,uaded,voted,mined,sired,noted,lined,nselled,luted,jured,fided,puted,piled,pared,olored,cided,hoked,enged,tured,geoned,cotted,lamed,uiled,waited,udited,anged,luded,mired,uired,raded¦5:modelled,izzled,eleted,umpeted,ailored,rseded,treated,eduled,ecited,rammed,eceded,atrolled,nitored,basted,twined,itialled,ncited,gnored,ploded,xcited,nrolled,namelled,plored,efeated,redited,ntrolled,nfined,pleted,llided,lcined,eathed,ibuted,lloted,dhered,cceded¦3ad:sled¦2aw:drew¦2ot:hot¦2ke:made¦2ow:hrew,grew¦2ose:hose¦2d:ilt¦2in:egan¦1un:ran¦1ink:hought¦1ick:tuck¦1ike:ruck¦1eak:poke,nuck¦1it:pat¦1o:did¦1ow:new¦1ake:woke¦go:went",
    "rev": "3:rst,hed,hut,cut,set¦4:tbid¦5:dcast,eread,pread,erbid¦ought:uy,eek¦1ied:ny,ly,dy,ry,fy,py,vy,by,ty,cy¦1ung:ling,ting,wing¦1pt:eep¦1ank:rink¦1ore:bear,wear¦1ave:give¦1oze:reeze¦1ound:rind,wind¦1ook:take,hake¦1aw:see¦1old:sell¦1ote:rite¦1ole:teal¦1unk:tink¦1am:wim¦1ay:lie¦1ood:tand¦1eld:hold¦2d:he,ge,re,le,leed,ne,reed,be,ye,lee,pe,we¦2ed:dd,oy,or,ey,gg,rr,us,ew,to¦2ame:ecome,rcome¦2ped:ap¦2ged:ag,og,ug,eg¦2bed:ub,ab,ib,ob¦2lt:neel¦2id:pay¦2ang:pring¦2ove:trive¦2med:um¦2ode:rride¦2at:ysit¦3ted:mit,hat,mat,lat,pot,rot,bat¦3ed:low,end,tow,und,ond,eem,lay,cho,dow,xit,eld,ald,uld,law,lel,eat,oll,ray,ank,fin,oam,out,how,iek,tay,haw,ait,vet,say,cay,bow¦3d:ste,ede,ode,ete,ree,ude,ame,oke,ote,ime,ute,ade¦3red:lur,cur,pur,car¦3ped:hop,rop,uip,rip,lip,tep,top¦3ded:bed,rod,kid¦3ade:orbid¦3led:uel¦3ned:lan,can,kin,pan,tun¦3med:rim,lim¦4ted:quit,llot¦4ed:pear,rrow,rand,lean,mand,anel,pand,reet,link,abel,evel,imit,ceed,ruit,mind,peal,veal,hool,head,pell,well,mell,uell,band,hear,weak¦4led:nnel,qual,ebel,ivel¦4red:nfer,efer,sfer¦4n:sake,trew¦4d:ntee¦4ded:hred¦4ned:rpin¦5ed:light,nceal,right,ndear,arget,hread,eight,rtial,eboot¦5d:edite,nvite¦5ted:egret¦5led:ravel",
    "ex": "2:been,upped¦3:added,aged,aided,aimed,aired,bid,died,dyed,egged,erred,eyed,fit,gassed,hit,lied,owed,pent,pied,tied,used,vied,oiled,outed,banned,barred,bet,canned,cut,dipped,donned,ended,feed,inked,jarred,let,manned,mowed,netted,padded,panned,pitted,popped,potted,put,set,sewn,sowed,tanned,tipped,topped,vowed,weed,bowed,jammed,binned,dimmed,hopped,mopped,nodded,pinned,rigged,sinned,towed,vetted¦4:ached,baked,baled,boned,bored,called,caned,cared,ceded,cited,coded,cored,cubed,cured,dared,dined,edited,exited,faked,fared,filed,fined,fired,fuelled,gamed,gelled,hired,hoped,joked,lined,mined,named,noted,piled,poked,polled,pored,pulled,reaped,roamed,rolled,ruled,seated,shed,sided,timed,tolled,toned,voted,waited,walled,waned,winged,wiped,wired,zoned,yelled,tamed,lubed,roped,faded,mired,caked,honed,banged,culled,heated,raked,welled,banded,beat,cast,cooled,cost,dealt,feared,folded,footed,handed,headed,heard,hurt,knitted,landed,leaked,leapt,linked,meant,minded,molded,neared,needed,peaked,plodded,plotted,pooled,quit,read,rooted,sealed,seeded,seeped,shipped,shunned,skimmed,slammed,sparred,stemmed,stirred,suited,thinned,twinned,swayed,winked,dialed,abutted,blotted,fretted,healed,heeded,peeled,reeled¦5:basted,cheated,equalled,eroded,exiled,focused,opined,pleated,primed,quoted,scouted,shored,sloped,smoked,sniped,spelled,spouted,routed,staked,stored,swelled,tasted,treated,wasted,smelled,dwelled,honored,prided,quelled,eloped,scared,coveted,sweated,breaded,cleared,debuted,deterred,freaked,modeled,pleaded,rebutted,speeded¦6:anchored,defined,endured,impaled,invited,refined,revered,strolled,cringed,recast,thrust,unfolded¦7:authored,combined,competed,conceded,convened,excreted,extruded,redefined,restored,secreted,rescinded,welcomed¦8:expedited,infringed¦9:interfered,intervened,persevered¦10:contravened¦eat:ate¦is:was¦go:went¦are:were¦3d:bent,lent,rent,sent¦3e:bit,fled,hid,lost¦3ed:bled,bred¦2ow:blew,grew¦1uy:bought¦2tch:caught¦1o:did¦1ive:dove,gave¦2aw:drew¦2ed:fed¦2y:flew,laid,paid,said¦1ight:fought¦1et:got¦2ve:had¦1ang:hung¦2ad:led¦2ght:lit¦2ke:made¦2et:met¦1un:ran¦1ise:rose¦1it:sat¦1eek:sought¦1each:taught¦1ake:woke,took¦1eave:wove¦2ise:arose¦1ear:bore,tore,wore¦1ind:bound,found,wound¦2eak:broke¦2ing:brought,wrung¦1ome:came¦2ive:drove¦1ig:dug¦1all:fell¦2el:felt¦4et:forgot¦1old:held¦2ave:left¦1ing:rang,sang¦1ide:rode¦1ink:sank¦1ee:saw¦2ine:shone¦4e:slid¦1ell:sold,told¦4d:spent¦2in:spun¦1in:won"
  },
  "PresentTense": {
    "fwd": "1:oes¦1ve:as",
    "both": "1:xes¦2:zzes,ches,shes,sses¦3:iases¦2y:llies,plies¦1y:cies,bies,ties,vies,nies,pies,dies,ries,fies¦:s",
    "rev": "1ies:ly¦2es:us,go,do¦3es:cho,eto",
    "ex": "2:does,goes¦3:gasses¦5:focuses¦is:are¦3y:relies¦2y:flies¦2ve:has"
  },
  "Superlative": {
    "fwd": "1st:e¦1est:l,m,f,s¦1iest:cey¦2est:or,ir¦3est:ver",
    "both": "4:east¦5:hwest¦5lest:erful¦4est:weet,lgar,tter,oung¦4most:uter¦3est:ger,der,rey,iet,ong,ear¦3test:lat¦3most:ner¦2est:pt,ft,nt,ct,rt,ht¦2test:it¦2gest:ig¦1est:b,k,n,p,h,d,w¦iest:y",
    "rev": "1:ttest,nnest,yest¦2:sest,stest,rmest,cest,vest,lmest,olest,ilest,ulest,ssest,imest,uest¦3:rgest,eatest,oorest,plest,allest,urest,iefest,uelest,blest,ugest,amest,yalest,ealest,illest,tlest,itest¦4:cerest,eriest,somest,rmalest,ndomest,motest,uarest,tiffest¦5:leverest,rangest¦ar:urthest¦3ey:riciest",
    "ex": "best:good¦worst:bad¦5est:great¦4est:fast,full,fair,dull¦3test:hot,wet,fat¦4nest:thin¦1urthest:far¦3est:gay,shy,ill¦4test:neat¦4st:late,wide,fine,safe,cute,fake,pale,rare,rude,sore,ripe,dire¦6st:severe"
  },
  "AdjToNoun": {
    "fwd": "1:tistic,eable,lful,sful,ting,tty¦2:onate,rtable,geous,ced,seful,ctful¦3:ortive,ented¦arity:ear¦y:etic¦fulness:begone¦1ity:re¦1y:tiful,gic¦2ity:ile,imous,ilous,ime¦2ion:ated¦2eness:iving¦2y:trious¦2ation:iring¦2tion:vant¦3ion:ect¦3ce:mant,mantic¦3tion:irable¦3y:est,estic¦3m:mistic,listic¦3ess:ning¦4n:utious¦4on:rative,native,vative,ective¦4ce:erant",
    "both": "1:king,wing¦2:alous,ltuous,oyful,rdous¦3:gorous,ectable,werful,amatic¦4:oised,usical,agical,raceful,ocused,lined,ightful¦5ness:stful,lding,itous,nuous,ulous,otous,nable,gious,ayful,rvous,ntous,lsive,peful,entle,ciful,osive,leful,isive,ncise,reful,mious¦5ty:ivacious¦5ties:ubtle¦5ce:ilient,adiant,atient¦5cy:icient¦5sm:gmatic¦5on:sessive,dictive¦5ity:pular,sonal,eative,entic¦5sity:uminous¦5ism:conic¦5nce:mperate¦5ility:mitable¦5ment:xcited¦5n:bitious¦4cy:brant,etent,curate¦4ility:erable,acable,icable,ptable¦4ty:nacious,aive,oyal,dacious¦4n:icious¦4ce:vient,erent,stent,ndent,dient,quent,ident¦4ness:adic,ound,hing,pant,sant,oing,oist,tute¦4icity:imple¦4ment:fined,mused¦4ism:otic¦4ry:dantic¦4ity:tund,eral¦4edness:hand¦4on:uitive¦4lity:pitable¦4sm:eroic,namic¦4sity:nerous¦3th:arm¦3ility:pable,bable,dable,iable¦3cy:hant,nant,icate¦3ness:red,hin,nse,ict,iet,ite,oud,ind,ied,rce¦3ion:lute¦3ity:ual,gal,volous,ial¦3ce:sent,fensive,lant,gant,gent,lent,dant¦3on:asive¦3m:fist,sistic,iastic¦3y:terious,xurious,ronic,tastic¦3ur:amorous¦3e:tunate¦3ation:mined¦3sy:rteous¦3ty:ain¦3ry:ave¦3ment:azed¦2ness:de,on,ue,rn,ur,ft,rp,pe,om,ge,rd,od,ay,ss,er,ll,oy,ap,ht,ld,ad,rt¦2inousness:umous¦2ity:neous,ene,id,ane¦2cy:bate,late¦2ation:ized¦2ility:oble,ible¦2y:odic¦2e:oving,aring¦2s:ost¦2itude:pt¦2dom:ee¦2ance:uring¦2tion:reet¦2ion:oted¦2sion:ending¦2liness:an¦2or:rdent¦1th:ung¦1e:uable¦1ness:w,h,k,f¦1ility:mble¦1or:vent¦1ement:ging¦1tiquity:ncient¦1ment:hed¦verty:or¦ength:ong¦eat:ot¦pth:ep¦iness:y",
    "rev": "",
    "ex": "5:forceful,humorous¦8:charismatic¦13:understanding¦5ity:active¦11ness:adventurous,inquisitive,resourceful¦8on:aggressive,automatic,perceptive¦7ness:amorous,fatuous,furtive,ominous,serious¦5ness:ample,sweet¦12ness:apprehensive,cantankerous,contemptuous,ostentatious¦13ness:argumentative,conscientious¦9ness:assertive,facetious,imperious,inventive,oblivious,rapacious,receptive,seditious,whimsical¦10ness:attractive,expressive,impressive,loquacious,salubrious,thoughtful¦3edom:boring¦4ness:calm,fast,keen,tame¦8ness:cheerful,gracious,specious,spurious,timorous,unctuous¦5sity:curious¦9ion:deliberate¦8ion:desperate¦6e:expensive¦7ce:fragrant¦3y:furious¦9ility:ineluctable¦6ism:mystical¦8ity:physical,proactive,sensitive,vertical¦5cy:pliant¦7ity:positive¦9ity:practical¦12ism:professional¦6ce:prudent¦3ness:red¦6cy:vagrant¦3dom:wise"
  }
};

// ../../node_modules/suffix-thumb/src/convert/index.js
var checkEx = function(str, ex = {}) {
  if (ex.hasOwnProperty(str)) {
    return ex[str];
  }
  return null;
};
var checkSame = function(str, same = []) {
  for (let i3 = 0; i3 < same.length; i3 += 1) {
    if (str.endsWith(same[i3])) {
      return str;
    }
  }
  return null;
};
var checkRules = function(str, fwd, both = {}) {
  fwd = fwd || {};
  let max3 = str.length - 1;
  for (let i3 = max3; i3 >= 1; i3 -= 1) {
    let size = str.length - i3;
    let suff = str.substring(size, str.length);
    if (fwd.hasOwnProperty(suff) === true) {
      return str.slice(0, size) + fwd[suff];
    }
    if (both.hasOwnProperty(suff) === true) {
      return str.slice(0, size) + both[suff];
    }
  }
  if (fwd.hasOwnProperty("")) {
    return str += fwd[""];
  }
  if (both.hasOwnProperty("")) {
    return str += both[""];
  }
  return null;
};
var convert = function(str = "", model5 = {}) {
  let out2 = checkEx(str, model5.ex);
  out2 = out2 || checkSame(str, model5.same);
  out2 = out2 || checkRules(str, model5.fwd, model5.both);
  out2 = out2 || str;
  return out2;
};
var convert_default = convert;

// ../../node_modules/suffix-thumb/src/reverse/index.js
var flipObj = function(obj) {
  return Object.entries(obj).reduce((h2, a2) => {
    h2[a2[1]] = a2[0];
    return h2;
  }, {});
};
var reverse2 = function(model5 = {}) {
  return {
    reversed: true,
    // keep these two
    both: flipObj(model5.both),
    ex: flipObj(model5.ex),
    // swap this one in
    fwd: model5.rev || {}
  };
};
var reverse_default = reverse2;

// ../../node_modules/suffix-thumb/src/compress/unpack.js
var prefix2 = /^([0-9]+)/;
var toObject = function(txt) {
  let obj = {};
  txt.split("¦").forEach((str) => {
    let [key, vals] = str.split(":");
    vals = (vals || "").split(",");
    vals.forEach((val) => {
      obj[val] = key;
    });
  });
  return obj;
};
var growObject = function(key = "", val = "") {
  val = String(val);
  let m3 = val.match(prefix2);
  if (m3 === null) {
    return val;
  }
  let num = Number(m3[1]) || 0;
  let pre = key.substring(0, num);
  let full = pre + val.replace(prefix2, "");
  return full;
};
var unpackOne = function(str) {
  let obj = toObject(str);
  return Object.keys(obj).reduce((h2, k2) => {
    h2[k2] = growObject(k2, obj[k2]);
    return h2;
  }, {});
};
var uncompress = function(model5 = {}) {
  if (typeof model5 === "string") {
    model5 = JSON.parse(model5);
  }
  model5.fwd = unpackOne(model5.fwd || "");
  model5.both = unpackOne(model5.both || "");
  model5.rev = unpackOne(model5.rev || "");
  model5.ex = unpackOne(model5.ex || "");
  return model5;
};
var unpack_default2 = uncompress;

// ../../node_modules/compromise/src/2-two/preTagger/model/models/index.js
var fromPast = unpack_default2(data_default2.PastTense);
var fromPresent = unpack_default2(data_default2.PresentTense);
var fromGerund = unpack_default2(data_default2.Gerund);
var fromParticiple = unpack_default2(data_default2.Participle);
var toPast = reverse_default(fromPast);
var toPresent = reverse_default(fromPresent);
var toGerund = reverse_default(fromGerund);
var toParticiple = reverse_default(fromParticiple);
var toComparative = unpack_default2(data_default2.Comparative);
var toSuperlative = unpack_default2(data_default2.Superlative);
var fromComparative = reverse_default(toComparative);
var fromSuperlative = reverse_default(toSuperlative);
var adjToNoun = unpack_default2(data_default2.AdjToNoun);
var models_default = {
  fromPast,
  fromPresent,
  fromGerund,
  fromParticiple,
  toPast,
  toPresent,
  toGerund,
  toParticiple,
  // adjectives
  toComparative,
  toSuperlative,
  fromComparative,
  fromSuperlative,
  adjToNoun
};

// ../../node_modules/compromise/src/2-two/preTagger/model/regex/regex-normal.js
var regex_normal_default = [
  //web tags
  [/^[\w.]+@[\w.]+\.[a-z]{2,3}$/, "Email"],
  [/^(https?:\/\/|www\.)+\w+\.[a-z]{2,3}/, "Url", "http.."],
  [/^[a-z0-9./].+\.(com|net|gov|org|ly|edu|info|biz|dev|ru|jp|de|in|uk|br|io|ai)/, "Url", ".com"],
  // timezones
  [/^[PMCE]ST$/, "Timezone", "EST"],
  //names
  [/^ma?c'.*/, "LastName", "mc'neil"],
  [/^o'[drlkn].*/, "LastName", "o'connor"],
  [/^ma?cd[aeiou]/, "LastName", "mcdonald"],
  //slang things
  [/^(lol)+[sz]$/, "Expression", "lol"],
  [/^wo{2,}a*h?$/, "Expression", "wooah"],
  [/^(hee?){2,}h?$/, "Expression", "hehe"],
  [/^(un|de|re)\\-[a-z\u00C0-\u00FF]{2}/, "Verb", "un-vite"],
  // m/h
  [/^(m|k|cm|km)\/(s|h|hr)$/, "Unit", "5 k/m"],
  // μg/g
  [/^(ug|ng|mg)\/(l|m3|ft3)$/, "Unit", "ug/L"]
];

// ../../node_modules/compromise/src/2-two/preTagger/model/regex/regex-text.js
var regex_text_default = [
  // #coolguy
  [/^#[\p{Number}_]*\p{Letter}/u, "HashTag"],
  // can't be all numbers
  // @spencermountain
  [/^@\w{2,}$/, "AtMention"],
  // period-ones acronyms - f.b.i.
  [/^([A-Z]\.){2}[A-Z]?/i, ["Acronym", "Noun"], "F.B.I"],
  //ascii-only
  // ending-apostrophes
  [/.{3}[lkmnp]in['‘’‛‵′`´]$/, "Gerund", "chillin'"],
  [/.{4}s['‘’‛‵′`´]$/, "Possessive", "flanders'"],
  //from https://www.regextester.com/106421
  // [/^([\u00a9\u00ae\u2319-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/, 'Emoji', 'emoji-range']
  // unicode character range
  [/^[\p{Emoji_Presentation}\p{Extended_Pictographic}]/u, "Emoji", "emoji-class"]
];

// ../../node_modules/compromise/src/2-two/preTagger/model/regex/regex-numbers.js
var regex_numbers_default = [
  [/^@1?[0-9](am|pm)$/i, "Time", "3pm"],
  [/^@1?[0-9]:[0-9]{2}(am|pm)?$/i, "Time", "3:30pm"],
  [/^'[0-9]{2}$/, "Year"],
  // times
  [/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])$/, "Time", "3:12:31"],
  [/^[012]?[0-9](:[0-5][0-9])?(:[0-5][0-9])? ?(am|pm)$/i, "Time", "1:12pm"],
  [/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])? ?(am|pm)?$/i, "Time", "1:12:31pm"],
  //can remove?
  // iso-dates
  [/^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}/i, "Date", "iso-date"],
  [/^[0-9]{1,4}-[0-9]{1,2}-[0-9]{1,4}$/, "Date", "iso-dash"],
  [/^[0-9]{1,4}\/[0-9]{1,2}\/([0-9]{4}|[0-9]{2})$/, "Date", "iso-slash"],
  [/^[0-9]{1,4}\.[0-9]{1,2}\.[0-9]{1,4}$/, "Date", "iso-dot"],
  [/^[0-9]{1,4}-[a-z]{2,9}-[0-9]{1,4}$/i, "Date", "12-dec-2019"],
  // timezones
  [/^utc ?[+-]?[0-9]+$/, "Timezone", "utc-9"],
  [/^(gmt|utc)[+-][0-9]{1,2}$/i, "Timezone", "gmt-3"],
  //phone numbers
  [/^[0-9]{3}-[0-9]{4}$/, "PhoneNumber", "421-0029"],
  [/^(\+?[0-9][ -])?[0-9]{3}[ -]?[0-9]{3}-[0-9]{4}$/, "PhoneNumber", "1-800-"],
  //money
  //like $5.30
  [
    /^[-+]?\p{Currency_Symbol}[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?([kmb]|bn)?\+?$/u,
    ["Money", "Value"],
    "$5.30"
  ],
  //like 5.30$
  [
    /^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\p{Currency_Symbol}\+?$/u,
    ["Money", "Value"],
    "5.30£"
  ],
  //like
  [/^[-+]?[$£]?[0-9]([0-9,.])+(usd|eur|jpy|gbp|cad|aud|chf|cny|hkd|nzd|kr|rub)$/i, ["Money", "Value"], "$400usd"],
  //numbers
  // 50 | -50 | 3.23  | 5,999.0  | 10+
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\+?$/, ["Cardinal", "NumericValue"], "5,999"],
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?(st|nd|rd|r?th)$/, ["Ordinal", "NumericValue"], "53rd"],
  // .73th
  [/^\.[0-9]+\+?$/, ["Cardinal", "NumericValue"], ".73th"],
  //percent
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?%\+?$/, ["Percent", "Cardinal", "NumericValue"], "-4%"],
  [/^\.[0-9]+%$/, ["Percent", "Cardinal", "NumericValue"], ".3%"],
  //fraction
  [/^[0-9]{1,4}\/[0-9]{1,4}(st|nd|rd|th)?s?$/, ["Fraction", "NumericValue"], "2/3rds"],
  //range
  [/^[0-9.]{1,3}[a-z]{0,2}[-–—][0-9]{1,3}[a-z]{0,2}$/, ["Value", "NumberRange"], "3-4"],
  //time-range
  [/^[0-9]{1,2}(:[0-9][0-9])?(am|pm)? ?[-–—] ?[0-9]{1,2}(:[0-9][0-9])?(am|pm)$/, ["Time", "NumberRange"], "3-4pm"],
  //number with unit
  [/^[0-9.]+([a-z°]{1,4})$/, "NumericValue", "9km"]
];

// ../../node_modules/compromise/src/2-two/preTagger/model/orgWords.js
var orgWords_default = [
  "academy",
  "administration",
  "agence",
  "agences",
  "agencies",
  "agency",
  "airlines",
  "airways",
  "army",
  "assoc",
  "associates",
  "association",
  "assurance",
  "authority",
  "autorite",
  "aviation",
  "bank",
  "banque",
  "board",
  "boys",
  "brands",
  "brewery",
  "brotherhood",
  "brothers",
  "bureau",
  "cafe",
  "co",
  "caisse",
  "capital",
  "care",
  "cathedral",
  "center",
  "centre",
  "chemicals",
  "choir",
  "chronicle",
  "church",
  "circus",
  "clinic",
  "clinique",
  "club",
  "co",
  "coalition",
  "coffee",
  "collective",
  "college",
  "commission",
  "committee",
  "communications",
  "community",
  "company",
  "comprehensive",
  "computers",
  "confederation",
  "conference",
  "conseil",
  "consulting",
  "containers",
  "corporation",
  "corps",
  "corp",
  "council",
  "crew",
  "data",
  "departement",
  "department",
  "departments",
  "design",
  "development",
  "directorate",
  "division",
  "drilling",
  "education",
  "eglise",
  "electric",
  "electricity",
  "energy",
  "ensemble",
  "enterprise",
  "enterprises",
  "entertainment",
  "estate",
  "etat",
  "faculty",
  "federation",
  "financial",
  "fm",
  "foundation",
  "fund",
  "gas",
  "gazette",
  "girls",
  "government",
  "group",
  "guild",
  "herald",
  "holdings",
  "hospital",
  "hotel",
  "hotels",
  "inc",
  "industries",
  "institut",
  "institute",
  "institutes",
  "insurance",
  "international",
  "interstate",
  "investment",
  "investments",
  "investors",
  "journal",
  "laboratory",
  "labs",
  "llc",
  "ltd",
  "limited",
  "machines",
  "magazine",
  "management",
  "marine",
  "marketing",
  "markets",
  "media",
  "memorial",
  "ministere",
  "ministry",
  "military",
  "mobile",
  "motor",
  "motors",
  "musee",
  "museum",
  "news",
  "observatory",
  "office",
  "oil",
  "optical",
  "orchestra",
  "organization",
  "partners",
  "partnership",
  "petrol",
  "petroleum",
  "pharmacare",
  "pharmaceutical",
  "pharmaceuticals",
  "pizza",
  "plc",
  "police",
  "polytechnic",
  "post",
  "power",
  "press",
  "productions",
  "quartet",
  "radio",
  "reserve",
  "resources",
  "restaurant",
  "restaurants",
  "savings",
  "school",
  "securities",
  "service",
  "services",
  "societe",
  "society",
  "sons",
  // 'standard',
  "subcommittee",
  "syndicat",
  "systems",
  "telecommunications",
  "telegraph",
  "television",
  "times",
  "tribunal",
  "tv",
  "union",
  "university",
  "utilities",
  "workers"
].reduce((h2, str) => {
  h2[str] = true;
  return h2;
}, {});

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toSingular/_rules.js
var rules_default2 = [
  [/([^v])ies$/i, "$1y"],
  [/(ise)s$/i, "$1"],
  //promises
  [/(kn|[^o]l|w)ives$/i, "$1ife"],
  [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)ves$/i, "$1f"],
  [/^(dwar|handkerchie|hoo|scar|whar)ves$/i, "$1f"],
  [/(antenn|formul|nebul|vertebr|vit)ae$/i, "$1a"],
  [/(octop|vir|radi|nucle|fung|cact|stimul)(i)$/i, "$1us"],
  [/(buffal|tomat|tornad)(oes)$/i, "$1o"],
  [/(ause)s$/i, "$1"],
  //causes
  [/(ease)s$/i, "$1"],
  //diseases
  [/(ious)es$/i, "$1"],
  //geniouses
  [/(ouse)s$/i, "$1"],
  //houses
  [/(ose)s$/i, "$1"],
  //roses
  [/(..ase)s$/i, "$1"],
  [/(..[aeiu]s)es$/i, "$1"],
  [/(vert|ind|cort)(ices)$/i, "$1ex"],
  [/(matr|append)(ices)$/i, "$1ix"],
  [/([xo]|ch|ss|sh)es$/i, "$1"],
  [/men$/i, "man"],
  [/(n)ews$/i, "$1ews"],
  [/([ti])a$/i, "$1um"],
  [/([^aeiouy]|qu)ies$/i, "$1y"],
  [/(s)eries$/i, "$1eries"],
  [/(m)ovies$/i, "$1ovie"],
  [/(cris|ax|test)es$/i, "$1is"],
  [/(alias|status)es$/i, "$1"],
  [/(ss)$/i, "$1"],
  [/(ic)s$/i, "$1"],
  [/s$/i, ""]
];

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toSingular/index.js
var invertObj = function(obj) {
  return Object.keys(obj).reduce((h2, k2) => {
    h2[obj[k2]] = k2;
    return h2;
  }, {});
};
var toSingular = function(str, model5) {
  const { irregularPlurals } = model5.two;
  let invert = invertObj(irregularPlurals);
  if (invert.hasOwnProperty(str)) {
    return invert[str];
  }
  for (let i3 = 0; i3 < rules_default2.length; i3++) {
    if (rules_default2[i3][0].test(str) === true) {
      str = str.replace(rules_default2[i3][0], rules_default2[i3][1]);
      return str;
    }
  }
  return str;
};
var toSingular_default = toSingular;

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/index.js
var all = function(str, model5) {
  let arr = [str];
  let p5 = toPlural_default(str, model5);
  if (p5 !== str) {
    arr.push(p5);
  }
  let s3 = toSingular_default(str, model5);
  if (s3 !== str) {
    arr.push(s3);
  }
  return arr;
};
var nouns_default2 = { toPlural: toPlural_default, toSingular: toSingular_default, all };

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/getTense/_guess.js
var guessVerb = {
  Gerund: ["ing"],
  Actor: ["erer"],
  Infinitive: [
    "ate",
    "ize",
    "tion",
    "rify",
    "then",
    "ress",
    "ify",
    "age",
    "nce",
    "ect",
    "ise",
    "ine",
    "ish",
    "ace",
    "ash",
    "ure",
    "tch",
    "end",
    "ack",
    "and",
    "ute",
    "ade",
    "ock",
    "ite",
    "ase",
    "ose",
    "use",
    "ive",
    "int",
    "nge",
    "lay",
    "est",
    "ain",
    "ant",
    "ent",
    "eed",
    "er",
    "le",
    "unk",
    "ung",
    "upt",
    "en"
  ],
  PastTense: ["ept", "ed", "lt", "nt", "ew", "ld"],
  PresentTense: [
    "rks",
    "cks",
    "nks",
    "ngs",
    "mps",
    "tes",
    "zes",
    "ers",
    "les",
    "acks",
    "ends",
    "ands",
    "ocks",
    "lays",
    "eads",
    "lls",
    "els",
    "ils",
    "ows",
    "nds",
    "ays",
    "ams",
    "ars",
    "ops",
    "ffs",
    "als",
    "urs",
    "lds",
    "ews",
    "ips",
    "es",
    "ts",
    "ns"
  ],
  Participle: ["ken", "wn"]
};
guessVerb = Object.keys(guessVerb).reduce((h2, k2) => {
  guessVerb[k2].forEach((a2) => h2[a2] = k2);
  return h2;
}, {});
var guess_default = guessVerb;

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/getTense/index.js
var getTense = function(str) {
  let three = str.substring(str.length - 3);
  if (guess_default.hasOwnProperty(three) === true) {
    return guess_default[three];
  }
  let two = str.substring(str.length - 2);
  if (guess_default.hasOwnProperty(two) === true) {
    return guess_default[two];
  }
  let one = str.substring(str.length - 1);
  if (one === "s") {
    return "PresentTense";
  }
  return null;
};
var getTense_default = getTense;

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/toInfinitive/index.js
var toParts = function(str, model5) {
  let prefix5 = "";
  let prefixes2 = {};
  if (model5.one && model5.one.prefixes) {
    prefixes2 = model5.one.prefixes;
  }
  let [verb, particle] = str.split(/ /);
  if (particle && prefixes2[verb] === true) {
    prefix5 = verb;
    verb = particle;
    particle = "";
  }
  return {
    prefix: prefix5,
    verb,
    particle
  };
};
var copulaMap = {
  are: "be",
  were: "be",
  been: "be",
  is: "be",
  am: "be",
  was: "be",
  be: "be",
  being: "be"
};
var toInfinitive = function(str, model5, tense) {
  const { fromPast: fromPast2, fromPresent: fromPresent2, fromGerund: fromGerund2, fromParticiple: fromParticiple2 } = model5.two.models;
  let { prefix: prefix5, verb, particle } = toParts(str, model5);
  let inf = "";
  if (!tense) {
    tense = getTense_default(str);
  }
  if (copulaMap.hasOwnProperty(str)) {
    inf = copulaMap[str];
  } else if (tense === "Participle") {
    inf = convert_default(verb, fromParticiple2);
  } else if (tense === "PastTense") {
    inf = convert_default(verb, fromPast2);
  } else if (tense === "PresentTense") {
    inf = convert_default(verb, fromPresent2);
  } else if (tense === "Gerund") {
    inf = convert_default(verb, fromGerund2);
  } else {
    return str;
  }
  if (particle) {
    inf += " " + particle;
  }
  if (prefix5) {
    inf = prefix5 + " " + inf;
  }
  return inf;
};
var toInfinitive_default = toInfinitive;

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/conjugate/index.js
var parse3 = (inf) => {
  if (/ /.test(inf)) {
    return inf.split(/ /);
  }
  return [inf, ""];
};
var conjugate = function(inf, model5) {
  const { toPast: toPast5, toPresent: toPresent4, toGerund: toGerund4, toParticiple: toParticiple2 } = model5.two.models;
  if (inf === "be") {
    return {
      Infinitive: inf,
      Gerund: "being",
      PastTense: "was",
      PresentTense: "is"
    };
  }
  let [str, particle] = parse3(inf);
  let found = {
    Infinitive: str,
    PastTense: convert_default(str, toPast5),
    PresentTense: convert_default(str, toPresent4),
    Gerund: convert_default(str, toGerund4),
    FutureTense: "will " + str
  };
  let pastPrt = convert_default(str, toParticiple2);
  if (pastPrt !== inf && pastPrt !== found.PastTense) {
    let lex = model5.one.lexicon || {};
    if (lex[pastPrt] === "Participle" || lex[pastPrt] === "Adjective") {
      if (inf === "play") {
        pastPrt = "played";
      }
      found.Participle = pastPrt;
    }
  }
  if (particle) {
    Object.keys(found).forEach((k2) => {
      found[k2] += " " + particle;
    });
  }
  return found;
};
var conjugate_default = conjugate;

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/index.js
var all2 = function(str, model5) {
  let res = conjugate_default(str, model5);
  delete res.FutureTense;
  return Object.values(res).filter((s3) => s3);
};
var verbs_default = {
  toInfinitive: toInfinitive_default,
  conjugate: conjugate_default,
  all: all2
};

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/inflect.js
var toSuperlative2 = function(adj, model5) {
  const mod = model5.two.models.toSuperlative;
  return convert_default(adj, mod);
};
var toComparative2 = function(adj, model5) {
  const mod = model5.two.models.toComparative;
  return convert_default(adj, mod);
};
var fromComparative2 = function(adj, model5) {
  const mod = model5.two.models.fromComparative;
  return convert_default(adj, mod);
};
var fromSuperlative2 = function(adj, model5) {
  const mod = model5.two.models.fromSuperlative;
  return convert_default(adj, mod);
};
var toNoun = function(adj, model5) {
  const mod = model5.two.models.adjToNoun;
  return convert_default(adj, mod);
};

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/conjugate/lib.js
var suffixLoop = function(str = "", suffixes5 = []) {
  const len = str.length;
  let max3 = len <= 6 ? len - 1 : 6;
  for (let i3 = max3; i3 >= 1; i3 -= 1) {
    let suffix = str.substring(len - i3, str.length);
    if (suffixes5[suffix.length].hasOwnProperty(suffix) === true) {
      let pre = str.slice(0, len - i3);
      let post = suffixes5[suffix.length][suffix];
      return pre + post;
    }
  }
  return null;
};
var lib_default6 = suffixLoop;

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/conjugate/fromAdverb.js
var s2 = "ically";
var ical = /* @__PURE__ */ new Set([
  "analyt" + s2,
  //analytical
  "chem" + s2,
  // chemical
  "class" + s2,
  //classical
  "clin" + s2,
  // clinical
  "crit" + s2,
  // critical
  "ecolog" + s2,
  // ecological
  "electr" + s2,
  // electrical
  "empir" + s2,
  // empirical
  "frant" + s2,
  // frantical
  "grammat" + s2,
  // grammatical
  "ident" + s2,
  // identical
  "ideolog" + s2,
  // ideological
  "log" + s2,
  // logical
  "mag" + s2,
  //magical
  "mathemat" + s2,
  // mathematical
  "mechan" + s2,
  // mechanical
  "med" + s2,
  // medical
  "method" + s2,
  // methodical
  "method" + s2,
  // methodical
  "mus" + s2,
  // musical
  "phys" + s2,
  // physical
  "phys" + s2,
  // physical
  "polit" + s2,
  // political
  "pract" + s2,
  // practical
  "rad" + s2,
  //radical
  "satir" + s2,
  // satirical
  "statist" + s2,
  // statistical
  "techn" + s2,
  // technical
  "technolog" + s2,
  // technological
  "theoret" + s2,
  // theoretical
  "typ" + s2,
  // typical
  "vert" + s2,
  // vertical
  "whims" + s2
  // whimsical
]);
var suffixes2 = [
  null,
  {},
  { "ly": "" },
  {
    "ily": "y",
    "bly": "ble",
    "ply": "ple"
  },
  {
    "ally": "al",
    "rply": "rp"
  },
  {
    "ually": "ual",
    "ially": "ial",
    "cally": "cal",
    "eally": "eal",
    "rally": "ral",
    "nally": "nal",
    "mally": "mal",
    "eeply": "eep",
    "eaply": "eap"
  },
  {
    ically: "ic"
  }
];
var noAdj = /* @__PURE__ */ new Set([
  "early",
  "only",
  "hourly",
  "daily",
  "weekly",
  "monthly",
  "yearly",
  "mostly",
  "duly",
  "unduly",
  "especially",
  "undoubtedly",
  "conversely",
  "namely",
  "exceedingly",
  "presumably",
  "accordingly",
  "overly",
  "best",
  "latter",
  "little",
  "long",
  "low"
]);
var exceptions = {
  wholly: "whole",
  fully: "full",
  truly: "true",
  gently: "gentle",
  singly: "single",
  customarily: "customary",
  idly: "idle",
  publically: "public",
  quickly: "quick",
  superbly: "superb",
  cynically: "cynical",
  well: "good"
  // -?
};
var toAdjective = function(str) {
  if (!str.endsWith("ly")) {
    return null;
  }
  if (ical.has(str)) {
    return str.replace(/ically/, "ical");
  }
  if (noAdj.has(str)) {
    return null;
  }
  if (exceptions.hasOwnProperty(str)) {
    return exceptions[str];
  }
  return lib_default6(str, suffixes2) || str;
};
var fromAdverb_default = toAdjective;

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/conjugate/toAdverb.js
var suffixes3 = [
  null,
  {
    y: "ily"
  },
  {
    ly: "ly",
    //unchanged
    ic: "ically"
  },
  {
    ial: "ially",
    ual: "ually",
    tle: "tly",
    ble: "bly",
    ple: "ply",
    ary: "arily"
  },
  {},
  {},
  {}
];
var exceptions2 = {
  cool: "cooly",
  whole: "wholly",
  full: "fully",
  good: "well",
  idle: "idly",
  public: "publicly",
  single: "singly",
  special: "especially"
};
var toAdverb = function(str) {
  if (exceptions2.hasOwnProperty(str)) {
    return exceptions2[str];
  }
  let adv = lib_default6(str, suffixes3);
  if (!adv) {
    adv = str + "ly";
  }
  return adv;
};
var toAdverb_default = toAdverb;

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/index.js
var all3 = function(str, model5) {
  let arr = [str];
  arr.push(toSuperlative2(str, model5));
  arr.push(toComparative2(str, model5));
  arr.push(toAdverb_default(str));
  arr = arr.filter((s3) => s3);
  arr = new Set(arr);
  return Array.from(arr);
};
var adjectives_default = {
  toSuperlative: toSuperlative2,
  toComparative: toComparative2,
  toAdverb: toAdverb_default,
  toNoun,
  fromAdverb: fromAdverb_default,
  fromSuperlative: fromSuperlative2,
  fromComparative: fromComparative2,
  all: all3
};

// ../../node_modules/compromise/src/2-two/preTagger/methods/transform/index.js
var transform_default = {
  noun: nouns_default2,
  verb: verbs_default,
  adjective: adjectives_default
};

// ../../node_modules/compromise/src/2-two/preTagger/methods/expand/byTag.js
var byTag_default = {
  // add plural forms of singular nouns
  Singular: (word, lex, methods18, model5) => {
    let already = model5.one.lexicon;
    let plural2 = methods18.two.transform.noun.toPlural(word, model5);
    if (!already[plural2]) {
      lex[plural2] = lex[plural2] || "Plural";
    }
  },
  // 'lawyer', 'manager' plural forms
  Actor: (word, lex, methods18, model5) => {
    let already = model5.one.lexicon;
    let plural2 = methods18.two.transform.noun.toPlural(word, model5);
    if (!already[plural2]) {
      lex[plural2] = lex[plural2] || ["Plural", "Actor"];
    }
  },
  // superlative/ comparative forms for adjectives
  Comparable: (word, lex, methods18, model5) => {
    let already = model5.one.lexicon;
    let { toSuperlative: toSuperlative3, toComparative: toComparative3 } = methods18.two.transform.adjective;
    let sup = toSuperlative3(word, model5);
    if (!already[sup]) {
      lex[sup] = lex[sup] || "Superlative";
    }
    let comp = toComparative3(word, model5);
    if (!already[comp]) {
      lex[comp] = lex[comp] || "Comparative";
    }
    lex[word] = "Adjective";
  },
  // 'german' -> 'germans'
  Demonym: (word, lex, methods18, model5) => {
    let plural2 = methods18.two.transform.noun.toPlural(word, model5);
    lex[plural2] = lex[plural2] || ["Demonym", "Plural"];
  },
  // conjugate all forms of these verbs
  Infinitive: (word, lex, methods18, model5) => {
    let already = model5.one.lexicon;
    let all4 = methods18.two.transform.verb.conjugate(word, model5);
    Object.entries(all4).forEach((a2) => {
      if (!already[a2[1]] && !lex[a2[1]]) {
        lex[a2[1]] = a2[0];
      }
    });
  },
  // 'walk up' should conjugate, too
  PhrasalVerb: (word, lex, methods18, model5) => {
    let already = model5.one.lexicon;
    lex[word] = ["PhrasalVerb", "Infinitive"];
    let _multi = model5.one._multiCache;
    let [inf, rest] = word.split(" ");
    if (!already[inf]) {
      lex[inf] = lex[inf] || "Infinitive";
    }
    let all4 = methods18.two.transform.verb.conjugate(inf, model5);
    delete all4.FutureTense;
    Object.entries(all4).forEach((a2) => {
      if (a2[0] === "Actor" || a2[1] === "") {
        return;
      }
      if (!lex[a2[1]] && !already[a2[1]]) {
        lex[a2[1]] = a2[0];
      }
      _multi[a2[1]] = true;
      let str = a2[1] + " " + rest;
      lex[str] = lex[str] || [a2[0], "PhrasalVerb"];
    });
  },
  // expand 'million'
  Multiple: (word, lex) => {
    lex[word] = ["Multiple", "Cardinal"];
    lex[word + "th"] = ["Multiple", "Ordinal"];
    lex[word + "ths"] = ["Multiple", "Fraction"];
  },
  // expand number-words
  Cardinal: (word, lex) => {
    lex[word] = ["TextValue", "Cardinal"];
  },
  // 'millionth'
  Ordinal: (word, lex) => {
    lex[word] = ["TextValue", "Ordinal"];
    lex[word + "s"] = ["TextValue", "Fraction"];
  },
  // 'thames'
  Place: (word, lex) => {
    lex[word] = ["Place", "ProperNoun"];
  },
  // 'ontario'
  Region: (word, lex) => {
    lex[word] = ["Region", "ProperNoun"];
  }
};

// ../../node_modules/compromise/src/2-two/preTagger/methods/expand/index.js
var expand3 = function(words, world2) {
  const { methods: methods18, model: model5 } = world2;
  let lex = {};
  let _multi = {};
  Object.keys(words).forEach((word) => {
    let tag = words[word];
    word = word.toLowerCase().trim();
    word = word.replace(/'s\b/, "");
    let split3 = word.split(/ /);
    if (split3.length > 1) {
      _multi[split3[0]] = true;
    }
    if (byTag_default.hasOwnProperty(tag) === true) {
      byTag_default[tag](word, lex, methods18, model5);
    }
    lex[word] = lex[word] || tag;
  });
  delete lex[""];
  delete lex[null];
  delete lex[" "];
  return { lex, _multi };
};
var expand_default2 = expand3;

// ../../node_modules/compromise/src/2-two/preTagger/methods/quickSplit.js
var splitOn = function(terms, i3) {
  const isNum = /^[0-9]+$/;
  let term = terms[i3];
  if (!term) {
    return false;
  }
  const maybeDate = /* @__PURE__ */ new Set(["may", "april", "august", "jan"]);
  if (term.normal === "like" || maybeDate.has(term.normal)) {
    return false;
  }
  if (term.tags.has("Place") || term.tags.has("Date")) {
    return false;
  }
  if (terms[i3 - 1]) {
    let lastTerm = terms[i3 - 1];
    if (lastTerm.tags.has("Date") || maybeDate.has(lastTerm.normal)) {
      return false;
    }
    if (lastTerm.tags.has("Adjective") || term.tags.has("Adjective")) {
      return false;
    }
  }
  let str = term.normal;
  if (str.length === 1 || str.length === 2 || str.length === 4) {
    if (isNum.test(str)) {
      return false;
    }
  }
  return true;
};
var quickSplit = function(document) {
  const splitHere = /[,:;]/;
  let arr = [];
  document.forEach((terms) => {
    let start2 = 0;
    terms.forEach((term, i3) => {
      if (splitHere.test(term.post) && splitOn(terms, i3 + 1)) {
        arr.push(terms.slice(start2, i3 + 1));
        start2 = i3 + 1;
      }
    });
    if (start2 < terms.length) {
      arr.push(terms.slice(start2, terms.length));
    }
  });
  return arr;
};
var quickSplit_default = quickSplit;

// ../../node_modules/compromise/src/2-two/preTagger/methods/looksPlural.js
var isPlural = {
  e: [
    "mice",
    "louse",
    "antennae",
    "formulae",
    "nebulae",
    "vertebrae",
    "vitae"
  ],
  i: [
    "tia",
    "octopi",
    "viri",
    "radii",
    "nuclei",
    "fungi",
    "cacti",
    "stimuli"
  ],
  n: [
    "men"
  ],
  t: [
    "feet"
  ]
};
var exceptions3 = /* @__PURE__ */ new Set([
  // 'formulas',
  // 'umbrellas',
  // 'gorillas',
  // 'koalas',
  "israelis",
  "menus"
]);
var notPlural = [
  "bus",
  "mas",
  //christmas
  "was",
  // 'las',
  "ias",
  //alias
  "xas",
  "vas",
  "cis",
  //probocis
  "lis",
  "nis",
  //tennis
  "ois",
  "ris",
  "sis",
  //thesis
  "tis",
  //mantis, testis
  "xis",
  "aus",
  "cus",
  "eus",
  //nucleus
  "fus",
  //doofus
  "gus",
  //fungus
  "ius",
  //radius
  "lus",
  //stimulus
  "nus",
  "ous",
  "pus",
  //octopus
  "rus",
  //virus
  "sus",
  //census
  "tus",
  //status,cactus
  "xus",
  "'s",
  "ss"
];
var looksPlural = function(str) {
  if (!str || str.length <= 3) {
    return false;
  }
  if (exceptions3.has(str)) {
    return true;
  }
  let end2 = str[str.length - 1];
  if (isPlural.hasOwnProperty(end2)) {
    return isPlural[end2].find((suff) => str.endsWith(suff));
  }
  if (end2 !== "s") {
    return false;
  }
  if (notPlural.find((suff) => str.endsWith(suff))) {
    return false;
  }
  return true;
};
var looksPlural_default = looksPlural;

// ../../node_modules/compromise/src/2-two/preTagger/methods/index.js
var methods_default10 = {
  two: {
    quickSplit: quickSplit_default,
    expandLexicon: expand_default2,
    transform: transform_default,
    looksPlural: looksPlural_default
  }
};

// ../../node_modules/compromise/src/2-two/preTagger/model/_expand/irregulars.js
var expandIrregulars = function(model5) {
  const { irregularPlurals } = model5.two;
  const { lexicon: lexicon4 } = model5.one;
  Object.entries(irregularPlurals).forEach((a2) => {
    lexicon4[a2[0]] = lexicon4[a2[0]] || "Singular";
    lexicon4[a2[1]] = lexicon4[a2[1]] || "Plural";
  });
  return model5;
};
var irregulars_default = expandIrregulars;

// ../../node_modules/compromise/src/2-two/preTagger/model/_expand/index.js
var tmpModel2 = {
  one: { lexicon: {} },
  two: { models: models_default }
};
var switchDefaults = {
  // 'pilot'
  "Actor|Verb": "Actor",
  //
  // 'amusing'
  "Adj|Gerund": "Adjective",
  //+conjugations
  // 'standard'
  "Adj|Noun": "Adjective",
  // 'boiled'
  "Adj|Past": "Adjective",
  //+conjugations
  // 'smooth'
  "Adj|Present": "Adjective",
  //+conjugations
  // 'box'
  "Noun|Verb": "Singular",
  //+conjugations (no-present)
  //'singing'
  "Noun|Gerund": "Gerund",
  //+conjugations
  // 'hope'
  "Person|Noun": "Noun",
  // 'April'
  "Person|Date": "Month",
  // 'rob'
  "Person|Verb": "FirstName",
  //+conjugations
  // 'victoria'
  "Person|Place": "Person",
  // 'rusty'
  "Person|Adj": "Comparative",
  // 'boxes'
  "Plural|Verb": "Plural",
  //(these are already derivative)
  // 'miles'
  "Unit|Noun": "Noun"
};
var expandLexicon = function(words, model5) {
  const world2 = { model: model5, methods: methods_default10 };
  let { lex, _multi } = methods_default10.two.expandLexicon(words, world2);
  Object.assign(model5.one.lexicon, lex);
  Object.assign(model5.one._multiCache, _multi);
  return model5;
};
var addUncountables = function(words, model5) {
  Object.keys(words).forEach((k2) => {
    if (words[k2] === "Uncountable") {
      model5.two.uncountable[k2] = true;
      words[k2] = "Uncountable";
    }
  });
  return model5;
};
var expandVerb = function(str, words, doPresent) {
  let obj = conjugate_default(str, tmpModel2);
  words[obj.PastTense] = words[obj.PastTense] || "PastTense";
  words[obj.Gerund] = words[obj.Gerund] || "Gerund";
  if (doPresent === true) {
    words[obj.PresentTense] = words[obj.PresentTense] || "PresentTense";
  }
};
var expandAdjective = function(str, words, model5) {
  let sup = toSuperlative2(str, model5);
  words[sup] = words[sup] || "Superlative";
  let comp = toComparative2(str, model5);
  words[comp] = words[comp] || "Comparative";
};
var expandNoun = function(str, words, model5) {
  let plur = toPlural_default(str, model5);
  words[plur] = words[plur] || "Plural";
};
var expandVariable = function(switchWords, model5) {
  let words = {};
  const lex = model5.one.lexicon;
  Object.keys(switchWords).forEach((w) => {
    const name = switchWords[w];
    words[w] = switchDefaults[name];
    if (name === "Noun|Verb" || name === "Person|Verb" || name === "Actor|Verb") {
      expandVerb(w, lex, false);
    }
    if (name === "Adj|Present") {
      expandVerb(w, lex, true);
      expandAdjective(w, lex, model5);
    }
    if (name === "Person|Adj") {
      expandAdjective(w, lex, model5);
    }
    if (name === "Adj|Gerund" || name === "Noun|Gerund") {
      let inf = toInfinitive_default(w, tmpModel2, "Gerund");
      if (!lex[inf]) {
        words[inf] = "Infinitive";
      }
    }
    if (name === "Noun|Gerund" || name === "Adj|Noun" || name === "Person|Noun") {
      expandNoun(w, lex, model5);
    }
    if (name === "Adj|Past") {
      let inf = toInfinitive_default(w, tmpModel2, "PastTense");
      if (!lex[inf]) {
        words[inf] = "Infinitive";
      }
    }
  });
  model5 = expandLexicon(words, model5);
  return model5;
};
var expand4 = function(model5) {
  model5 = expandLexicon(model5.one.lexicon, model5);
  model5 = addUncountables(model5.one.lexicon, model5);
  model5 = expandVariable(model5.two.switches, model5);
  model5 = irregulars_default(model5);
  return model5;
};
var expand_default3 = expand4;

// ../../node_modules/compromise/src/2-two/preTagger/model/index.js
var model4 = {
  one: {
    _multiCache: {},
    lexicon: lexicon3
  },
  two: {
    irregularPlurals: plurals_default,
    models: models_default,
    suffixPatterns: suffixes_default2,
    prefixPatterns: prefixes_default2,
    endsWith: endsWith_default,
    neighbours: neighbours_default,
    regexNormal: regex_normal_default,
    regexText: regex_text_default,
    regexNumbers: regex_numbers_default,
    switches,
    clues: clues_default,
    uncountable: {},
    orgWords: orgWords_default
  }
};
model4 = expand_default3(model4);
var model_default3 = model4;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/1st-pass/01-colons.js
var byPunctuation = function(terms, i3, model5, world2) {
  const setTag3 = world2.methods.one.setTag;
  if (i3 === 0 && terms.length >= 3) {
    const hasColon = /:/;
    let post = terms[0].post;
    if (post.match(hasColon)) {
      let nextTerm = terms[1];
      if (nextTerm.tags.has("Value") || nextTerm.tags.has("Email") || nextTerm.tags.has("PhoneNumber")) {
        return;
      }
      setTag3([terms[0]], "Expression", world2, null, `2-punct-colon''`);
    }
  }
};
var colons_default = byPunctuation;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/1st-pass/02-hyphens.js
var byHyphen = function(terms, i3, model5, world2) {
  const setTag3 = world2.methods.one.setTag;
  if (terms[i3].post === "-" && terms[i3 + 1]) {
    setTag3([terms[i3], terms[i3 + 1]], "Hyphenated", world2, null, `1-punct-hyphen''`);
  }
};
var hyphens_default = byHyphen;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/00-tagSwitch.js
var prefix3 = /^(under|over|mis|re|un|dis|semi)-?/;
var tagSwitch = function(terms, i3, model5) {
  const switches2 = model5.two.switches;
  let term = terms[i3];
  if (switches2.hasOwnProperty(term.normal)) {
    term.switch = switches2[term.normal];
    return;
  }
  if (prefix3.test(term.normal)) {
    let stem = term.normal.replace(prefix3, "");
    if (stem.length > 3 && switches2.hasOwnProperty(stem)) {
      term.switch = switches2[stem];
    }
  }
};
var tagSwitch_default = tagSwitch;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/_fastTag.js
var log2 = (term, tag, reason = "") => {
  const yellow = (str) => "\x1B[33m\x1B[3m" + str + "\x1B[0m";
  const i3 = (str) => "\x1B[3m" + str + "\x1B[0m";
  let word = term.text || "[" + term.implicit + "]";
  if (typeof tag !== "string" && tag.length > 2) {
    tag = tag.slice(0, 2).join(", #") + " +";
  }
  tag = typeof tag !== "string" ? tag.join(", #") : tag;
  console.log(` ${yellow(word).padEnd(24)} \x1B[32m→\x1B[0m #${tag.padEnd(22)}  ${i3(reason)}`);
};
var setTag2 = function(term, tag, reason) {
  if (!tag || tag.length === 0) {
    return;
  }
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2 && env2.DEBUG_TAGS) {
    log2(term, tag, reason);
  }
  term.tags = term.tags || /* @__PURE__ */ new Set();
  if (typeof tag === "string") {
    term.tags.add(tag);
  } else {
    tag.forEach((tg) => term.tags.add(tg));
  }
};
var fastTag_default = setTag2;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/_fillTags.js
var uncountable = [
  "Acronym",
  "Abbreviation",
  "ProperNoun",
  "Uncountable",
  "Possessive",
  "Pronoun",
  "Activity",
  "Honorific",
  "Month"
];
var setPluralSingular = function(term) {
  if (!term.tags.has("Noun") || term.tags.has("Plural") || term.tags.has("Singular")) {
    return;
  }
  if (uncountable.find((tag) => term.tags.has(tag))) {
    return;
  }
  if (looksPlural_default(term.normal)) {
    fastTag_default(term, "Plural", "3-plural-guess");
  } else {
    fastTag_default(term, "Singular", "3-singular-guess");
  }
};
var setTense = function(term) {
  let tags = term.tags;
  if (tags.has("Verb") && tags.size === 1) {
    let guess = getTense_default(term.normal);
    if (guess) {
      fastTag_default(term, guess, "3-verb-tense-guess");
    }
  }
};
var fillTags = function(terms, i3, model5) {
  let term = terms[i3];
  let tags = Array.from(term.tags);
  for (let k2 = 0; k2 < tags.length; k2 += 1) {
    if (model5.one.tagSet[tags[k2]]) {
      let toAdd = model5.one.tagSet[tags[k2]].parents;
      fastTag_default(term, toAdd, ` -inferred by #${tags[k2]}`);
    }
  }
  setPluralSingular(term);
  setTense(term, model5);
};
var fillTags_default = fillTags;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/01-case.js
var titleCase3 = /^\p{Lu}[\p{Ll}'’]/u;
var hasNumber = /[0-9]/;
var notProper = ["Date", "Month", "WeekDay", "Unit", "Expression"];
var hasIVX = /[IVX]/;
var romanNumeral = /^[IVXLCDM]{2,}$/;
var romanNumValid = /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/;
var nope = {
  li: true,
  dc: true,
  md: true,
  dm: true,
  ml: true
};
var checkCase = function(terms, i3, model5) {
  let term = terms[i3];
  term.index = term.index || [0, 0];
  let index3 = term.index[1];
  let str = term.text || "";
  if (index3 !== 0 && titleCase3.test(str) === true && hasNumber.test(str) === false) {
    if (notProper.find((tag) => term.tags.has(tag))) {
      return null;
    }
    if (term.pre.match(/["']$/)) {
      return null;
    }
    if (term.normal === "the") {
      return null;
    }
    fillTags_default(terms, i3, model5);
    if (!term.tags.has("Noun")) {
      term.tags.clear();
    }
    fastTag_default(term, "ProperNoun", "2-titlecase");
    return true;
  }
  if (str.length >= 2 && romanNumeral.test(str) && hasIVX.test(str) && romanNumValid.test(str) && !nope[term.normal]) {
    fastTag_default(term, "RomanNumeral", "2-xvii");
    return true;
  }
  return null;
};
var case_default2 = checkCase;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/02-suffix.js
var suffixLoop2 = function(str = "", suffixes5 = []) {
  const len = str.length;
  let max3 = 7;
  if (len <= max3) {
    max3 = len - 1;
  }
  for (let i3 = max3; i3 > 1; i3 -= 1) {
    let suffix = str.substring(len - i3, len);
    if (suffixes5[suffix.length].hasOwnProperty(suffix) === true) {
      let tag = suffixes5[suffix.length][suffix];
      return tag;
    }
  }
  return null;
};
var tagBySuffix = function(terms, i3, model5) {
  let term = terms[i3];
  if (term.tags.size === 0) {
    let tag = suffixLoop2(term.normal, model5.two.suffixPatterns);
    if (tag !== null) {
      fastTag_default(term, tag, "2-suffix");
      term.confidence = 0.7;
      return true;
    }
    if (term.implicit) {
      tag = suffixLoop2(term.implicit, model5.two.suffixPatterns);
      if (tag !== null) {
        fastTag_default(term, tag, "2-implicit-suffix");
        term.confidence = 0.7;
        return true;
      }
    }
  }
  return null;
};
var suffix_default = tagBySuffix;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/03-regex.js
var hasApostrophe = /['‘’‛‵′`´]/;
var doRegs = function(str, regs) {
  for (let i3 = 0; i3 < regs.length; i3 += 1) {
    if (regs[i3][0].test(str) === true) {
      return regs[i3];
    }
  }
  return null;
};
var doEndsWith = function(str = "", byEnd3) {
  let char = str[str.length - 1];
  if (byEnd3.hasOwnProperty(char) === true) {
    let regs = byEnd3[char] || [];
    for (let r2 = 0; r2 < regs.length; r2 += 1) {
      if (regs[r2][0].test(str) === true) {
        return regs[r2];
      }
    }
  }
  return null;
};
var checkRegex = function(terms, i3, model5, world2) {
  const setTag3 = world2.methods.one.setTag;
  let { regexText, regexNormal, regexNumbers, endsWith } = model5.two;
  let term = terms[i3];
  let normal = term.machine || term.normal;
  let text = term.text;
  if (hasApostrophe.test(term.post) && !hasApostrophe.test(term.pre)) {
    text += term.post.trim();
  }
  let arr = doRegs(text, regexText) || doRegs(normal, regexNormal);
  if (!arr && /[0-9]/.test(normal)) {
    arr = doRegs(normal, regexNumbers);
  }
  if (!arr && term.tags.size === 0) {
    arr = doEndsWith(normal, endsWith);
  }
  if (arr) {
    setTag3([term], arr[1], world2, null, `2-regex-'${arr[2] || arr[0]}'`);
    term.confidence = 0.6;
    return true;
  }
  return null;
};
var regex_default = checkRegex;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/04-prefix.js
var prefixLoop = function(str = "", prefixes2 = []) {
  const len = str.length;
  let max3 = 7;
  if (max3 > len - 3) {
    max3 = len - 3;
  }
  for (let i3 = max3; i3 > 2; i3 -= 1) {
    let prefix5 = str.substring(0, i3);
    if (prefixes2[prefix5.length].hasOwnProperty(prefix5) === true) {
      let tag = prefixes2[prefix5.length][prefix5];
      return tag;
    }
  }
  return null;
};
var checkPrefix = function(terms, i3, model5) {
  let term = terms[i3];
  if (term.tags.size === 0) {
    let tag = prefixLoop(term.normal, model5.two.prefixPatterns);
    if (tag !== null) {
      fastTag_default(term, tag, "2-prefix");
      term.confidence = 0.5;
      return true;
    }
  }
  return null;
};
var prefix_default = checkPrefix;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/05-year.js
var min = 1400;
var max2 = 2100;
var dateWords = /* @__PURE__ */ new Set([
  "in",
  "on",
  "by",
  "until",
  "for",
  "to",
  "during",
  "throughout",
  "through",
  "within",
  "before",
  "after",
  "of",
  "this",
  "next",
  "last",
  "circa",
  "around",
  "post",
  "pre",
  "budget",
  "classic",
  "plan",
  "may"
]);
var seemsGood = function(term) {
  if (!term) {
    return false;
  }
  let str = term.normal || term.implicit;
  if (dateWords.has(str)) {
    return true;
  }
  if (term.tags.has("Date") || term.tags.has("Month") || term.tags.has("WeekDay") || term.tags.has("Year")) {
    return true;
  }
  if (term.tags.has("ProperNoun")) {
    return true;
  }
  return false;
};
var seemsOkay = function(term) {
  if (!term) {
    return false;
  }
  if (term.tags.has("Ordinal")) {
    return true;
  }
  if (term.tags.has("Cardinal") && term.normal.length < 3) {
    return true;
  }
  if (term.normal === "is" || term.normal === "was") {
    return true;
  }
  return false;
};
var seemsFine = function(term) {
  return term && (term.tags.has("Date") || term.tags.has("Month") || term.tags.has("WeekDay") || term.tags.has("Year"));
};
var tagYear = function(terms, i3) {
  const term = terms[i3];
  if (term.tags.has("NumericValue") && term.tags.has("Cardinal") && term.normal.length === 4) {
    let num = Number(term.normal);
    if (num && !isNaN(num)) {
      if (num > min && num < max2) {
        let lastTerm = terms[i3 - 1];
        let nextTerm = terms[i3 + 1];
        if (seemsGood(lastTerm) || seemsGood(nextTerm)) {
          return fastTag_default(term, "Year", "2-tagYear");
        }
        if (num >= 1920 && num < 2025) {
          if (seemsOkay(lastTerm) || seemsOkay(nextTerm)) {
            return fastTag_default(term, "Year", "2-tagYear-close");
          }
          if (seemsFine(terms[i3 - 2]) || seemsFine(terms[i3 + 2])) {
            return fastTag_default(term, "Year", "2-tagYear-far");
          }
          if (lastTerm && (lastTerm.tags.has("Determiner") || lastTerm.tags.has("Possessive"))) {
            if (nextTerm && nextTerm.tags.has("Noun") && !nextTerm.tags.has("Plural")) {
              return fastTag_default(term, "Year", "2-tagYear-noun");
            }
          }
        }
      }
    }
  }
  return null;
};
var year_default = tagYear;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/06-verb-type.js
var verbType = function(terms, i3, model5, world2) {
  const setTag3 = world2.methods.one.setTag;
  const term = terms[i3];
  const types = ["PastTense", "PresentTense", "Auxiliary", "Modal", "Particle"];
  if (term.tags.has("Verb")) {
    let type = types.find((typ) => term.tags.has(typ));
    if (!type) {
      setTag3([term], "Infinitive", world2, null, `2-verb-type''`);
    }
  }
};
var verb_type_default = verbType;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/01-acronym.js
var oneLetterAcronym2 = /^[A-Z]('s|,)?$/;
var isUpperCase = /^[A-Z-]+$/;
var upperThenS = /^[A-Z]+s$/;
var periodAcronym2 = /([A-Z]\.)+[A-Z]?,?$/;
var noPeriodAcronym2 = /[A-Z]{2,}('s|,)?$/;
var lowerCaseAcronym2 = /([a-z]\.)+[a-z]\.?$/;
var oneLetterWord = {
  I: true,
  A: true
};
var places = {
  la: true,
  ny: true,
  us: true,
  dc: true,
  gb: true
};
var isNoPeriodAcronym = function(term, model5) {
  let str = term.text;
  if (isUpperCase.test(str) === false) {
    if (str.length > 3 && upperThenS.test(str) === true) {
      str = str.replace(/s$/, "");
    } else {
      return false;
    }
  }
  if (str.length > 5) {
    return false;
  }
  if (oneLetterWord.hasOwnProperty(str)) {
    return false;
  }
  if (model5.one.lexicon.hasOwnProperty(term.normal)) {
    return false;
  }
  if (periodAcronym2.test(str) === true) {
    return true;
  }
  if (lowerCaseAcronym2.test(str) === true) {
    return true;
  }
  if (oneLetterAcronym2.test(str) === true) {
    return true;
  }
  if (noPeriodAcronym2.test(str) === true) {
    return true;
  }
  return false;
};
var isAcronym3 = function(terms, i3, model5) {
  let term = terms[i3];
  if (term.tags.has("RomanNumeral") || term.tags.has("Acronym")) {
    return null;
  }
  if (isNoPeriodAcronym(term, model5)) {
    term.tags.clear();
    fastTag_default(term, ["Acronym", "Noun"], "3-no-period-acronym");
    if (places[term.normal] === true) {
      fastTag_default(term, "Place", "3-place-acronym");
    }
    if (upperThenS.test(term.text) === true) {
      fastTag_default(term, "Plural", "3-plural-acronym");
    }
    return true;
  }
  if (!oneLetterWord.hasOwnProperty(term.text) && oneLetterAcronym2.test(term.text)) {
    term.tags.clear();
    fastTag_default(term, ["Acronym", "Noun"], "3-one-letter-acronym");
    return true;
  }
  if (term.tags.has("Organization") && term.text.length <= 3) {
    fastTag_default(term, "Acronym", "3-org-acronym");
    return true;
  }
  if (term.tags.has("Organization") && isUpperCase.test(term.text) && term.text.length <= 6) {
    fastTag_default(term, "Acronym", "3-titlecase-acronym");
    return true;
  }
  return null;
};
var acronym_default = isAcronym3;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/02-neighbours.js
var lookAtWord = function(term, words) {
  if (!term) {
    return null;
  }
  let found = words.find((a2) => term.normal === a2[0]);
  if (found) {
    return found[1];
  }
  return null;
};
var lookAtTag = function(term, tags) {
  if (!term) {
    return null;
  }
  let found = tags.find((a2) => term.tags.has(a2[0]));
  if (found) {
    return found[1];
  }
  return null;
};
var neighbours = function(terms, i3, model5) {
  const { leftTags, leftWords, rightWords, rightTags } = model5.two.neighbours;
  let term = terms[i3];
  if (term.tags.size === 0) {
    let tag = null;
    tag = tag || lookAtWord(terms[i3 - 1], leftWords);
    tag = tag || lookAtWord(terms[i3 + 1], rightWords);
    tag = tag || lookAtTag(terms[i3 - 1], leftTags);
    tag = tag || lookAtTag(terms[i3 + 1], rightTags);
    if (tag) {
      fastTag_default(term, tag, "3-[neighbour]");
      fillTags_default(terms, i3, model5);
      terms[i3].confidence = 0.2;
      return true;
    }
  }
  return null;
};
var neighbours_default2 = neighbours;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/03-orgWords.js
var isTitleCase2 = (str) => /^\p{Lu}[\p{Ll}'’]/u.test(str);
var isOrg = function(term, i3, yelling) {
  if (!term) {
    return false;
  }
  if (term.tags.has("FirstName") || term.tags.has("Place")) {
    return false;
  }
  if (term.tags.has("ProperNoun") || term.tags.has("Organization") || term.tags.has("Acronym")) {
    return true;
  }
  if (!yelling && isTitleCase2(term.text)) {
    if (i3 === 0) {
      return term.tags.has("Singular");
    }
    return true;
  }
  return false;
};
var tagOrgs = function(terms, i3, world2, yelling) {
  const orgWords = world2.model.two.orgWords;
  const setTag3 = world2.methods.one.setTag;
  let term = terms[i3];
  let str = term.machine || term.normal;
  if (orgWords[str] === true && isOrg(terms[i3 - 1], i3 - 1, yelling)) {
    setTag3([terms[i3]], "Organization", world2, null, "3-[org-word]");
    for (let t3 = i3; t3 >= 0; t3 -= 1) {
      if (isOrg(terms[t3], t3, yelling)) {
        setTag3([terms[t3]], "Organization", world2, null, "3-[org-word]");
      } else {
        break;
      }
    }
  }
  return null;
};
var orgWords_default2 = tagOrgs;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/04-fallback.js
var nounFallback = function(terms, i3, model5) {
  let isEmpty = false;
  let tags = terms[i3].tags;
  if (tags.size === 0) {
    isEmpty = true;
  } else if (tags.size === 1) {
    if (tags.has("Hyphenated") || tags.has("HashTag") || tags.has("Prefix")) {
      isEmpty = true;
    }
  }
  if (isEmpty) {
    fastTag_default(terms[i3], "Noun", "3-[fallback]");
    fillTags_default(terms, i3, model5);
    terms[i3].confidence = 0.1;
  }
};
var fallback_default = nounFallback;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/_adhoc.js
var isTitleCase3 = /^[A-Z][a-z]/;
var isCapital = (terms, i3) => {
  if (terms[i3].tags.has("ProperNoun") && isTitleCase3.test(terms[i3].text)) {
    return "Noun";
  }
  return null;
};
var isAlone = (terms, i3, tag) => {
  if (i3 === 0 && !terms[1]) {
    return tag;
  }
  return null;
};
var isEndNoun = function(terms, i3) {
  if (!terms[i3 + 1] && terms[i3 - 1] && terms[i3 - 1].tags.has("Determiner")) {
    return "Noun";
  }
  return null;
};
var isStart = function(terms, i3, tag) {
  if (i3 === 0 && terms.length > 3) {
    return tag;
  }
  return null;
};
var adhoc = {
  "Adj|Gerund": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Adj|Noun": (terms, i3) => {
    return isCapital(terms, i3) || isEndNoun(terms, i3);
  },
  "Actor|Verb": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Adj|Past": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Adj|Present": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Noun|Gerund": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Noun|Verb": (terms, i3) => {
    return i3 > 0 && isCapital(terms, i3) || isAlone(terms, i3, "Infinitive");
  },
  "Plural|Verb": (terms, i3) => {
    return isCapital(terms, i3) || isAlone(terms, i3, "PresentTense") || isStart(terms, i3, "Plural");
  },
  "Person|Noun": (terms, i3) => {
    return isCapital(terms, i3);
  },
  "Person|Verb": (terms, i3) => {
    if (i3 !== 0) {
      return isCapital(terms, i3);
    }
    return null;
  },
  "Person|Adj": (terms, i3) => {
    if (i3 === 0 && terms.length > 1) {
      return "Person";
    }
    return isCapital(terms, i3) ? "Person" : null;
  }
};
var adhoc_default = adhoc;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/06-switches.js
var env = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
var prefix4 = /^(under|over|mis|re|un|dis|semi)-?/;
var checkWord = (term, obj) => {
  if (!term || !obj) {
    return null;
  }
  let str = term.normal || term.implicit;
  let found = null;
  if (obj.hasOwnProperty(str)) {
    found = obj[str];
  }
  if (found && env.DEBUG_TAGS) {
    console.log(`
  \x1B[2m\x1B[3m     ↓ - '${str}' \x1B[0m`);
  }
  return found;
};
var checkTag = (term, obj = {}, tagSet) => {
  if (!term || !obj) {
    return null;
  }
  let tags = Array.from(term.tags).sort((a2, b) => {
    let numA = tagSet[a2] ? tagSet[a2].parents.length : 0;
    let numB = tagSet[b] ? tagSet[b].parents.length : 0;
    return numA > numB ? -1 : 1;
  });
  let found = tags.find((tag) => obj[tag]);
  if (found && env.DEBUG_TAGS) {
    console.log(`  \x1B[2m\x1B[3m      ↓ - '${term.normal || term.implicit}' (#${found})  \x1B[0m`);
  }
  found = obj[found];
  return found;
};
var pickTag = function(terms, i3, clues5, model5) {
  if (!clues5) {
    return null;
  }
  const tagSet = model5.one.tagSet;
  let tag = checkWord(terms[i3 + 1], clues5.afterWords);
  tag = tag || checkWord(terms[i3 - 1], clues5.beforeWords);
  tag = tag || checkTag(terms[i3 - 1], clues5.beforeTags, tagSet);
  tag = tag || checkTag(terms[i3 + 1], clues5.afterTags, tagSet);
  return tag;
};
var doSwitches = function(terms, i3, world2) {
  const model5 = world2.model;
  const setTag3 = world2.methods.one.setTag;
  const { switches: switches2, clues: clues5 } = model5.two;
  const term = terms[i3];
  let str = term.normal || term.implicit || "";
  if (prefix4.test(str) && !switches2[str]) {
    str = str.replace(prefix4, "");
  }
  if (term.switch) {
    let form = term.switch;
    if (term.tags.has("Acronym") || term.tags.has("PhrasalVerb")) {
      return;
    }
    let tag = pickTag(terms, i3, clues5[form], model5);
    if (adhoc_default[form]) {
      tag = adhoc_default[form](terms, i3) || tag;
    }
    if (tag) {
      setTag3([term], tag, world2, null, `3-[switch] (${form})`);
      fillTags_default(terms, i3, model5);
    } else if (env.DEBUG_TAGS) {
      console.log(`
 -> X  - '${str}'  : (${form})  `);
    }
  }
};
var switches_default = doSwitches;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/07-imperative.js
var beside = {
  there: true,
  //go there
  this: true,
  //try this
  it: true,
  //do it
  him: true,
  her: true,
  us: true
  //tell us
};
var imperative = function(terms, world2) {
  const setTag3 = world2.methods.one.setTag;
  const multiWords = world2.model.one._multiCache || {};
  let t3 = terms[0];
  let isRight = t3.switch === "Noun|Verb" || t3.tags.has("Infinitive");
  if (isRight && terms.length >= 2) {
    if (terms.length < 4 && !beside[terms[1].normal]) {
      return;
    }
    if (!t3.tags.has("PhrasalVerb") && multiWords.hasOwnProperty(t3.normal)) {
      return;
    }
    let nextNoun = terms[1].tags.has("Noun") || terms[1].tags.has("Determiner");
    if (nextNoun) {
      let soonVerb = terms.slice(1, 3).some((term) => term.tags.has("Verb"));
      if (!soonVerb || t3.tags.has("#PhrasalVerb")) {
        setTag3([t3], "Imperative", world2, null, "3-[imperative]");
      }
    }
  }
};
var imperative_default = imperative;

// ../../node_modules/compromise/src/2-two/preTagger/compute/tagger/index.js
var ignoreCase = function(terms) {
  if (terms.filter((t3) => !t3.tags.has("ProperNoun")).length <= 3) {
    return false;
  }
  const lowerCase = /^[a-z]/;
  return terms.every((t3) => !lowerCase.test(t3.text));
};
var firstPass = function(docs, model5, world2) {
  docs.forEach((terms) => {
    colons_default(terms, 0, model5, world2);
  });
};
var secondPass = function(terms, model5, world2, isYelling) {
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    tagSwitch_default(terms, i3, model5);
    if (isYelling === false) {
      case_default2(terms, i3, model5);
    }
    suffix_default(terms, i3, model5);
    regex_default(terms, i3, model5, world2);
    prefix_default(terms, i3, model5);
    year_default(terms, i3, model5);
  }
};
var thirdPass = function(terms, model5, world2, isYelling) {
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    let found = acronym_default(terms, i3, model5);
    fillTags_default(terms, i3, model5);
    found = found || neighbours_default2(terms, i3, model5);
    found = found || fallback_default(terms, i3, model5);
  }
  for (let i3 = 0; i3 < terms.length; i3 += 1) {
    orgWords_default2(terms, i3, world2, isYelling);
    switches_default(terms, i3, world2);
    verb_type_default(terms, i3, model5, world2);
    hyphens_default(terms, i3, model5, world2);
  }
  imperative_default(terms, world2);
};
var preTagger = function(view) {
  const { methods: methods18, model: model5, world: world2 } = view;
  let docs = view.docs;
  firstPass(docs, model5, world2);
  let document = methods18.two.quickSplit(docs);
  for (let n3 = 0; n3 < document.length; n3 += 1) {
    let terms = document[n3];
    const isYelling = ignoreCase(terms);
    secondPass(terms, model5, world2, isYelling);
    thirdPass(terms, model5, world2, isYelling);
  }
  return document;
};
var tagger_default2 = preTagger;

// ../../node_modules/compromise/src/2-two/preTagger/compute/root.js
var toRoot = {
  // 'spencer's' -> 'spencer'
  "Possessive": (term) => {
    let str = term.machine || term.normal || term.text;
    str = str.replace(/'s$/, "");
    return str;
  },
  // 'drinks' -> 'drink'
  "Plural": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.noun.toSingular(str, world2.model);
  },
  // ''
  "Copula": () => {
    return "is";
  },
  // 'walked' -> 'walk'
  "PastTense": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.verb.toInfinitive(str, world2.model, "PastTense");
  },
  // 'walking' -> 'walk'
  "Gerund": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.verb.toInfinitive(str, world2.model, "Gerund");
  },
  // 'walks' -> 'walk'
  "PresentTense": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    if (term.tags.has("Infinitive")) {
      return str;
    }
    return world2.methods.two.transform.verb.toInfinitive(str, world2.model, "PresentTense");
  },
  // 'quieter' -> 'quiet'
  "Comparative": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.adjective.fromComparative(str, world2.model);
  },
  // 'quietest' -> 'quiet'
  "Superlative": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.adjective.fromSuperlative(str, world2.model);
  },
  // 'suddenly' -> 'sudden'
  "Adverb": (term, world2) => {
    const { fromAdverb } = world2.methods.two.transform.adjective;
    let str = term.machine || term.normal || term.text;
    return fromAdverb(str);
  }
};
var getRoot = function(view) {
  const world2 = view.world;
  const keys = Object.keys(toRoot);
  view.docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      const term = terms[i3];
      for (let k2 = 0; k2 < keys.length; k2 += 1) {
        if (term.tags.has(keys[k2])) {
          const fn = toRoot[keys[k2]];
          let root = fn(term, world2);
          if (term.normal !== root) {
            term.root = root;
          }
          break;
        }
      }
    }
  });
};
var root_default = getRoot;

// ../../node_modules/compromise/src/2-two/preTagger/compute/penn.js
var mapping = {
  // adverbs
  // 'Comparative': 'RBR',
  // 'Superlative': 'RBS',
  "Adverb": "RB",
  // adjectives
  "Comparative": "JJR",
  "Superlative": "JJS",
  "Adjective": "JJ",
  "TO": "Conjunction",
  // verbs
  "Modal": "MD",
  "Auxiliary": "MD",
  "Gerund": "VBG",
  //throwing
  "PastTense": "VBD",
  //threw
  "Participle": "VBN",
  //thrown
  "PresentTense": "VBZ",
  //throws
  "Infinitive": "VB",
  //throw
  "Particle": "RP",
  //phrasal particle
  "Verb": "VB",
  // throw
  // pronouns
  "Pronoun": "PRP",
  // misc
  "Cardinal": "CD",
  "Conjunction": "CC",
  "Determiner": "DT",
  "Preposition": "IN",
  // 'Determiner': 'WDT',
  // 'Expression': 'FW',
  "QuestionWord": "WP",
  "Expression": "UH",
  //nouns
  "Possessive": "POS",
  "ProperNoun": "NNP",
  "Person": "NNP",
  "Place": "NNP",
  "Organization": "NNP",
  "Singular": "NNP",
  "Plural": "NNS",
  "Noun": "NN",
  "There": "EX"
  //'there'
  // 'Adverb':'WRB',
  // 'Noun':'PDT', //predeterminer
  // 'Noun':'SYM', //symbol
  // 'Noun':'NFP', //
  //  WDT 	Wh-determiner
  // 	WP 	Wh-pronoun
  // 	WP$ 	Possessive wh-pronoun
  // 	WRB 	Wh-adverb 
};
var toPenn = function(term) {
  if (term.tags.has("ProperNoun") && term.tags.has("Plural")) {
    return "NNPS";
  }
  if (term.tags.has("Possessive") && term.tags.has("Pronoun")) {
    return "PRP$";
  }
  if (term.normal === "there") {
    return "EX";
  }
  if (term.normal === "to") {
    return "TO";
  }
  let arr = term.tagRank || [];
  for (let i3 = 0; i3 < arr.length; i3 += 1) {
    if (mapping.hasOwnProperty(arr[i3])) {
      return mapping[arr[i3]];
    }
  }
  return null;
};
var pennTag = function(view) {
  view.compute("tagRank");
  view.docs.forEach((terms) => {
    terms.forEach((term) => {
      term.penn = toPenn(term);
    });
  });
};
var penn_default = pennTag;

// ../../node_modules/compromise/src/2-two/preTagger/compute/index.js
var compute_default8 = { preTagger: tagger_default2, root: root_default, penn: penn_default };

// ../../node_modules/compromise/src/2-two/preTagger/tagSet/nouns.js
var entity = ["Person", "Place", "Organization"];
var nouns_default3 = {
  Noun: {
    not: ["Verb", "Adjective", "Adverb", "Value", "Determiner"]
  },
  Singular: {
    is: "Noun",
    not: ["Plural", "Uncountable"]
  },
  // 'Canada'
  ProperNoun: {
    is: "Noun"
  },
  Person: {
    is: "Singular",
    also: ["ProperNoun"],
    not: ["Place", "Organization", "Date"]
  },
  FirstName: {
    is: "Person"
  },
  MaleName: {
    is: "FirstName",
    not: ["FemaleName", "LastName"]
  },
  FemaleName: {
    is: "FirstName",
    not: ["MaleName", "LastName"]
  },
  LastName: {
    is: "Person",
    not: ["FirstName"]
  },
  // 'dr.'
  Honorific: {
    is: "Person",
    not: ["FirstName", "LastName", "Value"]
  },
  Place: {
    is: "Singular",
    not: ["Person", "Organization"]
  },
  Country: {
    is: "Place",
    also: ["ProperNoun"],
    not: ["City"]
  },
  City: {
    is: "Place",
    also: ["ProperNoun"],
    not: ["Country"]
  },
  // 'california'
  Region: {
    is: "Place",
    also: ["ProperNoun"]
  },
  Address: {
    // is: 'Place',
  },
  Organization: {
    is: "ProperNoun",
    not: ["Person", "Place"]
  },
  SportsTeam: {
    is: "Organization"
  },
  School: {
    is: "Organization"
  },
  Company: {
    is: "Organization"
  },
  Plural: {
    is: "Noun",
    not: ["Singular", "Uncountable"]
  },
  // 'gravity'
  Uncountable: {
    is: "Noun"
  },
  // 'it'
  Pronoun: {
    is: "Noun",
    not: entity
  },
  // 'swimmer'
  Actor: {
    is: "Noun",
    not: ["Place", "Organization"]
  },
  // walking
  Activity: {
    is: "Noun",
    not: ["Person", "Place"]
  },
  // kilometres
  Unit: {
    is: "Noun",
    not: entity
  },
  // canadian
  Demonym: {
    is: "Noun",
    also: ["ProperNoun"],
    not: entity
  },
  // [spencer's] hat
  Possessive: {
    is: "Noun"
  },
  // 'yourself'
  Reflexive: {
    is: "Pronoun"
  }
};

// ../../node_modules/compromise/src/2-two/preTagger/tagSet/verbs.js
var verbs_default2 = {
  Verb: {
    not: ["Noun", "Adjective", "Adverb", "Value", "Expression"]
  },
  // 'he [walks]'
  PresentTense: {
    is: "Verb",
    not: ["PastTense"]
  },
  // 'will [walk]'
  Infinitive: {
    is: "PresentTense",
    not: ["Gerund"]
  },
  // '[walk] now!'
  Imperative: {
    is: "Verb",
    not: ["PastTense", "Gerund", "Copula"]
  },
  // walking
  Gerund: {
    is: "PresentTense",
    not: ["Copula"]
  },
  // walked
  PastTense: {
    is: "Verb",
    not: ["PresentTense", "Gerund"]
  },
  // is/was
  Copula: {
    is: "Verb"
  },
  // '[could] walk'
  Modal: {
    is: "Verb",
    not: ["Infinitive"]
  },
  // 'awaken'
  Participle: {
    is: "PastTense"
  },
  // '[will have had] walked'
  Auxiliary: {
    is: "Verb",
    not: ["PastTense", "PresentTense", "Gerund", "Conjunction"]
  },
  // 'walk out'
  PhrasalVerb: {
    is: "Verb"
  },
  // 'walk [out]'
  Particle: {
    is: "PhrasalVerb",
    not: ["PastTense", "PresentTense", "Copula", "Gerund"]
  },
  // 'walked by'
  Passive: {
    is: "Verb"
  }
};

// ../../node_modules/compromise/src/2-two/preTagger/tagSet/values.js
var values_default = {
  Value: {
    not: ["Verb", "Adjective", "Adverb"]
  },
  Ordinal: {
    is: "Value",
    not: ["Cardinal"]
  },
  Cardinal: {
    is: "Value",
    not: ["Ordinal"]
  },
  Fraction: {
    is: "Value",
    not: ["Noun"]
  },
  Multiple: {
    is: "TextValue"
  },
  RomanNumeral: {
    is: "Cardinal",
    not: ["TextValue"]
  },
  TextValue: {
    is: "Value",
    not: ["NumericValue"]
  },
  NumericValue: {
    is: "Value",
    not: ["TextValue"]
  },
  Money: {
    is: "Cardinal"
  },
  Percent: {
    is: "Value"
  }
};

// ../../node_modules/compromise/src/2-two/preTagger/tagSet/dates.js
var dates_default = {
  Date: {
    not: ["Verb", "Adverb", "Adjective"]
  },
  Month: {
    is: "Date",
    also: ["Noun"],
    not: ["Year", "WeekDay", "Time"]
  },
  WeekDay: {
    is: "Date",
    also: ["Noun"]
  },
  Year: {
    is: "Date",
    not: ["RomanNumeral"]
  },
  FinancialQuarter: {
    is: "Date",
    not: "Fraction"
  },
  // 'easter'
  Holiday: {
    is: "Date",
    also: ["Noun"]
  },
  // 'summer'
  Season: {
    is: "Date"
  },
  Timezone: {
    is: "Date",
    also: ["Noun"],
    not: ["ProperNoun"]
  },
  Time: {
    is: "Date",
    not: ["AtMention"]
  },
  // 'months'
  Duration: {
    is: "Date",
    also: ["Noun"]
  }
};

// ../../node_modules/compromise/src/2-two/preTagger/tagSet/misc.js
var anything = ["Noun", "Verb", "Adjective", "Adverb", "Value", "QuestionWord"];
var misc_default3 = {
  Adjective: {
    not: ["Noun", "Verb", "Adverb", "Value"]
  },
  Comparable: {
    is: "Adjective"
  },
  Comparative: {
    is: "Adjective"
  },
  Superlative: {
    is: "Adjective",
    not: ["Comparative"]
  },
  NumberRange: {},
  Adverb: {
    not: ["Noun", "Verb", "Adjective", "Value"]
  },
  Determiner: {
    not: ["Noun", "Verb", "Adjective", "Adverb", "QuestionWord", "Conjunction"]
    //allow 'a' to be a Determiner/Value
  },
  Conjunction: {
    not: anything
  },
  Preposition: {
    not: ["Noun", "Verb", "Adjective", "Adverb", "QuestionWord", "Determiner"]
  },
  QuestionWord: {
    not: ["Determiner"]
  },
  Currency: {
    is: "Noun"
  },
  Expression: {
    not: ["Noun", "Adjective", "Verb", "Adverb"]
  },
  Abbreviation: {},
  Url: {
    not: ["HashTag", "PhoneNumber", "Verb", "Adjective", "Value", "AtMention", "Email"]
  },
  PhoneNumber: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention", "Email"]
  },
  HashTag: {},
  AtMention: {
    is: "Noun",
    not: ["HashTag", "Email"]
  },
  Emoji: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Emoticon: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Email: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Acronym: {
    not: ["Plural", "RomanNumeral", "Pronoun"]
  },
  Negative: {
    not: ["Noun", "Adjective", "Value", "Expression"]
  },
  Condition: {
    not: ["Verb", "Adjective", "Noun", "Value"]
  },
  // existential 'there'
  There: {
    not: ["Verb", "Adjective", "Noun", "Value", "Conjunction", "Preposition"]
  },
  // 'co-wrote'
  Prefix: {
    not: ["Abbreviation", "Acronym", "ProperNoun"]
  },
  // hard-nosed, bone-headed
  Hyphenated: {}
};

// ../../node_modules/compromise/src/2-two/preTagger/tagSet/index.js
var allTags = Object.assign({}, nouns_default3, verbs_default2, values_default, dates_default, misc_default3);
var tagSet_default = allTags;

// ../../node_modules/compromise/src/2-two/preTagger/plugin.js
var plugin_default13 = {
  compute: compute_default8,
  methods: methods_default10,
  model: model_default3,
  tags: tagSet_default,
  hooks: ["preTagger"]
};

// ../../node_modules/compromise/src/2-two/contraction-two/api/contract.js
var postPunct = /[,)"';:\-–—.…]/;
var setContraction = function(m3, suffix) {
  if (!m3.found) {
    return;
  }
  let terms = m3.termList();
  for (let i3 = 0; i3 < terms.length - 1; i3++) {
    const t3 = terms[i3];
    if (postPunct.test(t3.post)) {
      return;
    }
  }
  terms[0].implicit = terms[0].normal;
  terms[0].text += suffix;
  terms[0].normal += suffix;
  terms.slice(1).forEach((t3) => {
    t3.implicit = t3.normal;
    t3.text = "";
    t3.normal = "";
  });
  for (let i3 = 0; i3 < terms.length - 1; i3++) {
    terms[i3].post = terms[i3].post.replace(/ /, "");
  }
};
var contract = function() {
  let doc = this.not("@hasContraction");
  let m3 = doc.match("(we|they|you) are");
  setContraction(m3, `'re`);
  m3 = doc.match("(he|she|they|it|we|you) will");
  setContraction(m3, `'ll`);
  m3 = doc.match("(he|she|they|it|we) is");
  setContraction(m3, `'s`);
  m3 = doc.match("#Person is");
  setContraction(m3, `'s`);
  m3 = doc.match("#Person would");
  setContraction(m3, `'d`);
  m3 = doc.match("(is|was|had|would|should|could|do|does|have|has|can) not");
  setContraction(m3, `n't`);
  m3 = doc.match("(i|we|they) have");
  setContraction(m3, `'ve`);
  m3 = doc.match("(would|should|could) have");
  setContraction(m3, `'ve`);
  m3 = doc.match("i am");
  setContraction(m3, `'m`);
  m3 = doc.match("going to");
  return this;
};
var contract_default = contract;

// ../../node_modules/compromise/src/2-two/contraction-two/api/index.js
var titleCase4 = /^\p{Lu}[\p{Ll}'’]/u;
var toTitleCase2 = function(str = "") {
  str = str.replace(/^ *[a-z\u00C0-\u00FF]/, (x) => x.toUpperCase());
  return str;
};
var api3 = function(View2) {
  class Contractions extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Contraction";
    }
    /** i've -> 'i have' */
    expand() {
      this.docs.forEach((terms) => {
        let isTitleCase4 = titleCase4.test(terms[0].text);
        terms.forEach((t3, i3) => {
          t3.text = t3.implicit || "";
          delete t3.implicit;
          if (i3 < terms.length - 1 && t3.post === "") {
            t3.post += " ";
          }
          t3.dirty = true;
        });
        if (isTitleCase4) {
          terms[0].text = toTitleCase2(terms[0].text);
        }
      });
      this.compute("normal");
      return this;
    }
  }
  View2.prototype.contractions = function() {
    let m3 = this.match("@hasContraction+");
    return new Contractions(this.document, m3.pointer);
  };
  View2.prototype.contract = contract_default;
};
var api_default10 = api3;

// ../../node_modules/compromise/src/2-two/contraction-two/compute/_splice.js
var insertContraction2 = function(document, point, words) {
  let [n3, w] = point;
  if (!words || words.length === 0) {
    return;
  }
  words = words.map((word, i3) => {
    word.implicit = word.text;
    word.machine = word.text;
    word.pre = "";
    word.post = "";
    word.text = "";
    word.normal = "";
    word.index = [n3, w + i3];
    return word;
  });
  if (words[0]) {
    words[0].pre = document[n3][w].pre;
    words[words.length - 1].post = document[n3][w].post;
    words[0].text = document[n3][w].text;
    words[0].normal = document[n3][w].normal;
  }
  document[n3].splice(w, 1, ...words);
};
var splice_default2 = insertContraction2;

// ../../node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-s.js
var hasContraction3 = /'/;
var isHas = (terms, i3) => {
  let after2 = terms.slice(i3 + 1, i3 + 3);
  return after2.some((t3) => t3.tags.has("PastTense"));
};
var apostropheS = function(terms, i3) {
  let before2 = terms[i3].normal.split(hasContraction3)[0];
  if (isHas(terms, i3)) {
    return [before2, "has"];
  }
  if (before2 === "let") {
    return [before2, "us"];
  }
  if (before2 === "there") {
    let nextTerm = terms[i3 + 1];
    if (nextTerm && nextTerm.tags.has("Plural")) {
      return [before2, "are"];
    }
  }
  return [before2, "is"];
};
var apostrophe_s_default = apostropheS;

// ../../node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-d.js
var hasContraction4 = /'/;
var pickHad = (terms, i3) => {
  if (terms[i3 + 1] && terms[i3 + 1].normal == "better") {
    return true;
  }
  let after2 = terms.slice(i3 + 1, i3 + 3);
  return after2.some((t3) => t3.tags.has("PastTense"));
};
var _apostropheD2 = function(terms, i3) {
  let before2 = terms[i3].normal.split(hasContraction4)[0];
  if (before2 === "how" || before2 === "what") {
    return [before2, "did"];
  }
  if (pickHad(terms, i3) === true) {
    return [before2, "had"];
  }
  return [before2, "would"];
};
var apostrophe_d_default2 = _apostropheD2;

// ../../node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-t.js
var lastNoun = function(terms, i3) {
  for (let n3 = i3 - 1; n3 >= 0; n3 -= 1) {
    if (terms[n3].tags.has("Noun") || terms[n3].tags.has("Pronoun") || terms[n3].tags.has("Plural") || terms[n3].tags.has("Singular")) {
      return terms[n3];
    }
  }
  return null;
};
var apostropheT2 = function(terms, i3) {
  if (terms[i3].normal === "ain't" || terms[i3].normal === "aint") {
    if (terms[i3 + 1] && terms[i3 + 1].normal === "never") {
      return ["have"];
    }
    let noun = lastNoun(terms, i3);
    if (noun) {
      if (noun.normal === "we" || noun.normal === "they") {
        return ["are", "not"];
      }
      if (noun.normal === "i") {
        return ["am", "not"];
      }
      if (noun.tags && noun.tags.has("Plural")) {
        return ["are", "not"];
      }
    }
    return ["is", "not"];
  }
  let before2 = terms[i3].normal.replace(/n't/, "");
  return [before2, "not"];
};
var apostrophe_t_default2 = apostropheT2;

// ../../node_modules/compromise/src/2-two/contraction-two/compute/isPossessive.js
var banList = {
  that: true,
  there: true,
  let: true,
  here: true,
  everywhere: true
};
var beforePossessive = {
  in: true,
  //in sunday's
  by: true,
  //by sunday's
  for: true
  //for sunday's
};
var isPossessive = (terms, i3) => {
  let term = terms[i3];
  if (banList.hasOwnProperty(term.machine || term.normal)) {
    return false;
  }
  if (term.tags.has("Possessive")) {
    return true;
  }
  if (term.tags.has("QuestionWord")) {
    return false;
  }
  if (term.normal === `he's` || term.normal === `she's`) {
    return false;
  }
  let nextTerm = terms[i3 + 1];
  if (!nextTerm) {
    return true;
  }
  if (term.normal === `it's`) {
    if (nextTerm.tags.has("#Noun")) {
      return true;
    }
    return false;
  }
  if (nextTerm.tags.has("Verb")) {
    if (nextTerm.tags.has("Infinitive")) {
      return true;
    }
    if (nextTerm.tags.has("PresentTense")) {
      return true;
    }
    return false;
  }
  if (nextTerm.tags.has("Noun")) {
    let nextStr = nextTerm.machine || nextTerm.normal;
    if (nextStr === "here" || nextStr === "there" || nextStr === "everywhere") {
      return false;
    }
    if (nextTerm.tags.has("Possessive")) {
      return false;
    }
    if (nextTerm.tags.has("ProperNoun") && !term.tags.has("ProperNoun")) {
      return false;
    }
    return true;
  }
  if (terms[i3 - 1] && beforePossessive[terms[i3 - 1].normal] === true) {
    return true;
  }
  let twoTerm = terms[i3 + 2];
  if (twoTerm && twoTerm.tags.has("Noun") && !twoTerm.tags.has("Pronoun")) {
    return true;
  }
  if (nextTerm.tags.has("Adjective") || nextTerm.tags.has("Adverb") || nextTerm.tags.has("Verb")) {
    return false;
  }
  return false;
};
var isPossessive_default = isPossessive;

// ../../node_modules/compromise/src/2-two/contraction-two/compute/index.js
var byApostrophe2 = /'/;
var reIndex = function(terms) {
  terms.forEach((t3, i3) => {
    if (t3.index) {
      t3.index[1] = i3;
    }
  });
};
var reTag2 = function(terms, view, start2, len) {
  let tmp = view.update();
  tmp.document = [terms];
  let end2 = start2 + len;
  if (start2 > 0) {
    start2 -= 1;
  }
  if (terms[end2]) {
    end2 += 1;
  }
  tmp.ptrs = [[0, start2, end2]];
  tmp.compute(["lexicon", "preTagger"]);
  reIndex(terms);
};
var byEnd2 = {
  // how'd
  d: (terms, i3) => apostrophe_d_default2(terms, i3),
  // we ain't
  t: (terms, i3) => apostrophe_t_default2(terms, i3),
  // bob's
  s: (terms, i3, world2) => {
    if (isPossessive_default(terms, i3)) {
      return world2.methods.one.setTag([terms[i3]], "Possessive", world2, "2-contraction");
    }
    return apostrophe_s_default(terms, i3);
  }
};
var toDocs2 = function(words, view) {
  let doc = view.fromText(words.join(" "));
  doc.compute("id");
  return doc.docs[0];
};
var contractionTwo = (view) => {
  let { world: world2, document } = view;
  document.forEach((terms, n3) => {
    for (let i3 = terms.length - 1; i3 >= 0; i3 -= 1) {
      if (terms[i3].implicit) {
        return;
      }
      let after2 = null;
      if (byApostrophe2.test(terms[i3].normal) === true) {
        [, after2] = terms[i3].normal.split(byApostrophe2);
      }
      let words = null;
      if (byEnd2.hasOwnProperty(after2)) {
        words = byEnd2[after2](terms, i3, world2);
      }
      if (words) {
        words = toDocs2(words, view);
        splice_default2(document, [n3, i3], words);
        reTag2(document[n3], view, i3, words.length);
        continue;
      }
    }
  });
};
var compute_default9 = { contractionTwo };

// ../../node_modules/compromise/src/2-two/contraction-two/plugin.js
var plugin_default14 = {
  compute: compute_default9,
  api: api_default10,
  hooks: ["contractionTwo"]
};

// ../../node_modules/compromise/src/2-two/postTagger/model/adjective/adjective.js
var adjective_default = [
  // all fell apart
  { match: "[(all|both)] #Determiner #Noun", group: 0, tag: "Noun", reason: "all-noun" },
  //sometimes not-adverbs
  { match: "#Copula [(just|alone)]$", group: 0, tag: "Adjective", reason: "not-adverb" },
  //jack is guarded
  { match: "#Singular is #Adverb? [#PastTense$]", group: 0, tag: "Adjective", reason: "is-filled" },
  // smoked poutine is
  { match: "[#PastTense] #Singular is", group: 0, tag: "Adjective", reason: "smoked-poutine" },
  // baked onions are
  { match: "[#PastTense] #Plural are", group: 0, tag: "Adjective", reason: "baked-onions" },
  // well made
  { match: "well [#PastTense]", group: 0, tag: "Adjective", reason: "well-made" },
  // is f*ed up
  { match: "#Copula [fucked up?]", group: 0, tag: "Adjective", reason: "swears-adjective" },
  //jack seems guarded
  { match: "#Singular (seems|appears) #Adverb? [#PastTense$]", group: 0, tag: "Adjective", reason: "seems-filled" },
  // jury is out - preposition ➔ adjective
  { match: "#Copula #Adjective? [(out|in|through)]$", group: 0, tag: "Adjective", reason: "still-out" },
  // shut the door
  { match: "^[#Adjective] (the|your) #Noun", group: 0, notIf: "(all|even)", tag: "Infinitive", reason: "shut-the" },
  // the said card
  { match: "the [said] #Noun", group: 0, tag: "Adjective", reason: "the-said-card" },
  // faith-based, much-appreciated, soft-boiled
  { match: "[#Hyphenated (#Hyphenated && #PastTense)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", notIf: "#Adverb", reason: "faith-based" },
  //self-driving
  { match: "[#Hyphenated (#Hyphenated && #Gerund)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", notIf: "#Adverb", reason: "self-driving" },
  //dammed-up
  { match: "[#PastTense (#Hyphenated && #PhrasalVerb)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", reason: "dammed-up" },
  //two-fold
  { match: "(#Hyphenated && #Value) fold", tag: "Adjective", reason: "two-fold" },
  //must-win
  { match: "must (#Hyphenated && #Infinitive)", tag: "Adjective", reason: "must-win" },
  // vacuum-sealed
  { match: `(#Hyphenated && #Infinitive) #Hyphenated`, tag: "Adjective", notIf: "#PhrasalVerb", reason: "vacuum-sealed" },
  { match: "too much", tag: "Adverb Adjective", reason: "bit-4" },
  { match: "a bit much", tag: "Determiner Adverb Adjective", reason: "bit-3" },
  // adjective-prefixes - 'un skilled'
  { match: "[(un|contra|extra|inter|intra|macro|micro|mid|mis|mono|multi|pre|sub|tri|ex)] #Adjective", group: 0, tag: ["Adjective", "Prefix"], reason: "un-skilled" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/adjective/adj-adverb.js
var adverbAdj = `(dark|bright|flat|light|soft|pale|dead|dim|faux|little|wee|sheer|most|near|good|extra|all)`;
var noLy = "(hard|fast|late|early|high|right|deep|close|direct)";
var adj_adverb_default = [
  // kinda sparkly
  { match: `#Adverb [#Adverb] (and|or|then)`, group: 0, tag: "Adjective", reason: "kinda-sparkly-and" },
  // dark green
  { match: `[${adverbAdj}] #Adjective`, group: 0, tag: "Adverb", reason: "dark-green" },
  // far too
  { match: `#Copula [far too] #Adjective`, group: 0, tag: "Adverb", reason: "far-too" },
  // was still in 
  { match: `#Copula [still] (in|#Gerund|#Adjective)`, group: 0, tag: "Adverb", reason: "was-still-walking" },
  // studies hard
  { match: `#Plural ${noLy}`, tag: "#PresentTense #Adverb", reason: "studies-hard" },
  // shops direct
  { match: `#Verb [${noLy}] !#Noun?`, group: 0, notIf: "(#Copula|get|got|getting|become|became|becoming|feel|feels|feeling)", tag: "Adverb", reason: "shops-direct" },
  // studies a lot
  { match: `[#Plural] a lot`, tag: "PresentTense", reason: "studies-a-lot" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/adjective/adj-gerund.js
var adj_gerund_default2 = [
  //a staggering cost
  // { match: '(a|an) [#Gerund]', group: 0, tag: 'Adjective', reason: 'a|an' },
  //as amusing as
  { match: "as [#Gerund] as", group: 0, tag: "Adjective", reason: "as-gerund-as" },
  // more amusing than
  { match: "more [#Gerund] than", group: 0, tag: "Adjective", reason: "more-gerund-than" },
  // very amusing
  { match: "(so|very|extremely) [#Gerund]", group: 0, tag: "Adjective", reason: "so-gerund" },
  // found it amusing
  { match: "(found|found) it #Adverb? [#Gerund]", group: 0, tag: "Adjective", reason: "found-it-gerund" },
  // a bit amusing
  { match: "a (little|bit|wee) bit? [#Gerund]", group: 0, tag: "Adjective", reason: "a-bit-gerund" },
  // looking annoying
  { match: "#Gerund [#Gerund]", group: 0, tag: "Adjective", notIf: "(impersonating|practicing|considering|assuming)", reason: "looking-annoying" },
  // looked amazing
  { match: "(looked|look|looks) #Adverb? [%Adj|Gerund%]", group: 0, tag: "Adjective", notIf: "(impersonating|practicing|considering|assuming)", reason: "looked-amazing" },
  // were really amazing
  // { match: '(looked|look|looks) #Adverb [%Adj|Gerund%]', group: 0, tag: 'Adjective', notIf: '(impersonating|practicing|considering|assuming)', reason: 'looked-amazing' },
  // developing a
  { match: "[%Adj|Gerund%] #Determiner", group: 0, tag: "Gerund", reason: "developing-a" },
  // world's leading manufacturer
  { match: "#Possessive [%Adj|Gerund%] #Noun", group: 0, tag: "Adjective", reason: "leading-manufacturer" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/adjective/adj-noun.js
var adj_noun_default2 = [
  //the above is clear
  { match: "#Determiner [#Adjective] #Copula", group: 0, tag: "Noun", reason: "the-adj-is" },
  //real evil is
  { match: "#Adjective [#Adjective] #Copula", group: 0, tag: "Noun", reason: "adj-adj-is" },
  //his fine
  { match: "(his|its) [%Adj|Noun%]", group: 0, tag: "Noun", notIf: "#Hyphenated", reason: "his-fine" },
  //is all
  { match: "#Copula #Adverb? [all]", group: 0, tag: "Noun", reason: "is-all" },
  // have fun
  { match: `(have|had) [#Adjective] #Preposition .`, group: 0, tag: "Noun", reason: "have-fun" },
  // brewing giant
  { match: `#Gerund (giant|capital|center|zone|application)`, tag: "Noun", reason: "brewing-giant" },
  // in an instant
  { match: `#Preposition (a|an) [#Adjective]$`, group: 0, tag: "Noun", reason: "an-instant" },
  // no golden would
  { match: `no [#Adjective] #Modal`, group: 0, tag: "Noun", reason: "no-golden" },
  // brand new
  { match: `[brand #Gerund?] new`, group: 0, tag: "Adverb", reason: "brand-new" },
  // some kind
  { match: `(#Determiner|#Comparative|new|different) [kind]`, group: 0, tag: "Noun", reason: "some-kind" },
  // her favourite sport
  { match: `#Possessive [%Adj|Noun%] #Noun`, group: 0, tag: "Adjective", reason: "her-favourite" },
  // must-win
  { match: `must && #Hyphenated .`, tag: "Adjective", reason: "must-win" },
  // the present
  { match: `#Determiner [#Adjective]$`, tag: "Noun", notIf: "(this|that|#Comparative|#Superlative)", reason: "the-south" },
  //are that crazy.
  // company-wide
  { match: `(#Noun && #Hyphenated) (#Adjective && #Hyphenated)`, tag: "Adjective", notIf: "(this|that|#Comparative|#Superlative)", reason: "company-wide" },
  // the poor were
  { match: `#Determiner [#Adjective] (#Copula|#Determiner)`, notIf: "(#Comparative|#Superlative)", group: 0, tag: "Noun", reason: "the-poor" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/adjective/adj-verb.js
var adj_verb_default = [
  // amusing his aunt
  // { match: '[#Adjective] #Possessive #Noun', group: 0, tag: 'Verb', reason: 'gerund-his-noun' },
  // loving you
  // { match: '[#Adjective] (us|you)', group: 0, tag: 'Gerund', reason: 'loving-you' },
  // slowly stunning
  { match: "(slowly|quickly) [#Adjective]", group: 0, tag: "Verb", reason: "slowly-adj" },
  // does mean
  { match: "does (#Adverb|not)? [#Adjective]", group: 0, tag: "PresentTense", reason: "does-mean" },
  // okay by me
  { match: "[(fine|okay|cool|ok)] by me", group: 0, tag: "Adjective", reason: "okay-by-me" },
  // i mean
  { match: "i (#Adverb|do)? not? [mean]", group: 0, tag: "PresentTense", reason: "i-mean" },
  //will secure our
  { match: "will #Adjective", tag: "Auxiliary Infinitive", reason: "will-adj" },
  //he disguised the thing
  { match: "#Pronoun [#Adjective] #Determiner #Adjective? #Noun", group: 0, tag: "Verb", reason: "he-adj-the" },
  //is eager to go
  { match: "#Copula [%Adj|Present%] to #Verb", group: 0, tag: "Verb", reason: "adj-to" },
  //is done well
  { match: "#Copula [#Adjective] (well|badly|quickly|slowly)", group: 0, tag: "Verb", reason: "done-well" },
  // rude and insulting
  { match: "#Adjective and [#Gerund] !#Preposition?", group: 0, tag: "Adjective", reason: "rude-and-x" },
  // were over cooked
  { match: "#Copula #Adverb? (over|under) [#PastTense]", group: 0, tag: "Adjective", reason: "over-cooked" },
  // was bland and overcooked
  { match: "#Copula #Adjective+ (and|or) [#PastTense]$", group: 0, tag: "Adjective", reason: "bland-and-overcooked" },
  // got tired of
  { match: "got #Adverb? [#PastTense] of", group: 0, tag: "Adjective", reason: "got-tired-of" },
  //felt loved
  { match: "(seem|seems|seemed|appear|appeared|appears|feel|feels|felt|sound|sounds|sounded) (#Adverb|#Adjective)? [#PastTense]", group: 0, tag: "Adjective", reason: "felt-loved" },
  // seem confused
  { match: "(seem|feel|seemed|felt) [#PastTense #Particle?]", group: 0, tag: "Adjective", reason: "seem-confused" },
  // a bit confused
  { match: "a (bit|little|tad) [#PastTense #Particle?]", group: 0, tag: "Adjective", reason: "a-bit-confused" },
  // do not be embarrassed
  { match: "not be [%Adj|Past% #Particle?]", group: 0, tag: "Adjective", reason: "do-not-be-confused" },
  // is just right
  { match: "#Copula just [%Adj|Past% #Particle?]", group: 0, tag: "Adjective", reason: "is-just-right" },
  // as pale as
  { match: "as [#Infinitive] as", group: 0, tag: "Adjective", reason: "as-pale-as" },
  //failed and oppressive
  { match: "[%Adj|Past%] and #Adjective", group: 0, tag: "Adjective", reason: "faled-and-oppressive" },
  // or heightened emotion
  { match: "or [#PastTense] #Noun", group: 0, tag: "Adjective", notIf: "(#Copula|#Pronoun)", reason: "or-heightened-emotion" },
  // became involved
  { match: "(become|became|becoming|becomes) [#Verb]", group: 0, tag: "Adjective", reason: "become-verb" },
  // their declared intentions
  { match: "#Possessive [#PastTense] #Noun", group: 0, tag: "Adjective", reason: "declared-intentions" },
  // is he cool
  { match: "#Copula #Pronoun [%Adj|Present%]", group: 0, tag: "Adjective", reason: "is-he-cool" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/adverb.js
var adverb_default = [
  //still good
  { match: "[still] #Adjective", group: 0, tag: "Adverb", reason: "still-advb" },
  //still make
  { match: "[still] #Verb", group: 0, tag: "Adverb", reason: "still-verb" },
  // so hot
  { match: "[so] #Adjective", group: 0, tag: "Adverb", reason: "so-adv" },
  // way hotter
  { match: "[way] #Comparative", group: 0, tag: "Adverb", reason: "way-adj" },
  // way too hot
  { match: "[way] #Adverb #Adjective", group: 0, tag: "Adverb", reason: "way-too-adj" },
  // all singing
  { match: "[all] #Verb", group: 0, tag: "Adverb", reason: "all-verb" },
  // sing like an angel
  { match: "#Verb  [like]", group: 0, notIf: "(#Modal|#PhrasalVerb)", tag: "Adverb", reason: "verb-like" },
  //barely even walk
  { match: "(barely|hardly) even", tag: "Adverb", reason: "barely-even" },
  //even held
  { match: "[even] #Verb", group: 0, tag: "Adverb", reason: "even-walk" },
  //even worse
  { match: "[even] #Comparative", group: 0, tag: "Adverb", reason: "even-worse" },
  // even the greatest
  { match: "[even] (#Determiner|#Possessive)", group: 0, tag: "#Adverb", reason: "even-the" },
  // even left
  { match: "even left", tag: "#Adverb #Verb", reason: "even-left" },
  // way over
  { match: "[way] #Adjective", group: 0, tag: "#Adverb", reason: "way-over" },
  //cheering hard - dropped -ly's
  {
    match: "#PresentTense [(hard|quick|bright|slow|fast|backwards|forwards)]",
    notIf: "#Copula",
    group: 0,
    tag: "Adverb",
    reason: "lazy-ly"
  },
  // much appreciated
  { match: "[much] #Adjective", group: 0, tag: "Adverb", reason: "bit-1" },
  // is well
  { match: "#Copula [#Adverb]$", group: 0, tag: "Adjective", reason: "is-well" },
  // a bit cold
  { match: "a [(little|bit|wee) bit?] #Adjective", group: 0, tag: "Adverb", reason: "a-bit-cold" },
  // super strong
  { match: `[(super|pretty)] #Adjective`, group: 0, tag: "Adverb", reason: "super-strong" },
  // become overly weakened
  { match: "(become|fall|grow) #Adverb? [#PastTense]", group: 0, tag: "Adjective", reason: "overly-weakened" },
  // a completely beaten man
  { match: "(a|an) #Adverb [#Participle] #Noun", group: 0, tag: "Adjective", reason: "completely-beaten" },
  //a close
  { match: "#Determiner #Adverb? [close]", group: 0, tag: "Adjective", reason: "a-close" },
  //walking close
  { match: "#Gerund #Adverb? [close]", group: 0, tag: "Adverb", notIf: "(getting|becoming|feeling)", reason: "being-close" },
  // a blown motor
  { match: "(the|those|these|a|an) [#Participle] #Noun", group: 0, tag: "Adjective", reason: "blown-motor" },
  // charged back
  { match: "(#PresentTense|#PastTense) [back]", group: 0, tag: "Adverb", notIf: "(#PhrasalVerb|#Copula)", reason: "charge-back" },
  // send around
  { match: "#Verb [around]", group: 0, tag: "Adverb", notIf: "#PhrasalVerb", reason: "send-around" },
  // later say
  { match: "[later] #PresentTense", group: 0, tag: "Adverb", reason: "later-say" },
  // the well
  { match: "#Determiner [well] !#PastTense?", group: 0, tag: "Noun", reason: "the-well" },
  // high enough
  { match: "#Adjective [enough]", group: 0, tag: "Adverb", reason: "high-enough" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/dates/date-phrase.js
var date_phrase_default = [
  // ==== Holiday ====
  { match: "#Holiday (day|eve)", tag: "Holiday", reason: "holiday-day" },
  //5th of March
  { match: "#Value of #Month", tag: "Date", reason: "value-of-month" },
  //5 March
  { match: "#Cardinal #Month", tag: "Date", reason: "cardinal-month" },
  //march 5 to 7
  { match: "#Month #Value to #Value", tag: "Date", reason: "value-to-value" },
  //march the 12th
  { match: "#Month the #Value", tag: "Date", reason: "month-the-value" },
  //june 7
  { match: "(#WeekDay|#Month) #Value", tag: "Date", reason: "date-value" },
  //7 june
  { match: "#Value (#WeekDay|#Month)", tag: "Date", reason: "value-date" },
  //may twenty five
  { match: "(#TextValue && #Date) #TextValue", tag: "Date", reason: "textvalue-date" },
  // 'aug 20-21'
  { match: `#Month #NumberRange`, tag: "Date", reason: "aug 20-21" },
  // wed march 5th
  { match: `#WeekDay #Month #Ordinal`, tag: "Date", reason: "week mm-dd" },
  // aug 5th 2021
  { match: `#Month #Ordinal #Cardinal`, tag: "Date", reason: "mm-dd-yyy" },
  // === timezones ===
  // china standard time
  { match: `(#Place|#Demonmym|#Time) (standard|daylight|central|mountain)? time`, tag: "Timezone", reason: "std-time" },
  // eastern time
  {
    match: `(eastern|mountain|pacific|central|atlantic) (standard|daylight|summer)? time`,
    tag: "Timezone",
    reason: "eastern-time"
  },
  // 5pm central
  { match: `#Time [(eastern|mountain|pacific|central|est|pst|gmt)]`, group: 0, tag: "Timezone", reason: "5pm-central" },
  // central european time
  { match: `(central|western|eastern) european time`, tag: "Timezone", reason: "cet" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/dates/date.js
var date_default = [
  // ==== WeekDay ====
  // sun the 5th
  { match: "[sun] the #Ordinal", tag: "WeekDay", reason: "sun-the-5th" },
  //sun feb 2
  { match: "[sun] #Date", group: 0, tag: "WeekDay", reason: "sun-feb" },
  //1pm next sun
  { match: "#Date (on|this|next|last|during)? [sun]", group: 0, tag: "WeekDay", reason: "1pm-sun" },
  //this sat
  { match: `(in|by|before|during|on|until|after|of|within|all) [sat]`, group: 0, tag: "WeekDay", reason: "sat" },
  { match: `(in|by|before|during|on|until|after|of|within|all) [wed]`, group: 0, tag: "WeekDay", reason: "wed" },
  { match: `(in|by|before|during|on|until|after|of|within|all) [march]`, group: 0, tag: "Month", reason: "march" },
  //sat november
  { match: "[sat] #Date", group: 0, tag: "WeekDay", reason: "sat-feb" },
  // ==== Month ====
  //all march
  { match: `#Preposition [(march|may)]`, group: 0, tag: "Month", reason: "in-month" },
  //this march
  { match: `(this|next|last) (march|may) !#Infinitive?`, tag: "#Date #Month", reason: "this-month" },
  // march 5th
  { match: `(march|may) the? #Value`, tag: "#Month #Date #Date", reason: "march-5th" },
  // 5th of march
  { match: `#Value of? (march|may)`, tag: "#Date #Date #Month", reason: "5th-of-march" },
  // march and feb
  { match: `[(march|may)] .? #Date`, group: 0, tag: "Month", reason: "march-and-feb" },
  // feb to march
  { match: `#Date .? [(march|may)]`, group: 0, tag: "Month", reason: "feb-and-march" },
  //quickly march
  { match: `#Adverb [(march|may)]`, group: 0, tag: "Verb", reason: "quickly-march" },
  //march quickly
  { match: `[(march|may)] #Adverb`, group: 0, tag: "Verb", reason: "march-quickly" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/nouns/nouns.js
var infNouns = "(feel|sense|process|rush|side|bomb|bully|challenge|cover|crush|dump|exchange|flow|function|issue|lecture|limit|march|process)";
var nouns_default4 = [
  //'more' is not always an adverb
  // any more
  { match: "(the|any) [more]", group: 0, tag: "Singular", reason: "more-noun" },
  // more players
  { match: "[more] #Noun", group: 0, tag: "Adjective", reason: "more-noun" },
  // rights of man
  { match: "(right|rights) of .", tag: "Noun", reason: "right-of" },
  // a bit
  { match: "a [bit]", group: 0, tag: "Singular", reason: "bit-2" },
  // a must
  { match: "a [must]", group: 0, tag: "Singular", reason: "must-2" },
  // we all
  { match: "(we|us) [all]", group: 0, tag: "Noun", reason: "we all" },
  // due to weather
  { match: "due to [#Verb]", group: 0, tag: "Noun", reason: "due-to" },
  //some pressing issues
  { match: "some [#Verb] #Plural", group: 0, tag: "Noun", reason: "determiner6" },
  // my first thought
  { match: "#Possessive #Ordinal [#PastTense]", group: 0, tag: "Noun", reason: "first-thought" },
  //the nice swim
  { match: "(the|this|those|these) #Adjective [%Verb|Noun%]", group: 0, tag: "Noun", notIf: "#Copula", reason: "the-adj-verb" },
  // the truly nice swim
  { match: "(the|this|those|these) #Adverb #Adjective [#Verb]", group: 0, tag: "Noun", reason: "determiner4" },
  //the wait to vote
  { match: "the [#Verb] #Preposition .", group: 0, tag: "Noun", reason: "determiner1" },
  //a sense of
  { match: "(a|an|the) [#Verb] of", group: 0, tag: "Noun", reason: "the-verb-of" },
  //the threat of force
  { match: "#Determiner #Noun of [#Verb]", group: 0, tag: "Noun", notIf: "#Gerund", reason: "noun-of-noun" },
  // ended in ruins
  { match: "#PastTense #Preposition [#PresentTense]", group: 0, notIf: "#Gerund", tag: "Noun", reason: "ended-in-ruins" },
  //'u' as pronoun
  { match: "#Conjunction [u]", group: 0, tag: "Pronoun", reason: "u-pronoun-2" },
  { match: "[u] #Verb", group: 0, tag: "Pronoun", reason: "u-pronoun-1" },
  //the western line
  { match: "#Determiner [(western|eastern|northern|southern|central)] #Noun", group: 0, tag: "Noun", reason: "western-line" },
  //air-flow
  { match: "(#Singular && @hasHyphen) #PresentTense", tag: "Noun", reason: "hyphen-verb" },
  //is no walk
  { match: "is no [#Verb]", group: 0, tag: "Noun", reason: "is-no-verb" },
  //do so
  { match: "do [so]", group: 0, tag: "Noun", reason: "so-noun" },
  // what the hell
  { match: "#Determiner [(shit|damn|hell)]", group: 0, tag: "Noun", reason: "swears-noun" },
  // go to shit
  { match: "to [(shit|hell)]", group: 0, tag: "Noun", reason: "to-swears" },
  // the staff were
  { match: "(the|these) [#Singular] (were|are)", group: 0, tag: "Plural", reason: "singular-were" },
  // a comdominium, or simply condo
  { match: `a #Noun+ or #Adverb+? [#Verb]`, group: 0, tag: "Noun", reason: "noun-or-noun" },
  // walk the walk
  { match: "(the|those|these|a|an) #Adjective? [#PresentTense #Particle?]", group: 0, tag: "Noun", notIf: "(seem|appear|include|#Gerund|#Copula)", reason: "det-inf" },
  // { match: '(the|those|these|a|an) #Adjective? [#PresentTense #Particle?]', group: 0, tag: 'Noun', notIf: '(#Gerund|#Copula)', reason: 'det-pres' },
  // ==== Actor ====
  //Aircraft designer
  { match: "#Noun #Actor", tag: "Actor", notIf: "(#Person|#Pronoun)", reason: "thing-doer" },
  //lighting designer
  { match: "#Gerund #Actor", tag: "Actor", reason: "gerund-doer" },
  // captain sanders
  // { match: '[#Actor+] #ProperNoun', group: 0, tag: 'Honorific', reason: 'sgt-kelly' },
  // co-founder
  { match: `co #Singular`, tag: "Actor", reason: "co-noun" },
  // co-founder
  { match: `[#Noun+] #Actor`, group: 0, tag: "Actor", notIf: "(#Honorific|#Pronoun|#Possessive)", reason: "air-traffic-controller" },
  // fine-artist
  { match: `(urban|cardiac|cardiovascular|respiratory|medical|clinical|visual|graphic|creative|dental|exotic|fine|certified|registered|technical|virtual|professional|amateur|junior|senior|special|pharmaceutical|theoretical)+ #Noun? #Actor`, tag: "Actor", reason: "fine-artist" },
  // dance coach
  { match: `#Noun+ (coach|chef|king|engineer|fellow|personality|boy|girl|man|woman|master)`, tag: "Actor", reason: "dance-coach" },
  // chief design officer
  { match: `chief . officer`, tag: "Actor", reason: "chief-x-officer" },
  // chief of police
  { match: `chief of #Noun+`, tag: "Actor", reason: "chief-of-police" },
  // president of marketing
  { match: `senior? vice? president of #Noun+`, tag: "Actor", reason: "president-of" },
  // ==== Singular ====
  //the sun
  { match: "#Determiner [sun]", group: 0, tag: "Singular", reason: "the-sun" },
  //did a 900, paid a 20
  { match: "#Verb (a|an) [#Value]$", group: 0, tag: "Singular", reason: "did-a-value" },
  //'the can'
  { match: "the [(can|will|may)]", group: 0, tag: "Singular", reason: "the can" },
  // ==== Possessive ====
  //spencer kelly's
  { match: "#FirstName #Acronym? (#Possessive && #LastName)", tag: "Possessive", reason: "name-poss" },
  //Super Corp's fundraiser
  { match: "#Organization+ #Possessive", tag: "Possessive", reason: "org-possessive" },
  //Los Angeles's fundraiser
  { match: "#Place+ #Possessive", tag: "Possessive", reason: "place-possessive" },
  // Ptolemy's experiments
  { match: "#Possessive #PresentTense #Particle?", notIf: "(#Gerund|her)", tag: "Noun", reason: "possessive-verb" },
  // anna's eating vs anna's eating lunch
  // my presidents house
  { match: "(my|our|their|her|his|its) [(#Plural && #Actor)] #Noun", tag: "Possessive", reason: "my-dads" },
  // 10th of a second
  { match: "#Value of a [second]", group: 0, unTag: "Value", tag: "Singular", reason: "10th-of-a-second" },
  // 10 seconds
  { match: "#Value [seconds]", group: 0, unTag: "Value", tag: "Plural", reason: "10-seconds" },
  // in time
  { match: "in [#Infinitive]", group: 0, tag: "Singular", reason: "in-age" },
  // a minor in
  { match: "a [#Adjective] #Preposition", group: 0, tag: "Noun", reason: "a-minor-in" },
  //the repairer said
  { match: "#Determiner [#Singular] said", group: 0, tag: "Actor", reason: "the-actor-said" },
  //the euro sense
  { match: `#Determiner #Noun [${infNouns}] !(#Preposition|to|#Adverb)?`, group: 0, tag: "Noun", reason: "the-noun-sense" },
  // photographs of a computer are
  { match: "[#PresentTense] (of|by|for) (a|an|the) #Noun #Copula", group: 0, tag: "Plural", reason: "photographs-of" },
  // fight and win
  { match: "#Infinitive and [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "fight and win" },
  // peace and flowers and love
  { match: "#Noun and [#Verb] and #Noun", group: 0, tag: "Noun", reason: "peace-and-flowers" },
  // the 1992 classic
  { match: "the #Cardinal [%Adj|Noun%]", group: 0, tag: "Noun", reason: "the-1992-classic" },
  // the premier university
  { match: "#Copula the [%Adj|Noun%] #Noun", group: 0, tag: "Adjective", reason: "the-premier-university" },
  // scottish - i ate me sandwich
  { match: "i #Verb [me] #Noun", group: 0, tag: "Possessive", reason: "scottish-me" },
  // dance music
  { match: "[#PresentTense] (music|class|lesson|night|party|festival|league|ceremony)", group: 0, tag: "Noun", reason: "dance-music" },
  // wit it
  { match: "[wit] (me|it)", group: 0, tag: "Presposition", reason: "wit-me" },
  //left-her-boots, shoved her hand
  { match: "#PastTense #Possessive [#Verb]", group: 0, tag: "Noun", notIf: "(saw|made)", reason: "left-her-boots" },
  //35 signs
  { match: "#Value [%Plural|Verb%]", group: 0, tag: "Plural", notIf: "(one|1|a|an)", reason: "35-signs" },
  //had time
  { match: "had [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Gerund|come|become)", reason: "had-time" },
  //instant access
  { match: "%Adj|Noun% %Noun|Verb%", tag: "#Adjective #Noun", notIf: "#ProperNoun #Noun", reason: "instant-access" },
  // a representative to 
  { match: "#Determiner [%Adj|Noun%] #Conjunction", group: 0, tag: "Noun", reason: "a-rep-to" },
  // near death experiences, ambitious sales targets
  { match: "#Adjective #Noun [%Plural|Verb%]$", group: 0, tag: "Plural", notIf: "#Pronoun", reason: "near-death-experiences" },
  // your guild colors
  { match: "#Possessive #Noun [%Plural|Verb%]$", group: 0, tag: "Plural", reason: "your-guild-colors" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/verbs/noun-gerund.js
var noun_gerund_default2 = [
  // the planning processes
  { match: "(this|that|the|a|an) [#Gerund #Infinitive]", group: 0, tag: "Singular", reason: "the-planning-process" },
  // the paving stones
  { match: "(that|the) [#Gerund #PresentTense]", group: 0, ifNo: "#Copula", tag: "Plural", reason: "the-paving-stones" },
  // this swimming
  // { match: '(this|that|the) [#Gerund]', group: 0, tag: 'Noun', reason: 'this-gerund' },
  // the remaining claims
  { match: "#Determiner [#Gerund] #Noun", group: 0, tag: "Adjective", reason: "the-gerund-noun" },
  // i think tipping sucks
  { match: `#Pronoun #Infinitive [#Gerund] #PresentTense`, group: 0, tag: "Noun", reason: "tipping-sucks" },
  // early warning
  { match: "#Adjective [#Gerund]", group: 0, tag: "Noun", notIf: "(still|even|just)", reason: "early-warning" },
  //walking is cool
  { match: "[#Gerund] #Adverb? not? #Copula", group: 0, tag: "Activity", reason: "gerund-copula" },
  //are doing is
  { match: "#Copula [(#Gerund|#Activity)] #Copula", group: 0, tag: "Gerund", reason: "are-doing-is" },
  //walking should be fun
  { match: "[#Gerund] #Modal", group: 0, tag: "Activity", reason: "gerund-modal" },
  // finish listening
  // { match: '#Infinitive [#Gerund]', group: 0, tag: 'Activity', reason: 'finish-listening' },
  // the ruling party
  // responsibility for setting
  { match: "#Singular for [%Noun|Gerund%]", group: 0, tag: "Gerund", reason: "noun-for-gerund" },
  // better for training
  { match: "#Comparative (for|at) [%Noun|Gerund%]", group: 0, tag: "Gerund", reason: "better-for-gerund" },
  // keep the touching
  { match: "#PresentTense the [#Gerund]", group: 0, tag: "Noun", reason: "keep-the-touching" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/verbs/verb-noun.js
var verb_noun_default = [
  // do the dance
  { match: "#Infinitive (this|that|the) [#Infinitive]", group: 0, tag: "Noun", reason: "do-this-dance" },
  //running-a-show
  { match: "#Gerund #Determiner [#Infinitive]", group: 0, tag: "Noun", reason: "running-a-show" },
  //the-only-reason
  { match: "#Determiner (only|further|just|more|backward) [#Infinitive]", group: 0, tag: "Noun", reason: "the-only-reason" },
  // a stream runs
  { match: "(the|this|a|an) [#Infinitive] #Adverb? #Verb", group: 0, tag: "Noun", reason: "determiner5" },
  //a nice deal
  { match: "#Determiner #Adjective #Adjective? [#Infinitive]", group: 0, tag: "Noun", reason: "a-nice-inf" },
  // the mexican train
  { match: "#Determiner #Demonym [#PresentTense]", group: 0, tag: "Noun", reason: "mexican-train" },
  //next career move
  { match: "#Adjective #Noun+ [#Infinitive] #Copula", group: 0, tag: "Noun", reason: "career-move" },
  // at some point
  { match: "at some [#Infinitive]", group: 0, tag: "Noun", reason: "at-some-inf" },
  // goes to sleep
  { match: "(go|goes|went) to [#Infinitive]", group: 0, tag: "Noun", reason: "goes-to-verb" },
  //a close watch on
  { match: "(a|an) #Adjective? #Noun [#Infinitive] (#Preposition|#Noun)", group: 0, notIf: "from", tag: "Noun", reason: "a-noun-inf" },
  //a tv show
  { match: "(a|an) #Noun [#Infinitive]$", group: 0, tag: "Noun", reason: "a-noun-inf2" },
  //is mark hughes
  // { match: '#Copula [#Infinitive] #Noun', group: 0, tag: 'Noun', reason: 'is-pres-noun' },
  // good wait staff
  // { match: '#Adjective [#Infinitive] #Noun', group: 0, tag: 'Noun', reason: 'good-wait-staff' },
  // running for congress
  { match: "#Gerund #Adjective? for [#Infinitive]", group: 0, tag: "Noun", reason: "running-for" },
  // running to work
  // { match: '#Gerund #Adjective to [#Infinitive]', group: 0, tag: 'Noun', reason: 'running-to' },
  // about love
  { match: "about [#Infinitive]", group: 0, tag: "Singular", reason: "about-love" },
  // singers on stage
  { match: "#Plural on [#Infinitive]", group: 0, tag: "Noun", reason: "on-stage" },
  // any charge
  { match: "any [#Infinitive]", group: 0, tag: "Noun", reason: "any-charge" },
  // no doubt
  { match: "no [#Infinitive]", group: 0, tag: "Noun", reason: "no-doubt" },
  // number of seats
  { match: "number of [#PresentTense]", group: 0, tag: "Noun", reason: "number-of-x" },
  // teaches/taught
  { match: "(taught|teaches|learns|learned) [#PresentTense]", group: 0, tag: "Noun", reason: "teaches-x" },
  // use reverse
  { match: "(try|use|attempt|build|make) [#Verb #Particle?]", notIf: "(#Copula|#Noun|sure|fun|up)", group: 0, tag: "Noun", reason: "do-verb" },
  //make sure of
  // checkmate is
  { match: "^[#Infinitive] (is|was)", group: 0, tag: "Noun", reason: "checkmate-is" },
  // get much sleep
  { match: "#Infinitive much [#Infinitive]", group: 0, tag: "Noun", reason: "get-much" },
  // cause i gotta
  { match: "[cause] #Pronoun #Verb", group: 0, tag: "Conjunction", reason: "cause-cuz" },
  // the cardio dance party
  { match: "the #Singular [#Infinitive] #Noun", group: 0, tag: "Noun", notIf: "#Pronoun", reason: "cardio-dance" },
  // that should smoke
  { match: "#Determiner #Modal [#Noun]", group: 0, tag: "PresentTense", reason: "should-smoke" },
  //this rocks
  { match: "this [#Plural]", group: 0, tag: "PresentTense", notIf: "(#Preposition|#Date)", reason: "this-verbs" },
  //voice that rocks
  { match: "#Noun that [#Plural]", group: 0, tag: "PresentTense", notIf: "(#Preposition|#Pronoun|way)", reason: "voice-that-rocks" },
  //that leads to
  { match: "that [#Plural] to", group: 0, tag: "PresentTense", notIf: "#Preposition", reason: "that-leads-to" },
  //let him glue
  {
    match: "(let|make|made) (him|her|it|#Person|#Place|#Organization)+ [#Singular] (a|an|the|it)",
    group: 0,
    tag: "Infinitive",
    reason: "let-him-glue"
  },
  // assign all tasks
  { match: "#Verb (all|every|each|most|some|no) [#PresentTense]", notIf: "#Modal", group: 0, tag: "Noun", reason: "all-presentTense" },
  // PresentTense/Noun ambiguities
  // big dreams, critical thinking
  // have big dreams
  { match: "(had|have|#PastTense) #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "better", reason: "adj-presentTense" },
  // excellent answer spencer
  // { match: '^#Adjective [#PresentTense]', group: 0, tag: 'Noun', reason: 'start adj-presentTense' },
  // one big reason
  { match: "#Value #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "one-big-reason" },
  // won widespread support
  { match: "#PastTense #Adjective+ [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Copula|better)", reason: "won-wide-support" },
  // many poses
  { match: "(many|few|several|couple) [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "many-poses" },
  // very big dreams
  { match: "#Determiner #Adverb #Adjective [%Noun|Verb%]", group: 0, tag: "Noun", notIf: "#Copula", reason: "very-big-dream" },
  // from start to finish
  { match: "from #Noun to [%Noun|Verb%]", group: 0, tag: "Noun", reason: "start-to-finish" },
  // for comparison or contrast
  { match: "(for|with|of) #Noun (and|or|not) [%Noun|Verb%]", group: 0, tag: "Noun", notIf: "#Pronoun", reason: "for-food-and-gas" },
  // adorable little store
  { match: "#Adjective #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "adorable-little-store" },
  // of basic training
  // { match: '#Preposition #Adjective [#PresentTense]', group: 0, tag: 'Noun', reason: 'of-basic-training' },
  // justifiying higher costs
  { match: "#Gerund #Adverb? #Comparative [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "higher-costs" },
  { match: "(#Noun && @hasComma) #Noun (and|or) [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "noun-list" },
  // any questions for
  { match: "(many|any|some|several) [#PresentTense] for", group: 0, tag: "Noun", reason: "any-verbs-for" },
  // to facilitate gas exchange with
  { match: `to #PresentTense #Noun [#PresentTense] #Preposition`, group: 0, tag: "Noun", reason: "gas-exchange" },
  // waited until release
  { match: `#PastTense (until|as|through|without) [#PresentTense]`, group: 0, tag: "Noun", reason: "waited-until-release" },
  // selling like hot cakes
  { match: `#Gerund like #Adjective? [#PresentTense]`, group: 0, tag: "Plural", reason: "like-hot-cakes" },
  // some valid reason
  { match: `some #Adjective [#PresentTense]`, group: 0, tag: "Noun", reason: "some-reason" },
  // for some reason
  { match: `for some [#PresentTense]`, group: 0, tag: "Noun", reason: "for-some-reason" },
  // same kind of shouts
  { match: `(same|some|the|that|a) kind of [#PresentTense]`, group: 0, tag: "Noun", reason: "some-kind-of" },
  // a type of shout
  { match: `(same|some|the|that|a) type of [#PresentTense]`, group: 0, tag: "Noun", reason: "some-type-of" },
  // doing better for fights
  { match: `#Gerund #Adjective #Preposition [#PresentTense]`, group: 0, tag: "Noun", reason: "doing-better-for-x" },
  // get better aim
  { match: `(get|got|have) #Comparative [#PresentTense]`, group: 0, tag: "Noun", reason: "got-better-aim" },
  // whose name was
  { match: "whose [#PresentTense] #Copula", group: 0, tag: "Noun", reason: "whos-name-was" },
  // give up on reason
  { match: `#PhrasalVerb #Particle #Preposition [#PresentTense]`, group: 0, tag: "Noun", reason: "given-up-on-x" },
  //there are reasons
  { match: "there (are|were) #Adjective? [#PresentTense]", group: 0, tag: "Plural", reason: "there-are" },
  // 30 trains
  { match: "#Value [#PresentTense] of", group: 0, notIf: "(one|1|#Copula|#Infinitive)", tag: "Plural", reason: "2-trains" },
  // compromises are possible
  { match: "[#PresentTense] (are|were) #Adjective", group: 0, tag: "Plural", reason: "compromises-are-possible" },
  // hope i helped
  { match: "^[(hope|guess|thought|think)] #Pronoun #Verb", group: 0, tag: "Infinitive", reason: "suppose-i" },
  //pursue its dreams
  // { match: '#PresentTense #Possessive [#PresentTense]', notIf: '#Gerund', group: 0, tag: 'Plural', reason: 'pursue-its-dreams' },
  // our unyielding support
  { match: "#Possessive #Adjective [#Verb]", group: 0, tag: "Noun", notIf: "#Copula", reason: "our-full-support" },
  // tastes good
  { match: "[(tastes|smells)] #Adverb? #Adjective", group: 0, tag: "PresentTense", reason: "tastes-good" },
  // are you playing golf
  // { match: '^are #Pronoun [#Noun]', group: 0, notIf: '(here|there)', tag: 'Verb', reason: 'are-you-x' },
  // ignoring commute
  { match: "#Copula #Gerund [#PresentTense] !by?", group: 0, tag: "Noun", notIf: "going", reason: "ignoring-commute" },
  // noun-pastTense variables
  { match: "#Determiner #Adjective? [(shed|thought|rose|bid|saw|spelt)]", group: 0, tag: "Noun", reason: "noun-past" },
  // 'verb-to'
  // how to watch
  { match: "how to [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "how-to-noun" },
  // which boost it
  { match: "which [%Noun|Verb%] #Noun", group: 0, tag: "Infinitive", reason: "which-boost-it" },
  // asking questions
  { match: "#Gerund [%Plural|Verb%]", group: 0, tag: "Plural", reason: "asking-questions" },
  // ready to stream
  { match: "(ready|available|difficult|hard|easy|made|attempt|try) to [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "ready-to-noun" },
  // bring to market
  { match: "(bring|went|go|drive|run|bike) to [%Noun|Verb%]", group: 0, tag: "Noun", reason: "bring-to-noun" },
  // can i sleep, would you look
  { match: "#Modal #Noun [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "would-you-look" },
  // is just spam
  { match: "#Copula just [#Infinitive]", group: 0, tag: "Noun", reason: "is-just-spam" },
  // request copies
  { match: "^%Noun|Verb% %Plural|Verb%", tag: "Imperative #Plural", reason: "request-copies" },
  // homemade pickles and drinks
  { match: "#Adjective #Plural and [%Plural|Verb%]", group: 0, tag: "#Plural", reason: "pickles-and-drinks" },
  // the 1968 film
  { match: "#Determiner #Year [#Verb]", group: 0, tag: "Noun", reason: "the-1968-film" },
  // the break up
  { match: "#Determiner [#PhrasalVerb #Particle]", group: 0, tag: "Noun", reason: "the-break-up" },
  // the individual goals
  { match: "#Determiner [%Adj|Noun%] #Noun", group: 0, tag: "Adjective", notIf: "(#Pronoun|#Possessive|#ProperNoun)", reason: "the-individual-goals" },
  // work or prepare
  { match: "[%Noun|Verb%] or #Infinitive", group: 0, tag: "Infinitive", reason: "work-or-prepare" },
  // to give thanks
  { match: "to #Infinitive [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Gerund|#Copula|help)", reason: "to-give-thanks" },
  // kills me
  { match: "[#Noun] me", group: 0, tag: "Verb", reason: "kills-me" },
  // removes wrinkles
  { match: "%Plural|Verb% %Plural|Verb%", tag: "#PresentTense #Plural", reason: "removes-wrinkles" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/numbers/money.js
var money_default = [
  { match: "#Money and #Money #Currency?", tag: "Money", reason: "money-and-money" },
  // 6 dollars and 5 cents
  { match: "#Value #Currency [and] #Value (cents|ore|centavos|sens)", group: 0, tag: "money", reason: "and-5-cents" },
  // maybe currencies
  { match: "#Value (mark|rand|won|rub|ore)", tag: "#Money #Currency", reason: "4-mark" },
  // 3 pounds
  { match: "a pound", tag: "#Money #Unit", reason: "a-pound" },
  { match: "#Value (pound|pounds)", tag: "#Money #Unit", reason: "4-pounds" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/numbers/fractions.js
var fractions_default = [
  // half a penny
  { match: "[(half|quarter)] of? (a|an)", group: 0, tag: "Fraction", reason: "millionth" },
  // nearly half
  { match: "#Adverb [half]", group: 0, tag: "Fraction", reason: "nearly-half" },
  // half the
  { match: "[half] the", group: 0, tag: "Fraction", reason: "half-the" },
  // and a half
  { match: "#Cardinal and a half", tag: "Fraction", reason: "and-a-half" },
  // two-halves
  { match: "#Value (halves|halfs|quarters)", tag: "Fraction", reason: "two-halves" },
  // ---ordinals as fractions---
  // a fifth
  { match: "a #Ordinal", tag: "Fraction", reason: "a-quarter" },
  // seven fifths
  { match: "[#Cardinal+] (#Fraction && /s$/)", tag: "Fraction", reason: "seven-fifths" },
  // doc.match('(#Fraction && /s$/)').lookBefore('#Cardinal+$').tag('Fraction')
  // one third of ..
  { match: "[#Cardinal+ #Ordinal] of .", group: 0, tag: "Fraction", reason: "ordinal-of" },
  // 100th of
  { match: "[(#NumericValue && #Ordinal)] of .", group: 0, tag: "Fraction", reason: "num-ordinal-of" },
  // a twenty fifth
  { match: "(a|one) #Cardinal?+ #Ordinal", tag: "Fraction", reason: "a-ordinal" },
  // //  '3 out of 5'
  { match: "#Cardinal+ out? of every? #Cardinal", tag: "Fraction", reason: "out-of" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/numbers/numbers.js
var numbers_default = [
  // ==== Ambiguous numbers ====
  // 'second'
  { match: `#Cardinal [second]`, tag: "Unit", reason: "one-second" },
  //'a/an' can mean 1 - "a hour"
  {
    match: "!once? [(a|an)] (#Duration|hundred|thousand|million|billion|trillion)",
    group: 0,
    tag: "Value",
    reason: "a-is-one"
  },
  // ==== PhoneNumber ====
  //1 800 ...
  { match: "1 #Value #PhoneNumber", tag: "PhoneNumber", reason: "1-800-Value" },
  //(454) 232-9873
  { match: "#NumericValue #PhoneNumber", tag: "PhoneNumber", reason: "(800) PhoneNumber" },
  // ==== Currency ====
  // chinese yuan
  { match: "#Demonym #Currency", tag: "Currency", reason: "demonym-currency" },
  // ten bucks
  { match: "#Value [(buck|bucks|grand)]", group: 0, tag: "Currency", reason: "value-bucks" },
  // ==== Money ====
  { match: "[#Value+] #Currency", group: 0, tag: "Money", reason: "15 usd" },
  // ==== Ordinal ====
  { match: "[second] #Noun", group: 0, tag: "Ordinal", reason: "second-noun" },
  // ==== Units ====
  //5 yan
  { match: "#Value+ [#Currency]", group: 0, tag: "Unit", reason: "5-yan" },
  { match: "#Value [(foot|feet)]", group: 0, tag: "Unit", reason: "foot-unit" },
  //5 kg.
  { match: "#Value [#Abbreviation]", group: 0, tag: "Unit", reason: "value-abbr" },
  { match: "#Value [k]", group: 0, tag: "Unit", reason: "value-k" },
  { match: "#Unit an hour", tag: "Unit", reason: "unit-an-hour" },
  // ==== Magnitudes ====
  //minus 7
  { match: "(minus|negative) #Value", tag: "Value", reason: "minus-value" },
  //seven point five
  { match: "#Value (point|decimal) #Value", tag: "Value", reason: "value-point-value" },
  //quarter million
  { match: "#Determiner [(half|quarter)] #Ordinal", group: 0, tag: "Value", reason: "half-ordinal" },
  // thousand and two
  { match: `#Multiple+ and #Value`, tag: "Value", reason: "magnitude-and-value" },
  // ambiguous units like 'gb'
  // { match: '#Value square? [(kb|mb|gb|tb|ml|pt|qt|tbl|tbsp|km|cm|mm|mi|ft|yd|kg|hg|mg|oz|lb|mph|pa|miles|yard|yards|pound|pounds)]', group: 0, tag: 'Unit', reason: '12-gb' },
  // 5 miles per hour
  { match: "#Value #Unit [(per|an) (hr|hour|sec|second|min|minute)]", group: 0, tag: "Unit", reason: "12-miles-per-second" },
  // 5 square miles
  { match: "#Value [(square|cubic)] #Unit", group: 0, tag: "Unit", reason: "square-miles" },
  // 5) The expenses
  { match: "^[#Value] (#Determiner|#Gerund)", group: 0, tag: "Expression", unTag: "Value", reason: "numbered-list" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/person/person-phrase.js
var person_phrase_default = [
  // ==== FirstNames ====
  //is foo Smith
  { match: "#Copula [(#Noun|#PresentTense)] #LastName", group: 0, tag: "FirstName", reason: "copula-noun-lastname" },
  //pope francis
  { match: "(sister|pope|brother|father|aunt|uncle|grandpa|grandfather|grandma) #ProperNoun", tag: "Person", reason: "lady-titlecase", safe: true },
  // ==== Nickname ====
  // Dwayne 'the rock' Johnson
  { match: "#FirstName [#Determiner #Noun] #LastName", group: 0, tag: "Person", reason: "first-noun-last" },
  {
    match: "#ProperNoun (b|c|d|e|f|g|h|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z) #ProperNoun",
    tag: "Person",
    reason: "titlecase-acronym-titlecase",
    safe: true
  },
  { match: "#Acronym #LastName", tag: "Person", reason: "acronym-lastname", safe: true },
  { match: "#Person (jr|sr|md)", tag: "Person", reason: "person-honorific" },
  //remove single 'mr'
  { match: "#Honorific #Acronym", tag: "Person", reason: "Honorific-TitleCase" },
  { match: "#Person #Person the? #RomanNumeral", tag: "Person", reason: "roman-numeral" },
  { match: "#FirstName [/^[^aiurck]$/]", group: 0, tag: ["Acronym", "Person"], reason: "john-e" },
  //j.k Rowling
  { match: "#Noun van der? #Noun", tag: "Person", reason: "van der noun", safe: true },
  //king of spain
  { match: "(king|queen|prince|saint|lady) of #Noun", tag: "Person", reason: "king-of-noun", safe: true },
  //lady Florence
  { match: "(prince|lady) #Place", tag: "Person", reason: "lady-place" },
  //saint Foo
  { match: "(king|queen|prince|saint) #ProperNoun", tag: "Person", reason: "saint-foo" },
  // al sharpton
  { match: "al (#Person|#ProperNoun)", tag: "Person", reason: "al-borlen", safe: true },
  //ferdinand de almar
  { match: "#FirstName de #Noun", tag: "Person", reason: "bill-de-noun" },
  //Osama bin Laden
  { match: "#FirstName (bin|al) #Noun", tag: "Person", reason: "bill-al-noun" },
  //John L. Foo
  { match: "#FirstName #Acronym #ProperNoun", tag: "Person", reason: "bill-acronym-title" },
  //Andrew Lloyd Webber
  { match: "#FirstName #FirstName #ProperNoun", tag: "Person", reason: "bill-firstname-title" },
  //Mr Foo
  { match: "#Honorific #FirstName? #ProperNoun", tag: "Person", reason: "dr-john-Title" },
  //peter the great
  { match: "#FirstName the #Adjective", tag: "Person", reason: "name-the-great" },
  // dick van dyke
  { match: "#ProperNoun (van|al|bin) #ProperNoun", tag: "Person", reason: "title-van-title", safe: true },
  //jose de Sucre
  { match: "#ProperNoun (de|du) la? #ProperNoun", tag: "Person", reason: "title-de-title" },
  //Jani K. Smith
  { match: "#Singular #Acronym #LastName", tag: "#FirstName #Person .", reason: "title-acro-noun", safe: true },
  //Foo Ford
  { match: "[#ProperNoun] #Person", group: 0, tag: "Person", reason: "proper-person", safe: true },
  // john keith jones
  { match: "#Person [#ProperNoun #ProperNoun]", group: 0, tag: "Person", notIf: "#Possessive", reason: "three-name-person", safe: true },
  //John Foo
  { match: "#FirstName #Acronym? [#ProperNoun]", group: 0, tag: "LastName", notIf: "#Possessive", reason: "firstname-titlecase" },
  // john stewart
  { match: "#FirstName [#FirstName]", group: 0, tag: "LastName", reason: "firstname-firstname" },
  //Joe K. Sombrero
  { match: "#FirstName #Acronym #Noun", tag: "Person", reason: "n-acro-noun", safe: true },
  //Anthony de Marco
  { match: "#FirstName [(de|di|du|van|von)] #Person", group: 0, tag: "LastName", reason: "de-firstname" },
  // baker jenna smith
  // { match: '[#Actor+] #Person', group: 0, tag: 'Person', reason: 'baker-sam-smith' },
  // sergeant major Harold
  { match: "[(lieutenant|corporal|sergeant|captain|qeen|king|admiral|major|colonel|marshal|president|queen|king)+] #ProperNoun", group: 0, tag: "Honorific", reason: "seargeant-john" },
  // ==== Honorics ====
  { match: "[(private|general|major|rear|prime|field|count|miss)] #Honorific? #Person", group: 0, tag: ["Honorific", "Person"], reason: "ambg-honorifics" },
  // dr john foobar
  { match: "#Honorific #FirstName [#Singular]", group: 0, tag: "LastName", notIf: "#Possessive", reason: "dr-john-foo", safe: true },
  //his-excellency
  { match: "[(his|her) (majesty|honour|worship|excellency|honorable)] #Person", group: 0, tag: "Honorific", reason: "his-excellency" },
  // Lieutenant colonel
  { match: "#Honorific #Actor", tag: "Honorific", reason: "Lieutenant colonel" },
  // first lady, second admiral
  { match: "(first|second|third|1st|2nd|3rd) #Actor", tag: "Honorific", reason: "first lady" },
  // Louis IV
  { match: "#Person #RomanNumeral", tag: "Person", reason: "louis-IV" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/person/ambig-name.js
var ambig_name_default = [
  // ===person-date===
  { match: "%Person|Date% #Acronym? #ProperNoun", tag: "Person", reason: "jan-thierson" },
  // ===person-noun===
  //Cliff Clavin
  { match: "%Person|Noun% #Acronym? #ProperNoun", tag: "Person", reason: "switch-person", safe: true },
  // olive garden
  { match: "%Person|Noun% #Organization", tag: "Organization", reason: "olive-garden" },
  // ===person-verb===
  // ollie faroo
  { match: "%Person|Verb% #Acronym? #ProperNoun", tag: "Person", reason: "verb-propernoun", ifNo: "#Actor" },
  // chuck will ...
  { match: `[%Person|Verb%] (will|had|has|said|says|told|did|learned|wants|wanted)`, group: 0, tag: "Person", reason: "person-said" },
  // ===person-place===
  //sydney harbour
  { match: `[%Person|Place%] (harbor|harbour|pier|town|city|place|dump|landfill)`, group: 0, tag: "Place", reason: "sydney-harbour" },
  // east sydney
  { match: `(west|east|north|south) [%Person|Place%]`, group: 0, tag: "Place", reason: "east-sydney" },
  // ===person-adjective===
  // rusty smith
  // { match: `${personAdj} #Person`, tag: 'Person', reason: 'randy-smith' },
  // rusty a. smith
  // { match: `${personAdj} #Acronym? #ProperNoun`, tag: 'Person', reason: 'rusty-smith' },
  // very rusty
  // { match: `#Adverb [${personAdj}]`, group: 0, tag: 'Adjective', reason: 'really-rich' },
  // ===person-verb===
  // would wade
  { match: `#Modal [%Person|Verb%]`, group: 0, tag: "Verb", reason: "would-mark" },
  // really wade
  { match: `#Adverb [%Person|Verb%]`, group: 0, tag: "Verb", reason: "really-mark" },
  // drew closer
  { match: `[%Person|Verb%] (#Adverb|#Comparative)`, group: 0, tag: "Verb", reason: "drew-closer" },
  // wade smith
  { match: `%Person|Verb% #Person`, tag: "Person", reason: "rob-smith" },
  // wade m. Cooper
  { match: `%Person|Verb% #Acronym #ProperNoun`, tag: "Person", reason: "rob-a-smith" },
  // will go
  { match: "[will] #Verb", group: 0, tag: "Modal", reason: "will-verb" },
  // will Pharell
  { match: "(will && @isTitleCase) #ProperNoun", tag: "Person", reason: "will-name" },
  // jack layton won
  { match: "(#FirstName && !#Possessive) [#Singular] #Verb", group: 0, safe: true, tag: "LastName", reason: "jack-layton" },
  // sherwood anderson told
  { match: "^[#Singular] #Person #Verb", group: 0, safe: true, tag: "Person", reason: "sherwood-anderson" },
  // bought a warhol
  { match: "(a|an) [#Person]$", group: 0, unTag: "Person", reason: "a-warhol" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/verbs/verbs.js
var verbs_default3 = [
  //sometimes adverbs - 'pretty good','well above'
  {
    match: "#Copula (pretty|dead|full|well|sure) (#Adjective|#Noun)",
    tag: "#Copula #Adverb #Adjective",
    reason: "sometimes-adverb"
  },
  //i better ..
  { match: "(#Pronoun|#Person) (had|#Adverb)? [better] #PresentTense", group: 0, tag: "Modal", reason: "i-better" },
  // adj -> gerund
  // like
  { match: "(#Modal|i|they|we|do) not? [like]", group: 0, tag: "PresentTense", reason: "modal-like" },
  // ==== Tense ====
  //he left
  { match: "#Noun #Adverb? [left]", group: 0, tag: "PastTense", reason: "left-verb" },
  // ==== Copula ====
  //will be running (not copula)
  { match: "will #Adverb? not? #Adverb? [be] #Gerund", group: 0, tag: "Copula", reason: "will-be-copula" },
  //for more complex forms, just tag 'be'
  { match: "will #Adverb? not? #Adverb? [be] #Adjective", group: 0, tag: "Copula", reason: "be-copula" },
  // ==== Infinitive ====
  //march to
  { match: "[march] (up|down|back|toward)", notIf: "#Date", group: 0, tag: "Infinitive", reason: "march-to" },
  //must march
  { match: "#Modal [march]", group: 0, tag: "Infinitive", reason: "must-march" },
  // may be
  { match: `[may] be`, group: 0, tag: "Verb", reason: "may-be" },
  // subject to
  { match: `[(subject|subjects|subjected)] to`, group: 0, tag: "Verb", reason: "subject to" },
  // subject to
  { match: `[home] to`, group: 0, tag: "PresentTense", reason: "home to" },
  // === misc==
  // side with
  // { match: '[(side|fool|monkey)] with', group: 0, tag: 'Infinitive', reason: 'fool-with' },
  // open the door
  { match: "[open] #Determiner", group: 0, tag: "Infinitive", reason: "open-the" },
  //were being run
  { match: `(were|was) being [#PresentTense]`, group: 0, tag: "PastTense", reason: "was-being" },
  //had been broken
  { match: `(had|has|have) [been /en$/]`, group: 0, tag: "Auxiliary Participle", reason: "had-been-broken" },
  //had been smoked
  { match: `(had|has|have) [been /ed$/]`, group: 0, tag: "Auxiliary PastTense", reason: "had-been-smoked" },
  //were being run
  { match: `(had|has) #Adverb? [been] #Adverb? #PastTense`, group: 0, tag: "Auxiliary", reason: "had-been-adj" },
  //had to walk
  { match: `(had|has) to [#Noun] (#Determiner|#Possessive)`, group: 0, tag: "Infinitive", reason: "had-to-noun" },
  // have read
  { match: `have [#PresentTense]`, group: 0, tag: "PastTense", notIf: "(come|gotten)", reason: "have-read" },
  // does that work
  { match: `(does|will|#Modal) that [work]`, group: 0, tag: "PastTense", reason: "does-that-work" },
  // sounds fun
  { match: `[(sound|sounds)] #Adjective`, group: 0, tag: "PresentTense", reason: "sounds-fun" },
  // look good
  { match: `[(look|looks)] #Adjective`, group: 0, tag: "PresentTense", reason: "looks-good" },
  // stops thinking
  { match: `[(start|starts|stop|stops|begin|begins)] #Gerund`, group: 0, tag: "Verb", reason: "starts-thinking" },
  // have read
  { match: `(have|had) read`, tag: "Modal #PastTense", reason: "read-read" },
  //were under cooked
  {
    match: `(is|was|were) [(under|over) #PastTense]`,
    group: 0,
    tag: "Adverb Adjective",
    reason: "was-under-cooked"
  },
  // damn them
  { match: "[shit] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear1-verb" },
  { match: "[damn] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear2-verb" },
  { match: "[fuck] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear3-verb" },
  // jobs that fit
  { match: "#Plural that %Noun|Verb%", tag: ". #Preposition #Infinitive", reason: "jobs-that-work" },
  // works for me
  { match: "[works] for me", group: 0, tag: "PresentTense", reason: "works-for-me" },
  // as we please
  { match: "as #Pronoun [please]", group: 0, tag: "Infinitive", reason: "as-we-please" },
  // verb-prefixes - 'co write'
  { match: "[(co|mis|de|inter|intra|pre|re|un|out|under|over|counter)] #Verb", group: 0, tag: ["Verb", "Prefix"], notIf: "(#Copula|#PhrasalVerb)", reason: "co-write" },
  // dressed and left
  { match: "#PastTense and [%Adj|Past%]", group: 0, tag: "PastTense", reason: "dressed-and-left" },
  // melted and fallen
  { match: "[%Adj|Past%] and #PastTense", group: 0, tag: "PastTense", reason: "dressed-and-left" },
  // is he stoked
  { match: "#Copula #Pronoun [%Adj|Past%]", group: 0, tag: "Adjective", reason: "is-he-stoked" },
  // to dream of
  { match: "to [%Noun|Verb%] #Preposition", group: 0, tag: "Infinitive", reason: "to-dream-of" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/verbs/auxiliary.js
var auxiliary_default = [
  // ==== Auxiliary ====
  // have been
  { match: `will (#Adverb|not)+? [have] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "will-have-vb" },
  //was walking
  { match: `[#Copula] (#Adverb|not)+? (#Gerund|#PastTense)`, group: 0, tag: "Auxiliary", reason: "copula-walking" },
  //would walk
  { match: `[(#Modal|did)+] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "modal-verb" },
  //would have had
  { match: `#Modal (#Adverb|not)+? [have] (#Adverb|not)+? [had] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "would-have" },
  //support a splattering of auxillaries before a verb
  { match: `[(has|had)] (#Adverb|not)+? #PastTense`, group: 0, tag: "Auxiliary", reason: "had-walked" },
  // will walk
  { match: "[(do|does|did|will|have|had|has|got)] (not|#Adverb)+? #Verb", group: 0, tag: "Auxiliary", reason: "have-had" },
  // about to go
  { match: "[about to] #Adverb? #Verb", group: 0, tag: ["Auxiliary", "Verb"], reason: "about-to" },
  //would be walking
  { match: `#Modal (#Adverb|not)+? [be] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "would-be" },
  //had been walking
  { match: `[(#Modal|had|has)] (#Adverb|not)+? [been] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "had-been" },
  // was being driven
  { match: "[(be|being|been)] #Participle", group: 0, tag: "Auxiliary", reason: "being-driven" },
  // may want
  { match: "[may] #Adverb? #Infinitive", group: 0, tag: "Auxiliary", reason: "may-want" },
  // was being walked
  { match: "#Copula (#Adverb|not)+? [(be|being|been)] #Adverb+? #PastTense", group: 0, tag: "Auxiliary", reason: "being-walked" },
  // will be walked
  { match: "will [be] #PastTense", group: 0, tag: "Auxiliary", reason: "will-be-x" },
  // been walking
  { match: "[(be|been)] (#Adverb|not)+? #Gerund", group: 0, tag: "Auxiliary", reason: "been-walking" },
  // used to walk
  { match: "[used to] #PresentTense", group: 0, tag: "Auxiliary", reason: "used-to-walk" },
  // was going to walk
  { match: "#Copula (#Adverb|not)+? [going to] #Adverb+? #PresentTense", group: 0, tag: "Auxiliary", reason: "going-to-walk" },
  // tell me
  { match: "#Imperative [(me|him|her)]", group: 0, tag: "Reflexive", reason: "tell-him" },
  // there is no x
  { match: "(is|was) #Adverb? [no]", group: 0, tag: "Negative", reason: "is-no" },
  // been told
  { match: "[(been|had|became|came)] #PastTense", group: 0, notIf: "#PhrasalVerb", tag: "Auxiliary", reason: "been-told" },
  // being born
  { match: "[(being|having|getting)] #Verb", group: 0, tag: "Auxiliary", reason: "being-born" },
  // be walking
  { match: "[be] #Gerund", group: 0, tag: "Auxiliary", reason: "be-walking" },
  // better go
  { match: "[better] #PresentTense", group: 0, tag: "Modal", notIf: "(#Copula|#Gerund)", reason: "better-go" },
  // even better
  { match: "even better", tag: "Adverb #Comparative", reason: "even-better" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/verbs/phrasal.js
var phrasal_default = [
  // ==== Phrasal ====
  //'foo-up'
  { match: "(#Verb && @hasHyphen) up", tag: "PhrasalVerb", reason: "foo-up" },
  { match: "(#Verb && @hasHyphen) off", tag: "PhrasalVerb", reason: "foo-off" },
  { match: "(#Verb && @hasHyphen) over", tag: "PhrasalVerb", reason: "foo-over" },
  { match: "(#Verb && @hasHyphen) out", tag: "PhrasalVerb", reason: "foo-out" },
  // walk in on
  {
    match: "[#Verb (in|out|up|down|off|back)] (on|in)",
    notIf: "#Copula",
    tag: "PhrasalVerb Particle",
    reason: "walk-in-on"
  },
  // went on for
  { match: "(lived|went|crept|go) [on] for", group: 0, tag: "PhrasalVerb", reason: "went-on" },
  // the curtains come down
  { match: "#Verb (up|down|in|on|for)$", tag: "PhrasalVerb #Particle", notIf: "#PhrasalVerb", reason: "come-down$" },
  // got me thinking
  // { match: '(got|had) me [#Noun]', group: 0, tag: 'Verb', reason: 'got-me-gerund' },
  // help stop
  { match: "help [(stop|end|make|start)]", group: 0, tag: "Infinitive", reason: "help-stop" },
  // work in the office
  { match: "#PhrasalVerb (in && #Particle) #Determiner", tag: "#Verb #Preposition #Determiner", unTag: "PhrasalVerb", reason: "work-in-the" },
  // start listening
  { match: "[(stop|start|finish|help)] #Gerund", group: 0, tag: "Infinitive", reason: "start-listening" },
  // mis-fired
  // { match: '[(mis)] #Verb', group: 0, tag: 'Verb', reason: 'mis-firedsa' },
  //back it up
  {
    match: "#Verb (him|her|it|us|himself|herself|itself|everything|something) [(up|down)]",
    group: 0,
    tag: "Adverb",
    reason: "phrasal-pronoun-advb"
  }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/verbs/imperative.js
var notIf2 = "(i|we|they)";
var imperative_default2 = [
  // do not go
  { match: "^do not? [#Infinitive #Particle?]", notIf: notIf2, group: 0, tag: "Imperative", reason: "do-eat" },
  // please go
  { match: "^please do? not? [#Infinitive #Particle?]", group: 0, tag: "Imperative", reason: "please-go" },
  // just go
  { match: "^just do? not? [#Infinitive #Particle?]", group: 0, tag: "Imperative", reason: "just-go" },
  // do it better
  { match: "^[#Infinitive] it #Comparative", notIf: notIf2, group: 0, tag: "Imperative", reason: "do-it-better" },
  // do it again
  { match: "^[#Infinitive] it (please|now|again|plz)", notIf: notIf2, group: 0, tag: "Imperative", reason: "do-it-please" },
  // go quickly.
  { match: "^[#Infinitive] (#Adjective|#Adverb)$", group: 0, tag: "Imperative", notIf: "(so|such|rather|enough)", reason: "go-quickly" },
  // turn down the noise
  { match: "^[#Infinitive] (up|down|over) #Determiner", group: 0, tag: "Imperative", reason: "turn-down" },
  // eat my shorts
  { match: "^[#Infinitive] (your|my|the|a|an|any|each|every|some|more|with|on)", group: 0, notIf: "like", tag: "Imperative", reason: "eat-my-shorts" },
  // tell him the story
  { match: "^[#Infinitive] (him|her|it|us|me|there)", group: 0, tag: "Imperative", reason: "tell-him" },
  // avoid loud noises
  { match: "^[#Infinitive] #Adjective #Noun$", group: 0, tag: "Imperative", reason: "avoid-loud-noises" },
  // call and reserve
  { match: "^[#Infinitive] (#Adjective|#Adverb)? and #Infinitive", group: 0, tag: "Imperative", reason: "call-and-reserve" },
  // one-word imperatives
  { match: "^(go|stop|wait|hurry) please?$", tag: "Imperative", reason: "go" },
  // somebody call
  { match: "^(somebody|everybody) [#Infinitive]", group: 0, tag: "Imperative", reason: "somebody-call" },
  // let's leave
  { match: "^let (us|me) [#Infinitive]", group: 0, tag: "Imperative", reason: "lets-leave" },
  // shut the door
  { match: "^[(shut|close|open|start|stop|end|keep)] #Determiner #Noun", group: 0, tag: "Imperative", reason: "shut-the-door" },
  // turn off the light
  { match: "^[#PhrasalVerb #Particle] #Determiner #Noun", group: 0, tag: "Imperative", reason: "turn-off-the-light" },
  // go to toronto
  { match: "^[go] to .", group: 0, tag: "Imperative", reason: "go-to-toronto" },
  // would you recommend
  { match: "^#Modal you [#Infinitive]", group: 0, tag: "Imperative", reason: "would-you-" },
  // never say
  { match: "^never [#Infinitive]", group: 0, tag: "Imperative", reason: "never-stop" },
  // come have a drink
  { match: "^come #Infinitive", tag: "Imperative", notIf: "on", reason: "come-have" },
  // come and have a drink
  { match: "^come and? #Infinitive", tag: "Imperative . Imperative", notIf: "#PhrasalVerb", reason: "come-and-have" },
  // stay away
  { match: "^stay (out|away|back)", tag: "Imperative", reason: "stay-away" },
  // stay cool
  { match: "^[(stay|be|keep)] #Adjective", group: 0, tag: "Imperative", reason: "stay-cool" },
  // keep it silent
  { match: "^[keep it] #Adjective", group: 0, tag: "Imperative", reason: "keep-it-cool" },
  // don't be late
  { match: "^do not [#Infinitive]", group: 0, tag: "Imperative", reason: "do-not-be" },
  // allow yourself
  { match: "[#Infinitive] (yourself|yourselves)", group: 0, tag: "Imperative", reason: "allow-yourself" },
  // look what
  { match: "[#Infinitive] what .", group: 0, tag: "Imperative", reason: "look-what" },
  // continue playing
  { match: "^[#Infinitive] #Gerund", group: 0, tag: "Imperative", reason: "keep-playing" },
  // go to it
  { match: "^[#Infinitive] (to|for|into|toward|here|there)", group: 0, tag: "Imperative", reason: "go-to" },
  // relax and unwind
  { match: "^[#Infinitive] (and|or) #Infinitive", group: 0, tag: "Imperative", reason: "inf-and-inf" },
  // commit to
  { match: "^[%Noun|Verb%] to", group: 0, tag: "Imperative", reason: "commit-to" },
  // maintain eye contact
  { match: "^[#Infinitive] #Adjective? #Singular #Singular", group: 0, tag: "Imperative", reason: "maintain-eye-contact" },
  // don't forget to clean
  { match: "do not (forget|omit|neglect) to [#Infinitive]", group: 0, tag: "Imperative", reason: "do-not-forget" },
  // pay attention
  { match: "^[(ask|wear|pay|look|help|show|watch|act|fix|kill|stop|start|turn|try|win)] #Noun", group: 0, tag: "Imperative", reason: "pay-attention" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/verbs/adj-gerund.js
var adj_gerund_default3 = [
  // that were growing
  { match: "(that|which) were [%Adj|Gerund%]", group: 0, tag: "Gerund", reason: "that-were-growing" },
  // repairing crubling roads
  { match: "#Gerund [#Gerund] #Plural", group: 0, tag: "Adjective", reason: "hard-working-fam" }
  // { match: '(that|which) were [%Adj|Gerund%]', group: 0, tag: 'Gerund', reason: 'that-were-growing' },
];

// ../../node_modules/compromise/src/2-two/postTagger/model/verbs/passive.js
var passive_default = [
  // got walked, was walked, were walked
  { match: "(got|were|was|is|are|am) (#PastTense|#Participle)", tag: "Passive", reason: "got-walked" },
  // was being walked
  { match: "(was|were|is|are|am) being (#PastTense|#Participle)", tag: "Passive", reason: "was-being" },
  // had been walked, have been eaten
  { match: "(had|have|has) been (#PastTense|#Participle)", tag: "Passive", reason: "had-been" },
  // will be cleaned
  { match: "will be being? (#PastTense|#Participle)", tag: "Passive", reason: "will-be-cleaned" },
  // suffered by the country
  { match: "#Noun [(#PastTense|#Participle)] by (the|a) #Noun", group: 0, tag: "Passive", reason: "suffered-by" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/_misc.js
var matches = [
  // u r cool
  { match: "u r", tag: "#Pronoun #Copula", reason: "u r" },
  { match: "#Noun [(who|whom)]", group: 0, tag: "Determiner", reason: "captain-who" },
  // ==== Conditions ====
  // had he survived,
  { match: "[had] #Noun+ #PastTense", group: 0, tag: "Condition", reason: "had-he" },
  // were he to survive
  { match: "[were] #Noun+ to #Infinitive", group: 0, tag: "Condition", reason: "were-he" },
  // some sort of
  { match: "some sort of", tag: "Adjective Noun Conjunction", reason: "some-sort-of" },
  // some of
  // { match: 'some of', tag: 'Noun Conjunction', reason: 'some-of' },
  // of some sort
  { match: "of some sort", tag: "Conjunction Adjective Noun", reason: "of-some-sort" },
  // such skill
  { match: "[such] (a|an|is)? #Noun", group: 0, tag: "Determiner", reason: "such-skill" },
  // another one
  // { match: '[another] (#Noun|#Value)', group: 0, tag: 'Adjective', reason: 'another-one' },
  // right after
  { match: "[right] (before|after|in|into|to|toward)", group: 0, tag: "#Adverb", reason: "right-into" },
  // at about
  { match: "#Preposition [about]", group: 0, tag: "Adjective", reason: "at-about" },
  // are ya
  { match: "(are|#Modal|see|do|for) [ya]", group: 0, tag: "Pronoun", reason: "are-ya" },
  // long live
  { match: "[long live] .", group: 0, tag: "#Adjective #Infinitive", reason: "long-live" },
  // plenty of
  { match: "[plenty] of", group: 0, tag: "#Uncountable", reason: "plenty-of" },
  // 'there' as adjective
  { match: "(always|nearly|barely|practically) [there]", group: 0, tag: "Adjective", reason: "always-there" },
  // existential 'there'
  // there she is
  { match: "[there] (#Adverb|#Pronoun)? #Copula", group: 0, tag: "There", reason: "there-is" },
  // is there food
  { match: "#Copula [there] .", group: 0, tag: "There", reason: "is-there" },
  // should there
  { match: "#Modal #Adverb? [there]", group: 0, tag: "There", reason: "should-there" },
  // do you
  { match: "^[do] (you|we|they)", group: 0, tag: "QuestionWord", reason: "do-you" },
  // does he
  { match: "^[does] (he|she|it|#ProperNoun)", group: 0, tag: "QuestionWord", reason: "does-he" },
  // a while
  { match: "a [while]", group: 0, tag: "Noun", reason: "a-while" },
  // guess who
  { match: "guess who", tag: "#Infinitive #QuestionWord", reason: "guess-who" },
  // swear words
  { match: "[fucking] !#Verb", group: 0, tag: "#Gerund", reason: "f-as-gerund" }
];
var misc_default4 = matches;

// ../../node_modules/compromise/src/2-two/postTagger/model/orgs/organizations.js
var organizations_default2 = [
  // Foo University
  // { match: `#Noun ${orgMap}`, tag: 'Organization', safe: true, reason: 'foo-university' },
  // // University of Toronto
  // { match: `${orgMap} of #Place`, tag: 'Organization', safe: true, reason: 'university-of-foo' },
  // // foo regional health authority
  // { match: `${orgMap} (health|local|regional)+ authority`, tag: 'Organization', reason: 'regional-health' },
  // // foo stock exchange
  // { match: `${orgMap} (stock|mergantile)+ exchange`, tag: 'Organization', reason: 'stock-exchange' },
  // // foo news service
  // { match: `${orgMap} (daily|evening|local)+ news service?`, tag: 'Organization', reason: 'foo-news' },
  //John & Joe's
  { match: "#Noun (&|n) #Noun", tag: "Organization", reason: "Noun-&-Noun" },
  // teachers union of Ontario
  { match: "#Organization of the? #ProperNoun", tag: "Organization", reason: "org-of-place", safe: true },
  //walmart USA
  { match: "#Organization #Country", tag: "Organization", reason: "org-country" },
  //organization
  { match: "#ProperNoun #Organization", tag: "Organization", reason: "titlecase-org" },
  //FitBit Inc
  { match: "#ProperNoun (ltd|co|inc|dept|assn|bros)", tag: "Organization", reason: "org-abbrv" },
  // the OCED
  { match: "the [#Acronym]", group: 0, tag: "Organization", reason: "the-acronym", safe: true },
  // global trade union
  {
    match: "(world|global|international|national|#Demonym) #Organization",
    tag: "Organization",
    reason: "global-org"
  },
  // schools
  { match: "#Noun+ (public|private) school", tag: "School", reason: "noun-public-school" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/nouns/places.js
var places_default2 = [
  // ==== Region ====
  //West Norforlk
  { match: "(west|north|south|east|western|northern|southern|eastern)+ #Place", tag: "Region", reason: "west-norfolk" },
  //some us-state acronyms (exlude: al, in, la, mo, hi, me, md, ok..)
  { match: "#City [(al|ak|az|ar|ca|ct|dc|fl|ga|id|il|nv|nh|nj|ny|oh|pa|sc|tn|tx|ut|vt|pr)]", group: 0, tag: "Region", reason: "us-state" },
  // portland oregon
  { match: "portland [or]", group: 0, tag: "Region", reason: "portland-or" },
  //Foo District
  { match: "#ProperNoun+ (district|region|province|county|prefecture|municipality|territory|burough|reservation)", tag: "Region", reason: "foo-district" },
  //landforms - 'Foo river'
  { match: "#ProperNoun+ (river|lake|bay|inlet|creek|narrows|cove|dune|coast|lagoon|beach|peninsula|hill|mountain|canyon|marsh|island|trail|valley|glacier|estuary|desert|escarpment|gorge|plains|waterfall)", tag: "Place", reason: "foo-river" },
  //landforms - 'gulf of foo'
  { match: "(river|gulf|lake) of? #ProperNoun+", tag: "Place", reason: "river-foo" },
  //District of Foo
  { match: "(district|region|province|municipality|territory|burough|state) of #ProperNoun", tag: "Region", reason: "district-of-Foo" },
  // in Foo California
  { match: "in [#ProperNoun] #Place", group: 0, tag: "Place", reason: "propernoun-place" },
  // Address 
  { match: "#Value #Noun (st|street|rd|road|crescent|cr|way|tr|terrace|avenue|ave)", tag: "Address", reason: "address-st" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/conjunctions.js
var conjunctions_default = [
  // ==== Conjunctions ====
  { match: "[so] #Noun", group: 0, tag: "Conjunction", reason: "so-conj" },
  //how he is driving
  {
    match: "[(who|what|where|why|how|when)] #Noun #Copula #Adverb? (#Verb|#Adjective)",
    group: 0,
    tag: "Conjunction",
    reason: "how-he-is-x"
  },
  // when he
  { match: "#Copula [(who|what|where|why|how|when)] #Noun", group: 0, tag: "Conjunction", reason: "when-he" },
  // says that he..
  { match: "#Verb [that] #Pronoun", group: 0, tag: "Conjunction", reason: "said-that-he" },
  // things that are required
  { match: "#Noun [that] #Copula", group: 0, tag: "Conjunction", reason: "that-are" },
  // things that seem cool
  { match: "#Noun [that] #Verb #Adjective", group: 0, tag: "Conjunction", reason: "that-seem" },
  // wasn't that wide..
  { match: "#Noun #Copula not? [that] #Adjective", group: 0, tag: "Adverb", reason: "that-adj" },
  // ==== Prepositions ====
  //all students
  { match: "#Verb #Adverb? #Noun [(that|which)]", group: 0, tag: "Preposition", reason: "that-prep" },
  //work, which has been done.
  { match: "@hasComma [which] (#Pronoun|#Verb)", group: 0, tag: "Preposition", reason: "which-copula" },
  //folks like her
  { match: "#Noun [like] #Noun", group: 0, tag: "Preposition", reason: "noun-like" },
  //like the time
  { match: "^[like] #Determiner", group: 0, tag: "Preposition", reason: "like-the" },
  //a day like this
  { match: "a #Noun [like] (#Noun|#Determiner)", group: 0, tag: "Preposition", reason: "a-noun-like" },
  // really like
  { match: "#Adverb [like]", group: 0, tag: "Verb", reason: "really-like" },
  // nothing like
  { match: "(not|nothing|never) [like]", group: 0, tag: "Preposition", reason: "nothing-like" },
  // treat them like
  { match: "#Infinitive #Pronoun [like]", group: 0, tag: "Preposition", reason: "treat-them-like" },
  // ==== Questions ====
  // where
  // why
  // when
  // who
  // whom
  // whose
  // what
  // which
  //the word 'how many'
  // { match: '^(how|which)', tag: 'QuestionWord', reason: 'how-question' },
  // how-he, when the
  { match: "[#QuestionWord] (#Pronoun|#Determiner)", group: 0, tag: "Preposition", reason: "how-he" },
  // when stolen
  { match: "[#QuestionWord] #Participle", group: 0, tag: "Preposition", reason: "when-stolen" },
  // how is
  { match: "[how] (#Determiner|#Copula|#Modal|#PastTense)", group: 0, tag: "QuestionWord", reason: "how-is" },
  // children who dance
  { match: "#Plural [(who|which|when)] .", group: 0, tag: "Preposition", reason: "people-who" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/expressions.js
var expressions_default = [
  //swear-words as non-expression POS
  { match: "holy (shit|fuck|hell)", tag: "Expression", reason: "swears-expression" },
  // well..
  { match: "^[(well|so|okay|now)] !#Adjective?", group: 0, tag: "Expression", reason: "well-" },
  // well..
  { match: "^come on", tag: "Expression", reason: "come-on" },
  // sorry
  { match: "(say|says|said) [sorry]", group: 0, tag: "Expression", reason: "say-sorry" },
  // ok,
  { match: "^(ok|alright|shoot|hell|anyways)", tag: "Expression", reason: "ok-" },
  // c'mon marge..
  // { match: '^[come on] #Noun', group: 0, tag: 'Expression', reason: 'come-on' },
  // say,
  { match: "^(say && @hasComma)", tag: "Expression", reason: "say-" },
  { match: "^(like && @hasComma)", tag: "Expression", reason: "like-" },
  // dude we should
  { match: "^[(dude|man|girl)] #Pronoun", group: 0, tag: "Expression", reason: "dude-i" }
];

// ../../node_modules/compromise/src/2-two/postTagger/model/index.js
var matches2 = [].concat(
  // order matters top-matches can get overwritten
  passive_default,
  adjective_default,
  adj_adverb_default,
  adj_gerund_default2,
  adj_noun_default2,
  adverb_default,
  date_default,
  date_phrase_default,
  nouns_default4,
  noun_gerund_default2,
  verb_noun_default,
  money_default,
  fractions_default,
  numbers_default,
  person_phrase_default,
  ambig_name_default,
  verbs_default3,
  adj_verb_default,
  auxiliary_default,
  phrasal_default,
  imperative_default2,
  adj_gerund_default3,
  misc_default4,
  organizations_default2,
  places_default2,
  conjunctions_default,
  expressions_default
);
var model_default4 = {
  two: {
    matches: matches2
  }
};

// ../../node_modules/compromise/src/2-two/postTagger/compute/index.js
var net = null;
var postTagger = function(view) {
  const { world: world2 } = view;
  const { model: model5, methods: methods18 } = world2;
  net = net || methods18.one.buildNet(model5.two.matches, world2);
  let document = methods18.two.quickSplit(view.document);
  let ptrs = document.map((terms) => {
    let t3 = terms[0];
    return [t3.index[0], t3.index[1], t3.index[1] + terms.length];
  });
  let m3 = view.update(ptrs);
  m3.cache();
  m3.sweep(net);
  view.uncache();
  return view;
};
var tagger2 = (view) => view.compute(["lexicon", "preTagger", "postTagger"]);
var compute_default10 = { postTagger, tagger: tagger2 };

// ../../node_modules/compromise/src/2-two/postTagger/api.js
var round = (n3) => Math.round(n3 * 100) / 100;
function api_default11(View2) {
  View2.prototype.confidence = function() {
    let sum = 0;
    let count = 0;
    this.docs.forEach((terms) => {
      terms.forEach((term) => {
        count += 1;
        sum += term.confidence || 1;
      });
    });
    if (count === 0) {
      return 1;
    }
    return round(sum / count);
  };
  View2.prototype.tagger = function() {
    return this.compute(["tagger"]);
  };
}

// ../../node_modules/compromise/src/2-two/postTagger/plugin.js
var plugin2 = {
  api: api_default11,
  compute: compute_default10,
  model: model_default4,
  hooks: ["postTagger"]
};
var plugin_default15 = plugin2;

// ../../node_modules/compromise/src/2-two/lazy/maybeMatch.js
var getWords = function(net3) {
  return Object.keys(net3.hooks).filter((w) => !w.startsWith("#") && !w.startsWith("%"));
};
var maybeMatch = function(doc, net3) {
  let words = getWords(net3);
  if (words.length === 0) {
    return doc;
  }
  if (!doc._cache) {
    doc.cache();
  }
  let cache2 = doc._cache;
  return doc.filter((_m, i3) => {
    return words.some((str) => cache2[i3].has(str));
  });
};
var maybeMatch_default = maybeMatch;

// ../../node_modules/compromise/src/2-two/lazy/lazyParse.js
var lazyParse = function(input, reg) {
  let net3 = reg;
  if (typeof reg === "string") {
    net3 = this.buildNet([{ match: reg }]);
  }
  let doc = this.tokenize(input);
  let m3 = maybeMatch_default(doc, net3);
  if (m3.found) {
    m3.compute(["index", "tagger"]);
    return m3.match(reg);
  }
  return doc.none();
};
var lazyParse_default = lazyParse;

// ../../node_modules/compromise/src/2-two/lazy/plugin.js
var plugin_default16 = {
  lib: {
    lazy: lazyParse_default
  }
};

// ../../node_modules/compromise/src/2-two/swap/api/swap-verb.js
var matchVerb = function(m3, lemma) {
  const conjugate2 = m3.methods.two.transform.verb.conjugate;
  let all4 = conjugate2(lemma, m3.model);
  if (m3.has("#Gerund")) {
    return all4.Gerund;
  }
  if (m3.has("#PastTense")) {
    return all4.PastTense;
  }
  if (m3.has("#PresentTense")) {
    return all4.PresentTense;
  }
  if (m3.has("#Gerund")) {
    return all4.Gerund;
  }
  return lemma;
};
var swapVerb = function(vb3, lemma) {
  let str = lemma;
  vb3.forEach((m3) => {
    if (!m3.has("#Infinitive")) {
      str = matchVerb(m3, lemma);
    }
    m3.replaceWith(str);
  });
  return vb3;
};
var swap_verb_default = swapVerb;

// ../../node_modules/compromise/src/2-two/swap/api/swap.js
var swapNoun = function(m3, lemma) {
  let str = lemma;
  if (m3.has("#Plural")) {
    const toPlural = m3.methods.two.transform.noun.toPlural;
    str = toPlural(lemma, m3.model);
  }
  m3.replaceWith(str, { possessives: true });
};
var swapAdverb = function(m3, lemma) {
  const { toAdverb: toAdverb2 } = m3.methods.two.transform.adjective;
  let str = lemma;
  let adv = toAdverb2(str);
  if (adv) {
    m3.replaceWith(adv);
  }
};
var swapAdjective = function(m3, lemma) {
  const { toComparative: toComparative3, toSuperlative: toSuperlative3 } = m3.methods.two.transform.adjective;
  let str = lemma;
  if (m3.has("#Comparative")) {
    str = toComparative3(str, m3.model);
  } else if (m3.has("#Superlative")) {
    str = toSuperlative3(str, m3.model);
  }
  if (str) {
    m3.replaceWith(str);
  }
};
var swap = function(from, to, tag) {
  let reg = from.split(/ /g).map((str) => str.toLowerCase().trim());
  reg = reg.filter((str) => str);
  reg = reg.map((str) => `{${str}}`).join(" ");
  let m3 = this.match(reg);
  if (tag) {
    m3 = m3.if(tag);
  }
  if (m3.has("#Verb")) {
    return swap_verb_default(m3, to);
  }
  if (m3.has("#Noun")) {
    return swapNoun(m3, to);
  }
  if (m3.has("#Adverb")) {
    return swapAdverb(m3, to);
  }
  if (m3.has("#Adjective")) {
    return swapAdjective(m3, to);
  }
  return this;
};
var swap_default = swap;

// ../../node_modules/compromise/src/2-two/swap/plugin.js
var api4 = function(View2) {
  View2.prototype.swap = swap_default;
};
var plugin_default17 = {
  api: api4
};

// ../../node_modules/compromise/src/two.js
one_default.plugin(plugin_default13);
one_default.plugin(plugin_default14);
one_default.plugin(plugin_default15);
one_default.plugin(plugin_default16);
one_default.plugin(plugin_default17);
var two_default = one_default;

// ../../node_modules/compromise/src/3-three/adjectives/plugin.js
var toRoot2 = function(adj) {
  const { fromComparative: fromComparative3, fromSuperlative: fromSuperlative3 } = adj.methods.two.transform.adjective;
  let str = adj.text("normal");
  if (adj.has("#Comparative")) {
    return fromComparative3(str, adj.model);
  }
  if (adj.has("#Superlative")) {
    return fromSuperlative3(str, adj.model);
  }
  return str;
};
var api5 = function(View2) {
  class Adjectives extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Adjectives";
    }
    json(opts2 = {}) {
      const { toAdverb: toAdverb2, toNoun: toNoun2, toSuperlative: toSuperlative3, toComparative: toComparative3 } = this.methods.two.transform.adjective;
      opts2.normal = true;
      return this.map((m3) => {
        let json = m3.toView().json(opts2)[0] || {};
        let str = toRoot2(m3);
        json.adjective = {
          adverb: toAdverb2(str, this.model),
          noun: toNoun2(str, this.model),
          superlative: toSuperlative3(str, this.model),
          comparative: toComparative3(str, this.model)
        };
        return json;
      }, []);
    }
    adverbs() {
      return this.before("#Adverb+$").concat(this.after("^#Adverb+"));
    }
    conjugate(n3) {
      const { toComparative: toComparative3, toSuperlative: toSuperlative3, toNoun: toNoun2, toAdverb: toAdverb2 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root = toRoot2(adj);
        return {
          Adjective: root,
          Comparative: toComparative3(root, this.model),
          Superlative: toSuperlative3(root, this.model),
          Noun: toNoun2(root, this.model),
          Adverb: toAdverb2(root, this.model)
        };
      }, []);
    }
    toComparative(n3) {
      const { toComparative: toComparative3 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root = toRoot2(adj);
        let str = toComparative3(root, this.model);
        return adj.replaceWith(str);
      });
    }
    toSuperlative(n3) {
      const { toSuperlative: toSuperlative3 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root = toRoot2(adj);
        let str = toSuperlative3(root, this.model);
        return adj.replaceWith(str);
      });
    }
    toAdverb(n3) {
      const { toAdverb: toAdverb2 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root = toRoot2(adj);
        let str = toAdverb2(root, this.model);
        return adj.replaceWith(str);
      });
    }
    toNoun(n3) {
      const { toNoun: toNoun2 } = this.methods.two.transform.adjective;
      return this.getNth(n3).map((adj) => {
        let root = toRoot2(adj);
        let str = toNoun2(root, this.model);
        return adj.replaceWith(str);
      });
    }
  }
  View2.prototype.adjectives = function(n3) {
    let m3 = this.match("#Adjective");
    m3 = m3.getNth(n3);
    return new Adjectives(m3.document, m3.pointer);
  };
  View2.prototype.superlatives = function(n3) {
    let m3 = this.match("#Superlative");
    m3 = m3.getNth(n3);
    return new Adjectives(m3.document, m3.pointer);
  };
  View2.prototype.comparatives = function(n3) {
    let m3 = this.match("#Comparative");
    m3 = m3.getNth(n3);
    return new Adjectives(m3.document, m3.pointer);
  };
};
var plugin_default18 = { api: api5 };

// ../../node_modules/compromise/src/3-three/adverbs/plugin.js
var toRoot3 = function(adj) {
  let str = adj.compute("root").text("root");
  return str;
};
var api6 = function(View2) {
  class Adverbs extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Adverbs";
    }
    conjugate(n3) {
      return this.getNth(n3).map((adv) => {
        let adj = toRoot3(adv);
        return {
          Adverb: adv.text("normal"),
          Adjective: adj
        };
      }, []);
    }
    json(opts2 = {}) {
      const fromAdverb = this.methods.two.transform.adjective.fromAdverb;
      opts2.normal = true;
      return this.map((m3) => {
        let json = m3.toView().json(opts2)[0] || {};
        json.adverb = {
          adjective: fromAdverb(json.normal)
        };
        return json;
      }, []);
    }
  }
  View2.prototype.adverbs = function(n3) {
    let m3 = this.match("#Adverb");
    m3 = m3.getNth(n3);
    return new Adverbs(m3.document, m3.pointer);
  };
};
var plugin_default19 = { api: api6 };

// ../../node_modules/compromise/src/3-three/chunker/api/clauses.js
var byComma = function(doc) {
  let commas = doc.match("@hasComma");
  commas = commas.filter((m3) => {
    if (m3.growLeft(".").wordCount() === 1) {
      return false;
    }
    if (m3.growRight(". .").wordCount() === 1) {
      return false;
    }
    let more = m3.grow(".");
    more = more.ifNo("@hasComma @hasComma");
    more = more.ifNo("@hasComma (and|or) .");
    more = more.ifNo("(#City && @hasComma) #Country");
    more = more.ifNo("(#WeekDay && @hasComma) #Date");
    more = more.ifNo("(#Date+ && @hasComma) #Value");
    more = more.ifNo("(#Adjective && @hasComma) #Adjective");
    return more.found;
  });
  return doc.splitAfter(commas);
};
var splitParentheses = function(doc) {
  let matches3 = doc.parentheses();
  matches3 = matches3.filter((m3) => {
    return m3.wordCount() >= 3 && m3.has("#Verb") && m3.has("#Noun");
  });
  return doc.splitOn(matches3);
};
var splitQuotes = function(doc) {
  let matches3 = doc.quotations();
  matches3 = matches3.filter((m3) => {
    return m3.wordCount() >= 3 && m3.has("#Verb") && m3.has("#Noun");
  });
  return doc.splitOn(matches3);
};
var clauses = function(n3) {
  let found = this;
  found = splitParentheses(found);
  found = splitQuotes(found);
  found = byComma(found);
  found = found.splitAfter("(@hasEllipses|@hasSemicolon|@hasDash|@hasColon)");
  found = found.splitAfter("^#Pronoun (said|says)");
  found = found.splitBefore("(said|says) #ProperNoun$");
  found = found.splitBefore(". . if .{4}");
  found = found.splitBefore("and while");
  found = found.splitBefore("now that");
  found = found.splitBefore("ever since");
  found = found.splitBefore("(supposing|although)");
  found = found.splitBefore("even (while|if|though)");
  found = found.splitBefore("(whereas|whose)");
  found = found.splitBefore("as (though|if)");
  found = found.splitBefore("(til|until)");
  if (typeof n3 === "number") {
    found = found.get(n3);
  }
  return found;
};
var clauses_default = clauses;

// ../../node_modules/compromise/src/3-three/chunker/api/chunks.js
var chunks = function(doc) {
  let all4 = [];
  let lastOne = null;
  let m3 = doc.clauses();
  m3.docs.forEach((terms) => {
    terms.forEach((term) => {
      if (!term.chunk || term.chunk !== lastOne) {
        lastOne = term.chunk;
        all4.push([term.index[0], term.index[1], term.index[1] + 1]);
      } else {
        all4[all4.length - 1][2] = term.index[1] + 1;
      }
    });
    lastOne = null;
  });
  let parts = doc.update(all4);
  return parts;
};
var chunks_default2 = chunks;

// ../../node_modules/compromise/src/3-three/chunker/api/api.js
var api7 = function(View2) {
  class Chunks extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Chunks";
    }
    isVerb() {
      return this.filter((c2) => c2.has("<Verb>"));
    }
    isNoun() {
      return this.filter((c2) => c2.has("<Noun>"));
    }
    isAdjective() {
      return this.filter((c2) => c2.has("<Adjective>"));
    }
    isPivot() {
      return this.filter((c2) => c2.has("<Pivot>"));
    }
    // chunk-friendly debug
    debug() {
      this.toView().debug("chunks");
      return this;
    }
    // overloaded - keep Sentences class
    update(pointer) {
      let m3 = new Chunks(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  View2.prototype.chunks = function(n3) {
    let m3 = chunks_default2(this);
    m3 = m3.getNth(n3);
    return new Chunks(this.document, m3.pointer);
  };
  View2.prototype.clauses = clauses_default;
};
var api_default12 = api7;

// ../../node_modules/compromise/src/3-three/chunker/compute/01-easy.js
var byWord2 = {
  this: "Noun",
  then: "Pivot"
};
var easyMode = function(document) {
  for (let n3 = 0; n3 < document.length; n3 += 1) {
    for (let t3 = 0; t3 < document[n3].length; t3 += 1) {
      let term = document[n3][t3];
      if (byWord2.hasOwnProperty(term.normal) === true) {
        term.chunk = byWord2[term.normal];
        continue;
      }
      if (term.tags.has("Verb")) {
        term.chunk = "Verb";
        continue;
      }
      if (term.tags.has("Noun") || term.tags.has("Determiner")) {
        term.chunk = "Noun";
        continue;
      }
      if (term.tags.has("Value")) {
        term.chunk = "Noun";
        continue;
      }
      if (term.tags.has("QuestionWord")) {
        term.chunk = "Pivot";
        continue;
      }
    }
  }
};
var easy_default = easyMode;

// ../../node_modules/compromise/src/3-three/chunker/compute/02-neighbours.js
var byNeighbour = function(document) {
  for (let n3 = 0; n3 < document.length; n3 += 1) {
    for (let t3 = 0; t3 < document[n3].length; t3 += 1) {
      let term = document[n3][t3];
      if (term.chunk) {
        continue;
      }
      let onRight = document[n3][t3 + 1];
      let onLeft = document[n3][t3 - 1];
      if (term.tags.has("Adjective")) {
        if (onLeft && onLeft.tags.has("Copula")) {
          term.chunk = "Adjective";
          continue;
        }
        if (onLeft && onLeft.tags.has("Determiner")) {
          term.chunk = "Noun";
          continue;
        }
        if (onRight && onRight.tags.has("Noun")) {
          term.chunk = "Noun";
          continue;
        }
        continue;
      }
      if (term.tags.has("Adverb") || term.tags.has("Negative")) {
        if (onLeft && onLeft.tags.has("Adjective")) {
          term.chunk = "Adjective";
          continue;
        }
        if (onLeft && onLeft.tags.has("Verb")) {
          term.chunk = "Verb";
          continue;
        }
        if (onRight && onRight.tags.has("Adjective")) {
          term.chunk = "Adjective";
          continue;
        }
        if (onRight && onRight.tags.has("Verb")) {
          term.chunk = "Verb";
          continue;
        }
      }
    }
  }
};
var neighbours_default3 = byNeighbour;

// ../../node_modules/compromise/src/3-three/chunker/compute/03-matcher.js
var rules = [
  // === Conjunction ===
  // that the houses
  { match: "[that] #Determiner #Noun", group: 0, chunk: "Pivot" },
  // estimated that
  { match: "#PastTense [that]", group: 0, chunk: "Pivot" },
  // so the
  { match: "[so] #Determiner", group: 0, chunk: "Pivot" },
  // === Adjective ===
  // was really nice
  { match: "#Copula #Adverb+? [#Adjective]", group: 0, chunk: "Adjective" },
  // was nice
  // { match: '#Copula [#Adjective]', group: 0, chunk: 'Adjective' },
  // nice and cool
  { match: "#Adjective and #Adjective", chunk: "Adjective" },
  // really nice
  // { match: '#Adverb+ #Adjective', chunk: 'Adjective' },
  // === Verb ===
  // quickly and suddenly run
  { match: "#Adverb+ and #Adverb #Verb", chunk: "Verb" },
  // sitting near
  { match: "#Gerund #Adjective$", chunk: "Verb" },
  // going to walk
  { match: "#Gerund to #Verb", chunk: "Verb" },
  // come and have a drink
  { match: "#PresentTense and #PresentTense", chunk: "Verb" },
  // really not
  { match: "#Adverb #Negative", chunk: "Verb" },
  // want to see
  { match: "(want|wants|wanted) to #Infinitive", chunk: "Verb" },
  // walk ourselves
  { match: "#Verb #Reflexive", chunk: "Verb" },
  // tell him the story
  // { match: '#PresentTense [#Pronoun] #Determiner', group: 0, chunk: 'Verb' },
  // tries to walk
  { match: "#Verb [to] #Adverb? #Infinitive", group: 0, chunk: "Verb" },
  // upon seeing
  { match: "[#Preposition] #Gerund", group: 0, chunk: "Verb" },
  // ensure that
  { match: "#Infinitive [that] <Noun>", group: 0, chunk: "Verb" },
  // === Noun ===
  // the brown fox
  // { match: '#Determiner #Adjective+ #Noun', chunk: 'Noun' },
  // the fox
  // { match: '(the|this) <Noun>', chunk: 'Noun' },
  // brown fox
  // { match: '#Adjective+ <Noun>', chunk: 'Noun' },
  // --- of ---
  // son of a gun
  { match: "#Noun of #Determiner? #Noun", chunk: "Noun" },
  // 3 beautiful women
  { match: "#Value+ #Adverb? #Adjective", chunk: "Noun" },
  // the last russian tsar
  { match: "the [#Adjective] #Noun", chunk: "Noun" },
  // breakfast in bed
  { match: "#Singular in #Determiner? #Singular", chunk: "Noun" },
  // Some citizens in this Canadian capital
  { match: "#Plural [in] #Determiner? #Noun", group: 0, chunk: "Pivot" },
  // indoor and outdoor seating
  { match: "#Noun and #Determiner? #Noun", notIf: "(#Possessive|#Pronoun)", chunk: "Noun" }
  //  boys and girls
  // { match: '#Plural and #Determiner? #Plural', chunk: 'Noun' },
  // tomatoes and cheese
  // { match: '#Noun and #Determiner? #Noun', notIf: '#Pronoun', chunk: 'Noun' },
  // that is why
  // { match: '[that] (is|was)', group: 0, chunk: 'Noun' },
];
var net2 = null;
var matcher = function(view, _2, world2) {
  const { methods: methods18 } = world2;
  net2 = net2 || methods18.one.buildNet(rules, world2);
  view.sweep(net2);
};
var matcher_default = matcher;

// ../../node_modules/compromise/src/3-three/chunker/compute/04-fallback.js
var setChunk = function(term, chunk) {
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2.DEBUG_CHUNKS) {
    let str = (term.normal + "'").padEnd(8);
    console.log(`  | '${str}  →  \x1B[34m${chunk.padEnd(12)}\x1B[0m \x1B[2m -fallback- \x1B[0m`);
  }
  term.chunk = chunk;
};
var fallback = function(document) {
  for (let n3 = 0; n3 < document.length; n3 += 1) {
    for (let t3 = 0; t3 < document[n3].length; t3 += 1) {
      let term = document[n3][t3];
      if (term.chunk === void 0) {
        if (term.tags.has("Conjunction")) {
          setChunk(term, "Pivot");
        } else if (term.tags.has("Preposition")) {
          setChunk(term, "Pivot");
        } else if (term.tags.has("Adverb")) {
          setChunk(term, "Verb");
        } else {
          term.chunk = "Noun";
        }
      }
    }
  }
};
var fallback_default2 = fallback;

// ../../node_modules/compromise/src/3-three/chunker/compute/05-fixUp.js
var fixUp = function(docs) {
  let byChunk = [];
  let current = null;
  docs.forEach((terms) => {
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let term = terms[i3];
      if (current && term.chunk === current) {
        byChunk[byChunk.length - 1].terms.push(term);
      } else {
        byChunk.push({ chunk: term.chunk, terms: [term] });
        current = term.chunk;
      }
    }
  });
  byChunk.forEach((c2) => {
    if (c2.chunk === "Verb") {
      const hasVerb = c2.terms.find((t3) => t3.tags.has("Verb"));
      if (!hasVerb) {
        c2.terms.forEach((t3) => t3.chunk = null);
      }
    }
  });
};
var fixUp_default = fixUp;

// ../../node_modules/compromise/src/3-three/chunker/compute/index.js
var findChunks = function(view) {
  const { document, world: world2 } = view;
  easy_default(document);
  neighbours_default3(document);
  matcher_default(view, document, world2);
  fallback_default2(document, world2);
  fixUp_default(document, world2);
};
var compute_default11 = { chunks: findChunks };

// ../../node_modules/compromise/src/3-three/chunker/plugin.js
var plugin_default20 = {
  compute: compute_default11,
  api: api_default12,
  hooks: ["chunks"]
};

// ../../node_modules/compromise/src/3-three/misc/acronyms/index.js
var hasPeriod = /\./g;
var api8 = function(View2) {
  class Acronyms extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Acronyms";
    }
    strip() {
      this.docs.forEach((terms) => {
        terms.forEach((term) => {
          term.text = term.text.replace(hasPeriod, "");
          term.normal = term.normal.replace(hasPeriod, "");
        });
      });
      return this;
    }
    addPeriods() {
      this.docs.forEach((terms) => {
        terms.forEach((term) => {
          term.text = term.text.replace(hasPeriod, "");
          term.normal = term.normal.replace(hasPeriod, "");
          term.text = term.text.split("").join(".") + ".";
          term.normal = term.normal.split("").join(".") + ".";
        });
      });
      return this;
    }
  }
  View2.prototype.acronyms = function(n3) {
    let m3 = this.match("#Acronym");
    m3 = m3.getNth(n3);
    return new Acronyms(m3.document, m3.pointer);
  };
};
var acronyms_default2 = api8;

// ../../node_modules/compromise/src/3-three/misc/parentheses/fns.js
var hasOpen2 = /\(/;
var hasClosed2 = /\)/;
var findEnd = function(terms, i3) {
  for (; i3 < terms.length; i3 += 1) {
    if (terms[i3].post && hasClosed2.test(terms[i3].post)) {
      return i3;
    }
  }
  return null;
};
var find2 = function(doc) {
  let ptrs = [];
  doc.docs.forEach((terms) => {
    let isOpen = false;
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let term = terms[i3];
      if (!isOpen && term.pre && hasOpen2.test(term.pre)) {
        let end2 = findEnd(terms, i3);
        if (end2 !== null) {
          let [n3, start2] = terms[i3].index;
          ptrs.push([n3, start2, end2 + 1, terms[i3].id]);
          i3 = end2;
        }
      }
    }
  });
  return doc.update(ptrs);
};
var strip = function(m3) {
  m3.docs.forEach((terms) => {
    terms[0].pre = terms[0].pre.replace(hasOpen2, "");
    let last = terms[terms.length - 1];
    last.post = last.post.replace(hasClosed2, "");
  });
  return m3;
};

// ../../node_modules/compromise/src/3-three/misc/parentheses/index.js
var api9 = function(View2) {
  class Parentheses extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Possessives";
    }
    strip() {
      return strip(this);
    }
  }
  View2.prototype.parentheses = function(n3) {
    let m3 = find2(this);
    m3 = m3.getNth(n3);
    return new Parentheses(m3.document, m3.pointer);
  };
};
var parentheses_default = api9;

// ../../node_modules/compromise/src/3-three/misc/possessives/index.js
var apostropheS2 = /'s$/;
var find3 = function(doc) {
  let m3 = doc.match("#Possessive+");
  if (m3.has("#Person")) {
    m3 = m3.growLeft("#Person+");
  }
  if (m3.has("#Place")) {
    m3 = m3.growLeft("#Place+");
  }
  if (m3.has("#Organization")) {
    m3 = m3.growLeft("#Organization+");
  }
  return m3;
};
var api10 = function(View2) {
  class Possessives extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Possessives";
    }
    strip() {
      this.docs.forEach((terms) => {
        terms.forEach((term) => {
          term.text = term.text.replace(apostropheS2, "");
          term.normal = term.normal.replace(apostropheS2, "");
        });
      });
      return this;
    }
  }
  View2.prototype.possessives = function(n3) {
    let m3 = find3(this);
    m3 = m3.getNth(n3);
    return new Possessives(m3.document, m3.pointer);
  };
};
var possessives_default = api10;

// ../../node_modules/compromise/src/3-three/misc/quotations/fns.js
var pairs2 = {
  '"': '"',
  // 'StraightDoubleQuotes'
  "＂": "＂",
  // 'StraightDoubleQuotesWide'
  "'": "'",
  // 'StraightSingleQuotes'
  "“": "”",
  // 'CommaDoubleQuotes'
  "‘": "’",
  // 'CommaSingleQuotes'
  "‟": "”",
  // 'CurlyDoubleQuotesReversed'
  "‛": "’",
  // 'CurlySingleQuotesReversed'
  "„": "”",
  // 'LowCurlyDoubleQuotes'
  "⹂": "”",
  // 'LowCurlyDoubleQuotesReversed'
  "‚": "’",
  // 'LowCurlySingleQuotes'
  "«": "»",
  // 'AngleDoubleQuotes' «, »
  "‹": "›",
  // 'AngleSingleQuotes'
  // Prime 'non quotation'
  "‵": "′",
  // 'PrimeSingleQuotes'
  "‶": "″",
  // 'PrimeDoubleQuotes'
  "‷": "‴",
  // 'PrimeTripleQuotes'
  // Prime 'quotation' variation
  "〝": "〞",
  // 'PrimeDoubleQuotes'
  "`": "´",
  // 'PrimeSingleQuotes'
  "〟": "〞"
  // 'LowPrimeDoubleQuotesReversed'
};
var hasOpen3 = RegExp("[" + Object.keys(pairs2).join("") + "]");
var hasClosed3 = RegExp("[" + Object.values(pairs2).join("") + "]");
var findEnd2 = function(terms, i3) {
  const have = terms[i3].pre.match(hasOpen3)[0] || "";
  if (!have || !pairs2[have]) {
    return null;
  }
  const want = pairs2[have];
  for (; i3 < terms.length; i3 += 1) {
    if (terms[i3].post && terms[i3].post.match(want)) {
      return i3;
    }
  }
  return null;
};
var find4 = function(doc) {
  let ptrs = [];
  doc.docs.forEach((terms) => {
    let isOpen = false;
    for (let i3 = 0; i3 < terms.length; i3 += 1) {
      let term = terms[i3];
      if (!isOpen && term.pre && hasOpen3.test(term.pre)) {
        let end2 = findEnd2(terms, i3);
        if (end2 !== null) {
          let [n3, start2] = terms[i3].index;
          ptrs.push([n3, start2, end2 + 1, terms[i3].id]);
          i3 = end2;
        }
      }
    }
  });
  return doc.update(ptrs);
};
var strip2 = function(m3) {
  m3.docs.forEach((terms) => {
    terms[0].pre = terms[0].pre.replace(hasOpen3, "");
    let lastTerm = terms[terms.length - 1];
    lastTerm.post = lastTerm.post.replace(hasClosed3, "");
  });
};

// ../../node_modules/compromise/src/3-three/misc/quotations/index.js
var api11 = function(View2) {
  class Quotations extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Possessives";
    }
    strip() {
      return strip2(this);
    }
  }
  View2.prototype.quotations = function(n3) {
    let m3 = find4(this);
    m3 = m3.getNth(n3);
    return new Quotations(m3.document, m3.pointer);
  };
};
var quotations_default = api11;

// ../../node_modules/compromise/src/3-three/misc/selections/index.js
var phoneNumbers = function(n3) {
  let m3 = this.splitAfter("@hasComma");
  m3 = m3.match("#PhoneNumber+");
  m3 = m3.getNth(n3);
  return m3;
};
var selections = [
  ["hyphenated", "@hasHyphen ."],
  ["hashTags", "#HashTag"],
  ["emails", "#Email"],
  ["emoji", "#Emoji"],
  ["emoticons", "#Emoticon"],
  ["atMentions", "#AtMention"],
  ["urls", "#Url"],
  // ['pronouns', '#Pronoun'],
  ["conjunctions", "#Conjunction"],
  ["prepositions", "#Preposition"],
  ["abbreviations", "#Abbreviation"],
  ["honorifics", "#Honorific"]
];
var aliases2 = [
  ["emojis", "emoji"],
  ["atmentions", "atMentions"]
];
var addMethods = function(View2) {
  selections.forEach((a2) => {
    View2.prototype[a2[0]] = function(n3) {
      let m3 = this.match(a2[1]);
      return typeof n3 === "number" ? m3.get(n3) : m3;
    };
  });
  View2.prototype.phoneNumbers = phoneNumbers;
  aliases2.forEach((a2) => {
    View2.prototype[a2[0]] = View2.prototype[a2[1]];
  });
};
var selections_default = addMethods;

// ../../node_modules/compromise/src/3-three/misc/plugin.js
var plugin_default21 = {
  api: function(View2) {
    acronyms_default2(View2);
    parentheses_default(View2);
    possessives_default(View2);
    quotations_default(View2);
    selections_default(View2);
  }
};

// ../../node_modules/compromise/src/3-three/normalize/methods.js
var termLoop2 = function(view, cb) {
  view.docs.forEach((terms) => {
    terms.forEach(cb);
  });
};
var methods_default11 = {
  // remove titlecasing, uppercase
  "case": (doc) => {
    termLoop2(doc, (term) => {
      term.text = term.text.toLowerCase();
    });
  },
  // visually romanize/anglicize 'Björk' into 'Bjork'.
  "unicode": (doc) => {
    const world2 = doc.world;
    const killUnicode2 = world2.methods.one.killUnicode;
    termLoop2(doc, (term) => term.text = killUnicode2(term.text, world2));
  },
  // remove hyphens, newlines, and force one space between words
  "whitespace": (doc) => {
    termLoop2(doc, (term) => {
      term.post = term.post.replace(/\s+/g, " ");
      term.post = term.post.replace(/\s([.,?!:;])/g, "$1");
      term.pre = term.pre.replace(/\s+/g, "");
    });
  },
  // remove commas, semicolons - but keep sentence-ending punctuation
  "punctuation": (doc) => {
    termLoop2(doc, (term) => {
      term.post = term.post.replace(/[–—-]/g, " ");
      term.post = term.post.replace(/[,:;]/g, "");
      term.post = term.post.replace(/\.{2,}/g, "");
      term.post = term.post.replace(/\?{2,}/g, "?");
      term.post = term.post.replace(/!{2,}/g, "!");
      term.post = term.post.replace(/\?!+/g, "?");
    });
    let docs = doc.docs;
    let terms = docs[docs.length - 1];
    if (terms && terms.length > 0) {
      let lastTerm = terms[terms.length - 1];
      lastTerm.post = lastTerm.post.replace(/ /g, "");
    }
  },
  // ====== subsets ===
  // turn "isn't" to "is not"
  "contractions": (doc) => {
    doc.contractions().expand();
  },
  //remove periods from acronyms, like 'F.B.I.'
  "acronyms": (doc) => {
    doc.acronyms().strip();
  },
  //remove words inside brackets (like these)
  "parentheses": (doc) => {
    doc.parentheses().strip();
  },
  // turn "Google's tax return" to "Google tax return"
  "possessives": (doc) => {
    doc.possessives().strip();
  },
  // turn "tax return" to tax return
  "quotations": (doc) => {
    doc.quotations().strip();
  },
  // remove them
  "emoji": (doc) => {
    doc.emojis().remove();
  },
  //turn 'Vice Admiral John Smith' to 'John Smith'
  "honorifics": (doc) => {
    doc.match("#Honorific+ #Person").honorifics().remove();
  },
  // remove needless adverbs
  "adverbs": (doc) => {
    doc.adverbs().remove();
  },
  // turn "batmobiles" into "batmobile"
  "nouns": (doc) => {
    doc.nouns().toSingular();
  },
  // turn all verbs into Infinitive form - "I walked" → "I walk"
  "verbs": (doc) => {
    doc.verbs().toInfinitive();
  },
  // turn "fifty" into "50"
  "numbers": (doc) => {
    doc.numbers().toNumber();
  },
  /** remove bullets from beginning of phrase */
  "debullet": (doc) => {
    const hasBullet = /^\s*([-–—*•])\s*$/;
    doc.docs.forEach((terms) => {
      if (hasBullet.test(terms[0].pre)) {
        terms[0].pre = terms[0].pre.replace(hasBullet, "");
      }
    });
    return doc;
  }
};

// ../../node_modules/compromise/src/3-three/normalize/api.js
var split2 = (str) => {
  return str.split("|").reduce((h2, k2) => {
    h2[k2] = true;
    return h2;
  }, {});
};
var light = "unicode|punctuation|whitespace|acronyms";
var medium = "|case|contractions|parentheses|quotations|emoji|honorifics|debullet";
var heavy = "|possessives|adverbs|nouns|verbs";
var presets = {
  light: split2(light),
  medium: split2(light + medium),
  heavy: split2(light + medium + heavy)
};
function api_default13(View2) {
  View2.prototype.normalize = function(opts2 = "light") {
    if (typeof opts2 === "string") {
      opts2 = presets[opts2];
    }
    Object.keys(opts2).forEach((fn) => {
      if (methods_default11.hasOwnProperty(fn)) {
        methods_default11[fn](this, opts2[fn]);
      }
    });
    return this;
  };
}

// ../../node_modules/compromise/src/3-three/normalize/plugin.js
var plugin_default22 = {
  api: api_default13
};

// ../../node_modules/compromise/src/3-three/nouns/find.js
var findNouns = function(doc) {
  let m3 = doc.clauses().match("<Noun>");
  let commas = m3.match("@hasComma");
  commas = commas.not("#Place");
  if (commas.found) {
    m3 = m3.splitAfter(commas);
  }
  m3 = m3.splitOn("#Expression");
  m3 = m3.splitOn("(he|she|we|you|they|i)");
  m3 = m3.splitOn("(#Noun|#Adjective) [(he|him|she|it)]", 0);
  m3 = m3.splitOn("[(he|him|she|it)] (#Determiner|#Value)", 0);
  m3 = m3.splitBefore("#Noun [(the|a|an)] #Adjective? #Noun", 0);
  m3 = m3.splitOn("[(here|there)] #Noun", 0);
  m3 = m3.splitOn("[#Noun] (here|there)", 0);
  m3 = m3.splitBefore("(our|my|their|your)");
  m3 = m3.splitOn("#Noun [#Determiner]", 0);
  m3 = m3.if("#Noun");
  return m3;
};
var find_default = findNouns;

// ../../node_modules/compromise/src/3-three/nouns/api/isSubordinate.js
var list2 = [
  "after",
  "although",
  "as if",
  "as long as",
  "as",
  "because",
  "before",
  "even if",
  "even though",
  "ever since",
  "if",
  "in order that",
  "provided that",
  "since",
  "so that",
  "than",
  "that",
  "though",
  "unless",
  "until",
  "what",
  "whatever",
  "when",
  "whenever",
  "where",
  "whereas",
  "wherever",
  "whether",
  "which",
  "whichever",
  "who",
  "whoever",
  "whom",
  "whomever",
  "whose"
];
var isSubordinate = function(m3) {
  if (m3.before("#Preposition$").found) {
    return true;
  }
  let leadIn = m3.before();
  if (!leadIn.found) {
    return false;
  }
  for (let i3 = 0; i3 < list2.length; i3 += 1) {
    if (m3.has(list2[i3])) {
      return true;
    }
  }
  return false;
};
var isSubordinate_default = isSubordinate;

// ../../node_modules/compromise/src/3-three/nouns/api/isPlural.js
var notPlural2 = "(#Pronoun|#Place|#Value|#Person|#Uncountable|#Month|#WeekDay|#Holiday|#Possessive)";
var isPlural2 = function(m3, root) {
  if (m3.has("#Plural")) {
    return true;
  }
  if (m3.has("#Noun and #Noun")) {
    return true;
  }
  if (m3.has("(we|they)")) {
    return true;
  }
  if (root.has(notPlural2) === true) {
    return false;
  }
  if (m3.has("#Singular")) {
    return false;
  }
  let str = root.text("normal");
  return str.length > 3 && str.endsWith("s") && !str.endsWith("ss");
};
var isPlural_default = isPlural2;

// ../../node_modules/compromise/src/3-three/nouns/api/parse.js
var getRoot2 = function(m3) {
  let tmp = m3.clone();
  tmp = tmp.match("#Noun+");
  tmp = tmp.remove("(#Adjective|#Preposition|#Determiner|#Value)");
  tmp = tmp.not("#Possessive");
  tmp = tmp.first();
  if (!tmp.found) {
    return m3;
  }
  return tmp;
};
var parseNoun = function(m3) {
  let root = getRoot2(m3);
  return {
    determiner: m3.match("#Determiner").eq(0),
    adjectives: m3.match("#Adjective"),
    number: m3.values(),
    isPlural: isPlural_default(m3, root),
    isSubordinate: isSubordinate_default(m3),
    root
  };
};
var parse_default3 = parseNoun;

// ../../node_modules/compromise/src/3-three/nouns/api/toJSON.js
var toText2 = (m3) => m3.text();
var toArray2 = (m3) => m3.json({ terms: false, normal: true }).map((s3) => s3.normal);
var getNum = function(m3) {
  let num = null;
  if (!m3.found) {
    return num;
  }
  let val = m3.values(0);
  if (val.found) {
    let obj = val.parse()[0] || {};
    return obj.num;
  }
  return num;
};
var toJSON2 = function(m3) {
  let res = parse_default3(m3);
  return {
    root: toText2(res.root),
    number: getNum(res.number),
    determiner: toText2(res.determiner),
    adjectives: toArray2(res.adjectives),
    isPlural: res.isPlural,
    isSubordinate: res.isSubordinate
  };
};
var toJSON_default = toJSON2;

// ../../node_modules/compromise/src/3-three/nouns/api/hasPlural.js
var hasPlural = function(root) {
  if (root.has("^(#Uncountable|#ProperNoun|#Place|#Pronoun|#Acronym)+$")) {
    return false;
  }
  return true;
};
var hasPlural_default = hasPlural;

// ../../node_modules/compromise/src/3-three/nouns/api/toPlural.js
var keep = { tags: true };
var nounToPlural = function(m3, parsed) {
  if (parsed.isPlural === true) {
    return m3;
  }
  if (parsed.root.has("#Possessive")) {
    parsed.root = parsed.root.possessives().strip();
  }
  if (!hasPlural_default(parsed.root)) {
    return m3;
  }
  const { methods: methods18, model: model5 } = m3.world;
  const { toPlural } = methods18.two.transform.noun;
  let str = parsed.root.text({ keepPunct: false });
  let plural2 = toPlural(str, model5);
  m3.match(parsed.root).replaceWith(plural2, keep).tag("Plural", "toPlural");
  if (parsed.determiner.has("(a|an)")) {
    m3.remove(parsed.determiner);
  }
  let copula = parsed.root.after("not? #Adverb+? [#Copula]", 0);
  if (copula.found) {
    if (copula.has("is")) {
      m3.replace(copula, "are");
    } else if (copula.has("was")) {
      m3.replace(copula, "were");
    }
  }
  return m3;
};
var toPlural_default2 = nounToPlural;

// ../../node_modules/compromise/src/3-three/nouns/api/toSingular.js
var keep2 = { tags: true };
var nounToSingular = function(m3, parsed) {
  if (parsed.isPlural === false) {
    return m3;
  }
  const { methods: methods18, model: model5 } = m3.world;
  const { toSingular: toSingular2 } = methods18.two.transform.noun;
  let str = parsed.root.text("normal");
  let single = toSingular2(str, model5);
  m3.replace(parsed.root, single, keep2).tag("Singular", "toPlural");
  return m3;
};
var toSingular_default2 = nounToSingular;

// ../../node_modules/compromise/src/3-three/nouns/api/api.js
var api12 = function(View2) {
  class Nouns extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Nouns";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default3);
    }
    json(n3) {
      let opts2 = typeof n3 === "object" ? n3 : {};
      return this.getNth(n3).map((m3) => {
        let json = m3.toView().json(opts2)[0] || {};
        if (opts2 && opts2.noun !== true) {
          json.noun = toJSON_default(m3);
        }
        return json;
      }, []);
    }
    conjugate(n3) {
      const methods18 = this.world.methods.two.transform.noun;
      return this.getNth(n3).map((m3) => {
        let parsed = parse_default3(m3);
        let root = parsed.root.compute("root").text("root");
        let res = {
          Singular: root
        };
        if (hasPlural_default(parsed.root)) {
          res.Plural = methods18.toPlural(root, this.model);
        }
        if (res.Singular === res.Plural) {
          delete res.Plural;
        }
        return res;
      }, []);
    }
    isPlural(n3) {
      let res = this.filter((m3) => parse_default3(m3).isPlural);
      return res.getNth(n3);
    }
    isSingular(n3) {
      let res = this.filter((m3) => !parse_default3(m3).isPlural);
      return res.getNth(n3);
    }
    adjectives(n3) {
      let res = this.update([]);
      this.forEach((m3) => {
        let adj = parse_default3(m3).adjectives;
        if (adj.found) {
          res = res.concat(adj);
        }
      });
      return res.getNth(n3);
    }
    toPlural(n3) {
      return this.getNth(n3).map((m3) => {
        return toPlural_default2(m3, parse_default3(m3));
      });
    }
    toSingular(n3) {
      return this.getNth(n3).map((m3) => {
        let res = parse_default3(m3);
        return toSingular_default2(m3, res);
      });
    }
    // create a new View, from this one
    update(pointer) {
      let m3 = new Nouns(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  View2.prototype.nouns = function(n3) {
    let m3 = find_default(this);
    m3 = m3.getNth(n3);
    return new Nouns(this.document, m3.pointer);
  };
};
var api_default14 = api12;

// ../../node_modules/compromise/src/3-three/nouns/plugin.js
var plugin_default23 = {
  api: api_default14
};

// ../../node_modules/compromise/src/3-three/numbers/fractions/find.js
var findFractions = function(doc, n3) {
  let m3 = doc.match("#Fraction+");
  m3 = m3.filter((r2) => {
    return !r2.lookBehind("#Value and$").found;
  });
  m3 = m3.notIf("#Value seconds");
  if (typeof n3 === "number") {
    m3 = m3.eq(n3);
  }
  return m3;
};
var find_default2 = findFractions;

// ../../node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/findModifiers.js
var findModifiers = (str) => {
  const mults = [
    {
      reg: /^(minus|negative)[\s-]/i,
      mult: -1
    },
    {
      reg: /^(a\s)?half[\s-](of\s)?/i,
      mult: 0.5
    }
    //  {
    //   reg: /^(a\s)?quarter[\s\-]/i,
    //   mult: 0.25
    // }
  ];
  for (let i3 = 0; i3 < mults.length; i3++) {
    if (mults[i3].reg.test(str) === true) {
      return {
        amount: mults[i3].mult,
        str: str.replace(mults[i3].reg, "")
      };
    }
  }
  return {
    amount: 1,
    str
  };
};
var findModifiers_default = findModifiers;

// ../../node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/data.js
var data_default3 = {
  ones: {
    zeroth: 0,
    first: 1,
    second: 2,
    third: 3,
    fourth: 4,
    fifth: 5,
    sixth: 6,
    seventh: 7,
    eighth: 8,
    ninth: 9,
    zero: 0,
    one: 1,
    two: 2,
    three: 3,
    four: 4,
    five: 5,
    six: 6,
    seven: 7,
    eight: 8,
    nine: 9
  },
  teens: {
    tenth: 10,
    eleventh: 11,
    twelfth: 12,
    thirteenth: 13,
    fourteenth: 14,
    fifteenth: 15,
    sixteenth: 16,
    seventeenth: 17,
    eighteenth: 18,
    nineteenth: 19,
    ten: 10,
    eleven: 11,
    twelve: 12,
    thirteen: 13,
    fourteen: 14,
    fifteen: 15,
    sixteen: 16,
    seventeen: 17,
    eighteen: 18,
    nineteen: 19
  },
  tens: {
    twentieth: 20,
    thirtieth: 30,
    fortieth: 40,
    fourtieth: 40,
    fiftieth: 50,
    sixtieth: 60,
    seventieth: 70,
    eightieth: 80,
    ninetieth: 90,
    twenty: 20,
    thirty: 30,
    forty: 40,
    fourty: 40,
    fifty: 50,
    sixty: 60,
    seventy: 70,
    eighty: 80,
    ninety: 90
  },
  multiples: {
    hundredth: 100,
    thousandth: 1e3,
    millionth: 1e6,
    billionth: 1e9,
    trillionth: 1e12,
    quadrillionth: 1e15,
    quintillionth: 1e18,
    sextillionth: 1e21,
    septillionth: 1e24,
    hundred: 100,
    thousand: 1e3,
    million: 1e6,
    billion: 1e9,
    trillion: 1e12,
    quadrillion: 1e15,
    quintillion: 1e18,
    sextillion: 1e21,
    septillion: 1e24,
    grand: 1e3
  }
};

// ../../node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/validate.js
var isValid = (w, has2) => {
  if (data_default3.ones.hasOwnProperty(w)) {
    if (has2.ones || has2.teens) {
      return false;
    }
  } else if (data_default3.teens.hasOwnProperty(w)) {
    if (has2.ones || has2.teens || has2.tens) {
      return false;
    }
  } else if (data_default3.tens.hasOwnProperty(w)) {
    if (has2.ones || has2.teens || has2.tens) {
      return false;
    }
  }
  return true;
};
var validate_default3 = isValid;

// ../../node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/parseDecimals.js
var parseDecimals = function(arr) {
  let str = "0.";
  for (let i3 = 0; i3 < arr.length; i3++) {
    let w = arr[i3];
    if (data_default3.ones.hasOwnProperty(w) === true) {
      str += data_default3.ones[w];
    } else if (data_default3.teens.hasOwnProperty(w) === true) {
      str += data_default3.teens[w];
    } else if (data_default3.tens.hasOwnProperty(w) === true) {
      str += data_default3.tens[w];
    } else if (/^[0-9]$/.test(w) === true) {
      str += w;
    } else {
      return 0;
    }
  }
  return parseFloat(str);
};
var parseDecimals_default = parseDecimals;

// ../../node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/parseNumeric.js
var parseNumeric = (str) => {
  str = str.replace(/1st$/, "1");
  str = str.replace(/2nd$/, "2");
  str = str.replace(/3rd$/, "3");
  str = str.replace(/([4567890])r?th$/, "$1");
  str = str.replace(/^[$€¥£¢]/, "");
  str = str.replace(/[%$€¥£¢]$/, "");
  str = str.replace(/,/g, "");
  str = str.replace(/([0-9])([a-z\u00C0-\u00FF]{1,2})$/, "$1");
  return str;
};
var parseNumeric_default = parseNumeric;

// ../../node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/index.js
var improperFraction = /^([0-9,. ]+)\/([0-9,. ]+)$/;
var casualForms = {
  "a few": 3,
  "a couple": 2,
  "a dozen": 12,
  "two dozen": 24,
  zero: 0
};
var section_sum = (obj) => {
  return Object.keys(obj).reduce((sum, k2) => {
    sum += obj[k2];
    return sum;
  }, 0);
};
var parse4 = function(str) {
  if (casualForms.hasOwnProperty(str) === true) {
    return casualForms[str];
  }
  if (str === "a" || str === "an") {
    return 1;
  }
  const modifier = findModifiers_default(str);
  str = modifier.str;
  let last_mult = null;
  let has2 = {};
  let sum = 0;
  let isNegative = false;
  const terms = str.split(/[ -]/);
  for (let i3 = 0; i3 < terms.length; i3++) {
    let w = terms[i3];
    w = parseNumeric_default(w);
    if (!w || w === "and") {
      continue;
    }
    if (w === "-" || w === "negative") {
      isNegative = true;
      continue;
    }
    if (w.charAt(0) === "-") {
      isNegative = true;
      w = w.substring(1);
    }
    if (w === "point") {
      sum += section_sum(has2);
      sum += parseDecimals_default(terms.slice(i3 + 1, terms.length));
      sum *= modifier.amount;
      return sum;
    }
    const fm = w.match(improperFraction);
    if (fm) {
      const num = parseFloat(fm[1].replace(/[, ]/g, ""));
      const denom = parseFloat(fm[2].replace(/[, ]/g, ""));
      if (denom) {
        sum += num / denom || 0;
      }
      continue;
    }
    if (data_default3.tens.hasOwnProperty(w)) {
      if (has2.ones && Object.keys(has2).length === 1) {
        sum = has2.ones * 100;
        has2 = {};
      }
    }
    if (validate_default3(w, has2) === false) {
      return null;
    }
    if (/^[0-9.]+$/.test(w)) {
      has2.ones = parseFloat(w);
    } else if (data_default3.ones.hasOwnProperty(w) === true) {
      has2.ones = data_default3.ones[w];
    } else if (data_default3.teens.hasOwnProperty(w) === true) {
      has2.teens = data_default3.teens[w];
    } else if (data_default3.tens.hasOwnProperty(w) === true) {
      has2.tens = data_default3.tens[w];
    } else if (data_default3.multiples.hasOwnProperty(w) === true) {
      let mult = data_default3.multiples[w];
      if (mult === last_mult) {
        return null;
      }
      if (mult === 100 && terms[i3 + 1] !== void 0) {
        const w2 = terms[i3 + 1];
        if (data_default3.multiples[w2]) {
          mult *= data_default3.multiples[w2];
          i3 += 1;
        }
      }
      if (last_mult === null || mult < last_mult) {
        sum += (section_sum(has2) || 1) * mult;
        last_mult = mult;
        has2 = {};
      } else {
        sum += section_sum(has2);
        last_mult = mult;
        sum = (sum || 1) * mult;
        has2 = {};
      }
    }
  }
  sum += section_sum(has2);
  sum *= modifier.amount;
  sum *= isNegative ? -1 : 1;
  if (sum === 0 && Object.keys(has2).length === 0) {
    return null;
  }
  return sum;
};
var toNumber_default = parse4;

// ../../node_modules/compromise/src/3-three/numbers/fractions/parse.js
var endS = /s$/;
var parseNumber = function(m3) {
  let str = m3.text("reduced");
  return toNumber_default(str);
};
var mapping2 = {
  half: 2,
  halve: 2,
  quarter: 4
};
var slashForm = function(m3) {
  let str = m3.text("reduced");
  let found = str.match(/^([-+]?[0-9]+)\/([-+]?[0-9]+)(st|nd|rd|th)?s?$/);
  if (found && found[1] && found[0]) {
    return {
      numerator: Number(found[1]),
      denominator: Number(found[2])
    };
  }
  return null;
};
var nOutOfN = function(m3) {
  let found = m3.match("[<num>#Value+] out of every? [<den>#Value+]");
  if (found.found !== true) {
    return null;
  }
  let { num, den } = found.groups();
  if (!num || !den) {
    return null;
  }
  num = parseNumber(num);
  den = parseNumber(den);
  if (!num || !den) {
    return null;
  }
  if (typeof num === "number" && typeof den === "number") {
    return {
      numerator: num,
      denominator: den
    };
  }
  return null;
};
var nOrinalth = function(m3) {
  let found = m3.match("[<num>(#Cardinal|a)+] [<den>#Fraction+]");
  if (found.found !== true) {
    return null;
  }
  let { num, den } = found.groups();
  if (num.has("a")) {
    num = 1;
  } else {
    num = parseNumber(num);
  }
  let str = den.text("reduced");
  if (endS.test(str)) {
    str = str.replace(endS, "");
    den = den.replaceWith(str);
  }
  if (mapping2.hasOwnProperty(str)) {
    den = mapping2[str];
  } else {
    den = parseNumber(den);
  }
  if (typeof num === "number" && typeof den === "number") {
    return {
      numerator: num,
      denominator: den
    };
  }
  return null;
};
var oneNth = function(m3) {
  let found = m3.match("^#Ordinal$");
  if (found.found !== true) {
    return null;
  }
  if (m3.lookAhead("^of .")) {
    let num = parseNumber(found);
    return {
      numerator: 1,
      denominator: num
    };
  }
  return null;
};
var named = function(m3) {
  let str = m3.text("reduced");
  if (mapping2.hasOwnProperty(str)) {
    return { numerator: 1, denominator: mapping2[str] };
  }
  return null;
};
var round2 = (n3) => {
  let rounded = Math.round(n3 * 1e3) / 1e3;
  if (rounded === 0 && n3 !== 0) {
    return n3;
  }
  return rounded;
};
var parseFraction = function(m3) {
  m3 = m3.clone();
  let res = named(m3) || slashForm(m3) || nOutOfN(m3) || nOrinalth(m3) || oneNth(m3) || null;
  if (res !== null) {
    if (res.numerator && res.denominator) {
      res.decimal = res.numerator / res.denominator;
      res.decimal = round2(res.decimal);
    }
  }
  return res;
};
var parse_default4 = parseFraction;

// ../../node_modules/compromise/src/3-three/numbers/numbers/_toString.js
var numToString = function(n3) {
  if (n3 < 1e6) {
    return String(n3);
  }
  let str;
  if (typeof n3 === "number") {
    str = n3.toFixed(0);
  } else {
    str = n3;
  }
  if (str.indexOf("e+") === -1) {
    return str;
  }
  return str.replace(".", "").split("e+").reduce(function(p5, b) {
    return p5 + Array(b - p5.length + 2).join(0);
  });
};
var toString_default = numToString;

// ../../node_modules/compromise/src/3-three/numbers/numbers/format/toText/data.js
var tens_mapping = [
  ["ninety", 90],
  ["eighty", 80],
  ["seventy", 70],
  ["sixty", 60],
  ["fifty", 50],
  ["forty", 40],
  ["thirty", 30],
  ["twenty", 20]
];
var ones_mapping = [
  "",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "eleven",
  "twelve",
  "thirteen",
  "fourteen",
  "fifteen",
  "sixteen",
  "seventeen",
  "eighteen",
  "nineteen"
];
var sequence = [
  [1e24, "septillion"],
  [1e20, "hundred sextillion"],
  [1e21, "sextillion"],
  [1e20, "hundred quintillion"],
  [1e18, "quintillion"],
  [1e17, "hundred quadrillion"],
  [1e15, "quadrillion"],
  [1e14, "hundred trillion"],
  [1e12, "trillion"],
  [1e11, "hundred billion"],
  [1e9, "billion"],
  [1e8, "hundred million"],
  [1e6, "million"],
  [1e5, "hundred thousand"],
  [1e3, "thousand"],
  [100, "hundred"],
  [1, "one"]
];

// ../../node_modules/compromise/src/3-three/numbers/numbers/format/toText/index.js
var breakdown_magnitudes = function(num) {
  let working = num;
  let have = [];
  sequence.forEach((a2) => {
    if (num >= a2[0]) {
      let howmany = Math.floor(working / a2[0]);
      working -= howmany * a2[0];
      if (howmany) {
        have.push({
          unit: a2[1],
          count: howmany
        });
      }
    }
  });
  return have;
};
var breakdown_hundred = function(num) {
  let arr = [];
  if (num > 100) {
    return arr;
  }
  for (let i3 = 0; i3 < tens_mapping.length; i3++) {
    if (num >= tens_mapping[i3][1]) {
      num -= tens_mapping[i3][1];
      arr.push(tens_mapping[i3][0]);
    }
  }
  if (ones_mapping[num]) {
    arr.push(ones_mapping[num]);
  }
  return arr;
};
var handle_decimal = (num) => {
  const names = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
  let arr = [];
  let str = toString_default(num);
  let decimal = str.match(/\.([0-9]+)/);
  if (!decimal || !decimal[0]) {
    return arr;
  }
  arr.push("point");
  let decimals = decimal[0].split("");
  for (let i3 = 0; i3 < decimals.length; i3++) {
    arr.push(names[decimals[i3]]);
  }
  return arr;
};
var toText3 = function(obj) {
  let num = obj.num;
  if (num === 0 || num === "0") {
    return "zero";
  }
  if (num > 1e21) {
    num = toString_default(num);
  }
  let arr = [];
  if (num < 0) {
    arr.push("minus");
    num = Math.abs(num);
  }
  let units = breakdown_magnitudes(num);
  for (let i3 = 0; i3 < units.length; i3++) {
    let unit_name = units[i3].unit;
    if (unit_name === "one") {
      unit_name = "";
      if (arr.length > 1) {
        arr.push("and");
      }
    }
    arr = arr.concat(breakdown_hundred(units[i3].count));
    arr.push(unit_name);
  }
  arr = arr.concat(handle_decimal(num));
  arr = arr.filter((s3) => s3);
  if (arr.length === 0) {
    arr[0] = "";
  }
  return arr.join(" ");
};
var toText_default = toText3;

// ../../node_modules/compromise/src/3-three/numbers/fractions/convert/toCardinal.js
var toCardinal = function(obj) {
  if (!obj.numerator || !obj.denominator) {
    return "";
  }
  let a2 = toText_default({ num: obj.numerator });
  let b = toText_default({ num: obj.denominator });
  return `${a2} out of ${b}`;
};
var toCardinal_default = toCardinal;

// ../../node_modules/compromise/src/3-three/numbers/numbers/format/toOrdinal/textOrdinal.js
var irregulars = {
  one: "first",
  two: "second",
  three: "third",
  five: "fifth",
  eight: "eighth",
  nine: "ninth",
  twelve: "twelfth",
  twenty: "twentieth",
  thirty: "thirtieth",
  forty: "fortieth",
  fourty: "fourtieth",
  fifty: "fiftieth",
  sixty: "sixtieth",
  seventy: "seventieth",
  eighty: "eightieth",
  ninety: "ninetieth"
};
var textOrdinal = (obj) => {
  let words = toText_default(obj).split(" ");
  let last = words[words.length - 1];
  if (irregulars.hasOwnProperty(last)) {
    words[words.length - 1] = irregulars[last];
  } else {
    words[words.length - 1] = last.replace(/y$/, "i") + "th";
  }
  return words.join(" ");
};
var textOrdinal_default = textOrdinal;

// ../../node_modules/compromise/src/3-three/numbers/fractions/convert/toOrdinal.js
var toOrdinal = function(obj) {
  if (!obj.numerator || !obj.denominator) {
    return "";
  }
  let start2 = toText_default({ num: obj.numerator });
  let end2 = textOrdinal_default({ num: obj.denominator });
  if (obj.denominator === 2) {
    end2 = "half";
  }
  if (start2 && end2) {
    if (obj.numerator !== 1) {
      end2 += "s";
    }
    return `${start2} ${end2}`;
  }
  return "";
};
var toOrdinal_default = toOrdinal;

// ../../node_modules/compromise/src/3-three/numbers/fractions/api.js
var plugin3 = function(View2) {
  class Fractions extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Fractions";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default4);
    }
    get(n3) {
      return this.getNth(n3).map(parse_default4);
    }
    json(n3) {
      return this.getNth(n3).map((p5) => {
        let json = p5.toView().json(n3)[0];
        let parsed = parse_default4(p5);
        json.fraction = parsed;
        return json;
      }, []);
    }
    // become 0.5
    toDecimal(n3) {
      this.getNth(n3).forEach((m3) => {
        let { decimal } = parse_default4(m3);
        m3 = m3.replaceWith(String(decimal), true);
        m3.tag("NumericValue");
        m3.unTag("Fraction");
      });
      return this;
    }
    toFraction(n3) {
      this.getNth(n3).forEach((m3) => {
        let obj = parse_default4(m3);
        if (obj && typeof obj.numerator === "number" && typeof obj.denominator === "number") {
          let str = `${obj.numerator}/${obj.denominator}`;
          this.replace(m3, str);
        }
      });
      return this;
    }
    toOrdinal(n3) {
      this.getNth(n3).forEach((m3) => {
        let obj = parse_default4(m3);
        let str = toOrdinal_default(obj);
        if (m3.after("^#Noun").found) {
          str += " of";
        }
        m3.replaceWith(str);
      });
      return this;
    }
    toCardinal(n3) {
      this.getNth(n3).forEach((m3) => {
        let obj = parse_default4(m3);
        let str = toCardinal_default(obj);
        m3.replaceWith(str);
      });
      return this;
    }
    toPercentage(n3) {
      this.getNth(n3).forEach((m3) => {
        let { decimal } = parse_default4(m3);
        let percent = decimal * 100;
        percent = Math.round(percent * 100) / 100;
        m3.replaceWith(`${percent}%`);
      });
      return this;
    }
  }
  View2.prototype.fractions = function(n3) {
    let m3 = find_default2(this);
    m3 = m3.getNth(n3);
    return new Fractions(this.document, m3.pointer);
  };
};
var api_default15 = plugin3;

// ../../node_modules/compromise/src/3-three/numbers/numbers/find.js
var ones = "one|two|three|four|five|six|seven|eight|nine";
var tens = "twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|fourty";
var teens = "eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen";
var findNumbers = function(doc) {
  let m3 = doc.match("#Value+");
  if (m3.has("#NumericValue #NumericValue")) {
    if (m3.has("#Value @hasComma #Value")) {
      m3.splitAfter("@hasComma");
    } else if (m3.has("#NumericValue #Fraction")) {
      m3.splitAfter("#NumericValue #Fraction");
    } else {
      m3 = m3.splitAfter("#NumericValue");
    }
  }
  if (m3.has("#Value #Value #Value") && !m3.has("#Multiple")) {
    if (m3.has("(" + tens + ") #Cardinal #Cardinal")) {
      m3 = m3.splitAfter("(" + tens + ") #Cardinal");
    }
  }
  if (m3.has("#Value #Value")) {
    if (m3.has("#NumericValue #NumericValue")) {
      m3 = m3.splitOn("#Year");
    }
    if (m3.has("(" + tens + ") (" + teens + ")")) {
      m3 = m3.splitAfter("(" + tens + ")");
    }
    let double = m3.match("#Cardinal #Cardinal");
    if (double.found && !m3.has("(point|decimal|#Fraction)")) {
      if (!double.has("#Cardinal (#Multiple|point|decimal)")) {
        let noMultiple = m3.has(`(${ones}) (${tens})`);
        let tensVal = double.has("(" + tens + ") #Cardinal");
        let multVal = double.has("#Multiple #Value");
        if (!noMultiple && !tensVal && !multVal) {
          double.terms().forEach((d2) => {
            m3 = m3.splitOn(d2);
          });
        }
      }
    }
    if (m3.match("#Ordinal #Ordinal").match("#TextValue").found && !m3.has("#Multiple")) {
      if (!m3.has("(" + tens + ") #Ordinal")) {
        m3 = m3.splitAfter("#Ordinal");
      }
    }
    m3 = m3.splitBefore("#Ordinal [#Cardinal]", 0);
    if (m3.has("#TextValue #NumericValue") && !m3.has("(" + tens + "|#Multiple)")) {
      m3 = m3.splitBefore("#TextValue #NumericValue");
    }
  }
  m3 = m3.splitAfter("#NumberRange");
  m3 = m3.splitBefore("#Year");
  return m3;
};
var find_default3 = findNumbers;

// ../../node_modules/compromise/src/3-three/numbers/numbers/parse/index.js
var parseNumeric2 = function(str, m3) {
  str = str.replace(/,/g, "");
  let arr = str.split(/([0-9.,]*)/);
  let [prefix5, num] = arr;
  let suffix = arr.slice(2).join("");
  if (num !== "" && m3.length < 2) {
    num = Number(num || str);
    if (typeof num !== "number") {
      num = null;
    }
    suffix = suffix || "";
    if (suffix === "st" || suffix === "nd" || suffix === "rd" || suffix === "th") {
      suffix = "";
    }
    return {
      prefix: prefix5 || "",
      num,
      suffix
    };
  }
  return null;
};
var parseNumber2 = function(m3) {
  if (typeof m3 === "string") {
    return { num: toNumber_default(m3) };
  }
  let str = m3.text("reduced");
  let unit = m3.growRight("#Unit").match("#Unit$").text("machine");
  let hasComma = /[0-9],[0-9]/.test(m3.text("text"));
  if (m3.terms().length === 1 && !m3.has("#Multiple")) {
    let res = parseNumeric2(str, m3);
    if (res !== null) {
      res.hasComma = hasComma;
      res.unit = unit;
      return res;
    }
  }
  let frPart = m3.match("#Fraction{2,}$");
  frPart = frPart.found === false ? m3.match("^#Fraction$") : frPart;
  let fraction = null;
  if (frPart.found) {
    if (frPart.has("#Value and #Value #Fraction")) {
      frPart = frPart.match("and #Value #Fraction");
    }
    fraction = parse_default4(frPart);
    m3 = m3.not(frPart);
    m3 = m3.not("and$");
    str = m3.text("reduced");
  }
  let num = 0;
  if (str) {
    num = toNumber_default(str) || 0;
  }
  if (fraction && fraction.decimal) {
    num += fraction.decimal;
  }
  return {
    hasComma,
    prefix: "",
    num,
    suffix: "",
    isOrdinal: m3.has("#Ordinal"),
    isText: m3.has("#TextValue"),
    isFraction: m3.has("#Fraction"),
    isMoney: m3.has("#Money"),
    unit
  };
};
var parse_default5 = parseNumber2;

// ../../node_modules/compromise/src/3-three/numbers/numbers/format/toOrdinal/numOrdinal.js
var numOrdinal = function(obj) {
  let num = obj.num;
  if (!num && num !== 0) {
    return null;
  }
  let tens2 = num % 100;
  if (tens2 > 10 && tens2 < 20) {
    return String(num) + "th";
  }
  const mapping3 = {
    0: "th",
    1: "st",
    2: "nd",
    3: "rd"
  };
  let str = toString_default(num);
  let last = str.slice(str.length - 1, str.length);
  if (mapping3[last]) {
    str += mapping3[last];
  } else {
    str += "th";
  }
  return str;
};
var numOrdinal_default = numOrdinal;

// ../../node_modules/compromise/src/3-three/numbers/numbers/format/suffix.js
var prefixes = {
  "¢": "cents",
  $: "dollars",
  "£": "pounds",
  "¥": "yen",
  "€": "euros",
  "₡": "colón",
  "฿": "baht",
  "₭": "kip",
  "₩": "won",
  "₹": "rupees",
  "₽": "ruble",
  "₺": "liras"
};
var suffixes4 = {
  "%": "percent",
  // s: 'seconds',
  // cm: 'centimetres',
  // km: 'kilometres',
  // ft: 'feet',
  "°": "degrees"
};
var addSuffix = function(obj) {
  let res = {
    suffix: "",
    prefix: obj.prefix
  };
  if (prefixes.hasOwnProperty(obj.prefix)) {
    res.suffix += " " + prefixes[obj.prefix];
    res.prefix = "";
  }
  if (suffixes4.hasOwnProperty(obj.suffix)) {
    res.suffix += " " + suffixes4[obj.suffix];
  }
  if (res.suffix && obj.num === 1) {
    res.suffix = res.suffix.replace(/s$/, "");
  }
  if (!res.suffix && obj.suffix) {
    res.suffix += " " + obj.suffix;
  }
  return res;
};
var suffix_default2 = addSuffix;

// ../../node_modules/compromise/src/3-three/numbers/numbers/format/index.js
var format = function(obj, fmt2) {
  if (fmt2 === "TextOrdinal") {
    let { prefix: prefix5, suffix } = suffix_default2(obj);
    return prefix5 + textOrdinal_default(obj) + suffix;
  }
  if (fmt2 === "Ordinal") {
    return obj.prefix + numOrdinal_default(obj) + obj.suffix;
  }
  if (fmt2 === "TextCardinal") {
    let { prefix: prefix5, suffix } = suffix_default2(obj);
    return prefix5 + toText_default(obj) + suffix;
  }
  let num = obj.num;
  if (obj.hasComma) {
    num = num.toLocaleString();
  }
  return obj.prefix + String(num) + obj.suffix;
};
var format_default = format;

// ../../node_modules/compromise/src/3-three/numbers/numbers/api.js
var addMethod = function(View2) {
  class Numbers extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Numbers";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default5);
    }
    get(n3) {
      return this.getNth(n3).map(parse_default5).map((o2) => o2.num);
    }
    json(n3) {
      let opts2 = typeof n3 === "object" ? n3 : {};
      return this.getNth(n3).map((p5) => {
        let json = p5.toView().json(opts2)[0];
        let parsed = parse_default5(p5);
        json.number = {
          prefix: parsed.prefix,
          num: parsed.num,
          suffix: parsed.suffix,
          hasComma: parsed.hasComma,
          unit: parsed.unit
        };
        return json;
      }, []);
    }
    /** any known measurement unit, for the number */
    units() {
      return this.growRight("#Unit").match("#Unit$");
    }
    /** return only ordinal numbers */
    isOrdinal() {
      return this.if("#Ordinal");
    }
    /** return only cardinal numbers*/
    isCardinal() {
      return this.if("#Cardinal");
    }
    /** convert to numeric form like '8' or '8th' */
    toNumber() {
      let m3 = this.if("#TextValue");
      m3.forEach((val) => {
        let obj = parse_default5(val);
        if (obj.num === null) {
          return;
        }
        let fmt2 = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("NumericValue");
      });
      return this;
    }
    /** add commas, or nicer formatting for numbers */
    toLocaleString() {
      let m3 = this;
      m3.forEach((val) => {
        let obj = parse_default5(val);
        if (obj.num === null) {
          return;
        }
        let num = obj.num.toLocaleString();
        if (val.has("#Ordinal")) {
          let str = format_default(obj, "Ordinal");
          let end2 = str.match(/[a-z]+$/);
          if (end2) {
            num += end2[0] || "";
          }
        }
        val.replaceWith(num, { tags: true });
      });
      return this;
    }
    /** convert to numeric form like 'eight' or 'eighth' */
    toText() {
      let m3 = this;
      let res = m3.map((val) => {
        if (val.has("#TextValue")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("TextValue");
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    /** convert ordinal to cardinal form, like 'eight', or '8' */
    toCardinal() {
      let m3 = this;
      let res = m3.map((val) => {
        if (!val.has("#Ordinal")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#TextValue") ? "TextCardinal" : "Cardinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("Cardinal");
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    /** convert cardinal to ordinal form, like 'eighth', or '8th' */
    toOrdinal() {
      let m3 = this;
      let res = m3.map((val) => {
        if (val.has("#Ordinal")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#TextValue") ? "TextOrdinal" : "Ordinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("Ordinal");
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    /** return only numbers that are == n */
    isEqual(n3) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num === n3;
      });
    }
    /** return only numbers that are > n*/
    greaterThan(n3) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num > n3;
      });
    }
    /** return only numbers that are < n*/
    lessThan(n3) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num < n3;
      });
    }
    /** return only numbers > min and < max */
    between(min2, max3) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num > min2 && num < max3;
      });
    }
    /** set these number to n */
    set(n3) {
      if (n3 === void 0) {
        return this;
      }
      if (typeof n3 === "string") {
        n3 = parse_default5(n3).num;
      }
      let m3 = this;
      let res = m3.map((val) => {
        let obj = parse_default5(val);
        obj.num = n3;
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
        if (val.has("#TextValue")) {
          fmt2 = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
        }
        let str = format_default(obj, fmt2);
        if (obj.hasComma && fmt2 === "Cardinal") {
          str = Number(str).toLocaleString();
        }
        val = val.not("#Currency");
        val.replaceWith(str, { tags: true });
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    add(n3) {
      if (!n3) {
        return this;
      }
      if (typeof n3 === "string") {
        n3 = parse_default5(n3).num;
      }
      let m3 = this;
      let res = m3.map((val) => {
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        obj.num += n3;
        let fmt2 = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
        if (obj.isText) {
          fmt2 = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
        }
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    /** decrease each number by n*/
    subtract(n3, agree) {
      return this.add(n3 * -1, agree);
    }
    /** increase each number by 1 */
    increment(agree) {
      return this.add(1, agree);
    }
    /** decrease each number by 1 */
    decrement(agree) {
      return this.add(-1, agree);
    }
    // overloaded - keep Numbers class
    update(pointer) {
      let m3 = new Numbers(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  Numbers.prototype.toNice = Numbers.prototype.toLocaleString;
  Numbers.prototype.isBetween = Numbers.prototype.between;
  Numbers.prototype.minus = Numbers.prototype.subtract;
  Numbers.prototype.plus = Numbers.prototype.add;
  Numbers.prototype.equals = Numbers.prototype.isEqual;
  View2.prototype.numbers = function(n3) {
    let m3 = find_default3(this);
    m3 = m3.getNth(n3);
    return new Numbers(this.document, m3.pointer);
  };
  View2.prototype.percentages = function(n3) {
    let m3 = find_default3(this);
    m3 = m3.filter((v2) => v2.has("#Percent") || v2.after("^percent"));
    m3 = m3.getNth(n3);
    return new Numbers(this.document, m3.pointer);
  };
  View2.prototype.money = function(n3) {
    let m3 = find_default3(this);
    m3 = m3.filter((v2) => v2.has("#Money") || v2.after("^#Currency"));
    m3 = m3.getNth(n3);
    return new Numbers(this.document, m3.pointer);
  };
  View2.prototype.values = View2.prototype.numbers;
};
var api_default16 = addMethod;

// ../../node_modules/compromise/src/3-three/numbers/plugin.js
var api13 = function(View2) {
  api_default15(View2);
  api_default16(View2);
};
var plugin_default24 = {
  api: api13
};

// ../../node_modules/compromise/src/3-three/redact/plugin.js
var defaults3 = {
  people: true,
  emails: true,
  phoneNumbers: true,
  places: true
};
var redact = function(opts2 = {}) {
  opts2 = Object.assign({}, defaults3, opts2);
  if (opts2.people !== false) {
    this.people().replaceWith("██████████");
  }
  if (opts2.emails !== false) {
    this.emails().replaceWith("██████████");
  }
  if (opts2.places !== false) {
    this.places().replaceWith("██████████");
  }
  if (opts2.phoneNumbers !== false) {
    this.phoneNumbers().replaceWith("███████");
  }
  return this;
};
var plugin4 = {
  api: function(View2) {
    View2.prototype.redact = redact;
  }
};
var plugin_default25 = plugin4;

// ../../node_modules/compromise/src/3-three/sentences/questions.js
var isQuestion = function(doc) {
  let clauses2 = doc.clauses();
  if (/\.\.$/.test(doc.out("text"))) {
    return false;
  }
  if (doc.has("^#QuestionWord") && doc.has("@hasComma")) {
    return false;
  }
  if (doc.has("or not$")) {
    return true;
  }
  if (doc.has("^#QuestionWord")) {
    return true;
  }
  if (doc.has("^(do|does|did|is|was|can|could|will|would|may) #Noun")) {
    return true;
  }
  if (doc.has("^(have|must) you")) {
    return true;
  }
  if (clauses2.has("(do|does|is|was) #Noun+ #Adverb? (#Adjective|#Infinitive)$")) {
    return true;
  }
  return false;
};
var findQuestions = function(view) {
  const hasQ = /\?/;
  const { document } = view;
  return view.filter((m3) => {
    let terms = m3.docs[0] || [];
    let lastTerm = terms[terms.length - 1];
    if (!lastTerm || document[lastTerm.index[0]].length !== terms.length) {
      return false;
    }
    if (hasQ.test(lastTerm.post)) {
      return true;
    }
    return isQuestion(m3);
  });
};
var questions_default = findQuestions;

// ../../node_modules/compromise/src/3-three/sentences/parse/mainClause.js
var subordinate = `(after|although|as|because|before|if|since|than|that|though|when|whenever|where|whereas|wherever|whether|while|why|unless|until|once)`;
var relative = `(that|which|whichever|who|whoever|whom|whose|whomever)`;
var mainClause = function(s3) {
  let m3 = s3;
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.if("#Verb");
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.ifNo(subordinate);
  m3 = m3.ifNo("^even (if|though)");
  m3 = m3.ifNo("^so that");
  m3 = m3.ifNo("^rather than");
  m3 = m3.ifNo("^provided that");
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.ifNo(relative);
  if (m3.length === 1) {
    return m3;
  }
  m3 = m3.ifNo("(despite|during|before|through|throughout)");
  if (m3.length === 1) {
    return m3;
  }
  if (m3.length === 0) {
    m3 = s3;
  }
  return m3.eq(0);
};
var mainClause_default = mainClause;

// ../../node_modules/compromise/src/3-three/sentences/parse/index.js
var grammar = function(vb3) {
  let tense = null;
  if (vb3.has("#PastTense")) {
    tense = "PastTense";
  } else if (vb3.has("#FutureTense")) {
    tense = "FutureTense";
  } else if (vb3.has("#PresentTense")) {
    tense = "PresentTense";
  }
  return {
    tense
  };
};
var parse5 = function(s3) {
  let clauses2 = s3.clauses();
  let main = mainClause_default(clauses2);
  let chunks2 = main.chunks();
  let subj = s3.none();
  let verb = s3.none();
  let pred = s3.none();
  chunks2.forEach((ch, i3) => {
    if (i3 === 0 && !ch.has("<Verb>")) {
      subj = ch;
      return;
    }
    if (!verb.found && ch.has("<Verb>")) {
      verb = ch;
      return;
    }
    if (verb.found) {
      pred = pred.concat(ch);
    }
  });
  if (verb.found && !subj.found) {
    subj = verb.before("<Noun>+").first();
  }
  return {
    subj,
    verb,
    pred,
    grammar: grammar(verb)
  };
};
var parse_default6 = parse5;

// ../../node_modules/compromise/src/3-three/sentences/conjugate/toPast.js
var toPast2 = function(s3) {
  let verbs = s3.verbs();
  let first = verbs.eq(0);
  if (first.has("#PastTense")) {
    return s3;
  }
  first.toPastTense();
  if (verbs.length > 1) {
    verbs = verbs.slice(1);
    verbs = verbs.filter((v2) => !v2.lookBehind("to$").found);
    verbs = verbs.if("#PresentTense");
    verbs = verbs.notIf("#Gerund");
    let list4 = s3.match("to #Verb+ #Conjunction #Verb").terms();
    verbs = verbs.not(list4);
    if (verbs.found) {
      verbs.verbs().toPastTense();
    }
  }
  return s3;
};
var toPast_default = toPast2;

// ../../node_modules/compromise/src/3-three/sentences/conjugate/toPresent.js
var toPresent2 = function(s3) {
  let verbs = s3.verbs();
  let first = verbs.eq(0);
  first.toPresentTense();
  if (verbs.length > 1) {
    verbs = verbs.slice(1);
    verbs = verbs.filter((v2) => !v2.lookBehind("to$").found);
    verbs = verbs.notIf("#Gerund");
    if (verbs.found) {
      verbs.verbs().toPresentTense();
    }
  }
  return s3;
};
var toPresent_default = toPresent2;

// ../../node_modules/compromise/src/3-three/sentences/conjugate/toFuture.js
var toFuture = function(s3) {
  let verbs = s3.verbs();
  let first = verbs.eq(0);
  first.toFutureTense();
  s3 = s3.fullSentence();
  verbs = s3.verbs();
  if (verbs.length > 1) {
    verbs = verbs.slice(1);
    let toChange = verbs.filter((vb3) => {
      if (vb3.lookBehind("to$").found) {
        return false;
      }
      if (vb3.has("#Copula #Gerund")) {
        return true;
      }
      if (vb3.has("#Gerund")) {
        return false;
      }
      if (vb3.has("#Copula")) {
        return true;
      }
      if (vb3.has("#PresentTense") && !vb3.has("#Infinitive") && vb3.lookBefore("(he|she|it|that|which)$").found) {
        return false;
      }
      return true;
    });
    if (toChange.found) {
      toChange.forEach((m3) => {
        if (m3.has("#Copula")) {
          m3.match("was").replaceWith("is");
          m3.match("is").replaceWith("will be");
          return;
        }
        m3.toInfinitive();
      });
    }
  }
  return s3;
};
var toFuture_default = toFuture;

// ../../node_modules/compromise/src/3-three/sentences/conjugate/toNegative.js
var toNegative = function(s3) {
  s3.verbs().first().toNegative().compute("chunks");
  return s3;
};
var toPositive = function(s3) {
  s3.verbs().first().toPositive().compute("chunks");
  return s3;
};

// ../../node_modules/compromise/src/3-three/sentences/conjugate/toInfinitive.js
var toInfinitive2 = function(s3) {
  s3.verbs().toInfinitive();
  return s3;
};
var toInfinitive_default2 = toInfinitive2;

// ../../node_modules/compromise/src/3-three/sentences/api.js
var api14 = function(View2) {
  class Sentences extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Sentences";
    }
    json(opts2 = {}) {
      return this.map((m3) => {
        let json = m3.toView().json(opts2)[0] || {};
        let { subj, verb, pred, grammar: grammar2 } = parse_default6(m3);
        json.sentence = {
          subject: subj.text("normal"),
          verb: verb.text("normal"),
          predicate: pred.text("normal"),
          grammar: grammar2
        };
        return json;
      }, []);
    }
    toPastTense(n3) {
      return this.getNth(n3).map((s3) => {
        let parsed = parse_default6(s3);
        return toPast_default(s3, parsed);
      });
    }
    toPresentTense(n3) {
      return this.getNth(n3).map((s3) => {
        let parsed = parse_default6(s3);
        return toPresent_default(s3, parsed);
      });
    }
    toFutureTense(n3) {
      return this.getNth(n3).map((s3) => {
        let parsed = parse_default6(s3);
        s3 = toFuture_default(s3, parsed);
        return s3;
      });
    }
    toInfinitive(n3) {
      return this.getNth(n3).map((s3) => {
        let parsed = parse_default6(s3);
        return toInfinitive_default2(s3, parsed);
      });
    }
    toNegative(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default6(vb3);
        return toNegative(vb3, parsed);
      });
    }
    toPositive(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default6(vb3);
        return toPositive(vb3, parsed);
      });
    }
    isQuestion(n3) {
      return this.questions(n3);
    }
    isExclamation(n3) {
      let res = this.filter((s3) => s3.lastTerm().has("@hasExclamation"));
      return res.getNth(n3);
    }
    isStatement(n3) {
      let res = this.filter((s3) => !s3.isExclamation().found && !s3.isQuestion().found);
      return res.getNth(n3);
    }
    // overloaded - keep Sentences class
    update(pointer) {
      let m3 = new Sentences(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  Sentences.prototype.toPresent = Sentences.prototype.toPresentTense;
  Sentences.prototype.toPast = Sentences.prototype.toPastTense;
  Sentences.prototype.toFuture = Sentences.prototype.toFutureTense;
  const methods18 = {
    sentences: function(n3) {
      let m3 = this.map((s3) => s3.fullSentence());
      m3 = m3.getNth(n3);
      return new Sentences(this.document, m3.pointer);
    },
    questions: function(n3) {
      let m3 = questions_default(this);
      return m3.getNth(n3);
    }
  };
  Object.assign(View2.prototype, methods18);
};
var api_default17 = api14;

// ../../node_modules/compromise/src/3-three/sentences/plugin.js
var plugin_default26 = { api: api_default17 };

// ../../node_modules/compromise/src/3-three/topics/people/find.js
var find5 = function(doc) {
  let m3 = doc.match("#Honorific+? #Person+");
  return m3;
};
var find_default4 = find5;

// ../../node_modules/compromise/src/3-three/topics/people/parse.js
var parse6 = function(m3) {
  let res = {};
  res.firstName = m3.match("#FirstName+");
  res.lastName = m3.match("#LastName+");
  res.honorific = m3.match("#Honorific+");
  let last = res.lastName;
  let first = res.firstName;
  if (!first.found || !last.found) {
    if (!first.found && !last.found && m3.has("^#Honorific .$")) {
      res.lastName = m3.match(".$");
      return res;
    }
  }
  return res;
};
var parse_default7 = parse6;

// ../../node_modules/compromise/src/3-three/topics/people/gender.js
var m2 = "male";
var f2 = "female";
var honorifics = {
  mr: m2,
  mrs: f2,
  miss: f2,
  madam: f2,
  // british stuff
  king: m2,
  queen: f2,
  duke: m2,
  duchess: f2,
  baron: m2,
  baroness: f2,
  count: m2,
  countess: f2,
  prince: m2,
  princess: f2,
  sire: m2,
  dame: f2,
  lady: f2,
  ayatullah: m2,
  //i think?
  congressman: m2,
  congresswoman: f2,
  "first lady": f2,
  // marked as non-binary
  mx: null
};
var predictGender = function(parsed, person) {
  let { firstName, honorific } = parsed;
  if (firstName.has("#FemaleName")) {
    return f2;
  }
  if (firstName.has("#MaleName")) {
    return m2;
  }
  if (honorific.found) {
    let hon = honorific.text("normal");
    hon = hon.replace(/\./g, "");
    if (honorifics.hasOwnProperty(hon)) {
      return honorifics[hon];
    }
    if (/^her /.test(hon)) {
      return f2;
    }
    if (/^his /.test(hon)) {
      return m2;
    }
  }
  let after2 = person.after();
  if (!after2.has("#Person") && after2.has("#Pronoun")) {
    let pro = after2.match("#Pronoun");
    if (pro.has("(they|their)")) {
      return null;
    }
    let hasMasc = pro.has("(he|his)");
    let hasFem = pro.has("(she|her|hers)");
    if (hasMasc && !hasFem) {
      return m2;
    }
    if (hasFem && !hasMasc) {
      return f2;
    }
  }
  return null;
};
var gender_default = predictGender;

// ../../node_modules/compromise/src/3-three/topics/people/api.js
var addMethod2 = function(View2) {
  class People extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "People";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default7);
    }
    json(n3) {
      let opts2 = typeof n3 === "object" ? n3 : {};
      return this.getNth(n3).map((p5) => {
        let json = p5.toView().json(opts2)[0];
        let parsed = parse_default7(p5);
        json.person = {
          firstName: parsed.firstName.text("normal"),
          lastName: parsed.lastName.text("normal"),
          honorific: parsed.honorific.text("normal"),
          presumed_gender: gender_default(parsed, p5)
        };
        return json;
      }, []);
    }
    // used for co-reference resolution only
    presumedMale() {
      return this.filter((m3) => {
        return m3.has("(#MaleName|mr|mister|sr|jr|king|pope|prince|sir)");
      });
    }
    presumedFemale() {
      return this.filter((m3) => {
        return m3.has("(#FemaleName|mrs|miss|queen|princess|madam)");
      });
    }
    // overloaded - keep People class
    update(pointer) {
      let m3 = new People(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  View2.prototype.people = function(n3) {
    let m3 = find_default4(this);
    m3 = m3.getNth(n3);
    return new People(this.document, m3.pointer);
  };
};
var api_default18 = addMethod2;

// ../../node_modules/compromise/src/3-three/topics/places/find.js
var find6 = function(doc) {
  let m3 = doc.match("(#Place|#Address)+");
  let splits = m3.match("@hasComma");
  splits = splits.filter((c2) => {
    if (c2.has("(asia|africa|europe|america)$")) {
      return true;
    }
    if (c2.has("(#City|#Region|#ProperNoun)$") && c2.after("^(#Country|#Region)").found) {
      return false;
    }
    return true;
  });
  m3 = m3.splitAfter(splits);
  return m3;
};
var find_default5 = find6;

// ../../node_modules/compromise/src/3-three/topics/places/api.js
var addMethod3 = function(View2) {
  View2.prototype.places = function(n3) {
    let m3 = find_default5(this);
    m3 = m3.getNth(n3);
    return new View2(this.document, m3.pointer);
  };
};
var api_default19 = addMethod3;

// ../../node_modules/compromise/src/3-three/topics/orgs/api.js
var api15 = function(View2) {
  View2.prototype.organizations = function(n3) {
    let m3 = this.match("#Organization+");
    return m3.getNth(n3);
  };
};
var api_default20 = api15;

// ../../node_modules/compromise/src/3-three/topics/topics.js
var find7 = function(n3) {
  let r2 = this.clauses();
  let m3 = r2.people();
  m3 = m3.concat(r2.places());
  m3 = m3.concat(r2.organizations());
  m3 = m3.not("(someone|man|woman|mother|brother|sister|father)");
  m3 = m3.sort("seq");
  m3 = m3.getNth(n3);
  return m3;
};
var api16 = function(View2) {
  View2.prototype.topics = find7;
};
var topics_default = api16;

// ../../node_modules/compromise/src/3-three/topics/plugin.js
var api17 = function(View2) {
  api_default18(View2);
  api_default19(View2);
  api_default20(View2);
  topics_default(View2);
};
var plugin_default27 = { api: api17 };

// ../../node_modules/compromise/src/3-three/verbs/find.js
var findVerbs = function(doc) {
  let m3 = doc.match("<Verb>");
  m3 = m3.not("#Conjunction");
  m3 = m3.not("#Preposition");
  m3 = m3.splitAfter("@hasComma");
  m3 = m3.splitAfter("[(do|did|am|was|is|will)] (is|was)", 0);
  m3 = m3.splitBefore("(#Verb && !#Copula) [being] #Verb", 0);
  m3 = m3.splitBefore("#Verb [to be] #Verb", 0);
  m3 = m3.splitAfter("[help] #PresentTense", 0);
  m3 = m3.splitBefore("(#PresentTense|#PastTense) [#Copula]$", 0);
  m3 = m3.splitBefore("(#PresentTense|#PastTense) [will be]$", 0);
  m3 = m3.splitBefore("(#PresentTense|#PastTense) [(had|has)]", 0);
  m3 = m3.not("#Reflexive$");
  m3 = m3.not("#Adjective");
  m3 = m3.splitAfter("[#PastTense] #PastTense", 0);
  m3 = m3.splitAfter("[#PastTense] #Auxiliary+ #PastTense", 0);
  m3 = m3.splitAfter("#Copula [#Gerund] #PastTense", 0);
  m3 = m3.if("#Verb");
  if (m3.has("(#Verb && !#Auxiliary) #Adverb+? #Copula")) {
    m3 = m3.splitBefore("#Copula");
  }
  return m3;
};
var find_default6 = findVerbs;

// ../../node_modules/compromise/src/3-three/verbs/api/parse/root.js
var getMain = function(vb3) {
  let root = vb3;
  if (vb3.wordCount() > 1) {
    root = vb3.not("(#Negative|#Auxiliary|#Modal|#Adverb|#Prefix)");
  }
  if (root.length > 1 && !root.has("#Phrasal #Particle")) {
    root = root.last();
  }
  root = root.not("(want|wants|wanted) to");
  if (!root.found) {
    root = vb3.not("#Negative");
    return root;
  }
  return root;
};
var root_default2 = getMain;

// ../../node_modules/compromise/src/3-three/verbs/api/parse/adverbs.js
var getAdverbs = function(vb3, root) {
  let res = {
    pre: vb3.none(),
    post: vb3.none()
  };
  if (!vb3.has("#Adverb")) {
    return res;
  }
  let parts = vb3.splitOn(root);
  if (parts.length === 3) {
    return {
      pre: parts.eq(0).adverbs(),
      post: parts.eq(2).adverbs()
    };
  }
  if (parts.eq(0).isDoc(root)) {
    res.post = parts.eq(1).adverbs();
    return res;
  }
  res.pre = parts.eq(0).adverbs();
  return res;
};
var adverbs_default = getAdverbs;

// ../../node_modules/compromise/src/3-three/verbs/api/parse/index.js
var getAuxiliary = function(vb3, root) {
  let parts = vb3.splitBefore(root);
  if (parts.length <= 1) {
    return vb3.none();
  }
  let aux = parts.eq(0);
  aux = aux.not("(#Adverb|#Negative|#Prefix)");
  return aux;
};
var getNegative = function(vb3) {
  return vb3.match("#Negative");
};
var getPhrasal = function(root) {
  if (!root.has("(#Particle|#PhrasalVerb)")) {
    return {
      verb: root.none(),
      particle: root.none()
    };
  }
  let particle = root.match("#Particle$");
  return {
    verb: root.not(particle),
    particle
  };
};
var parseVerb = function(view) {
  let vb3 = view.clone();
  vb3.contractions().expand();
  const root = root_default2(vb3);
  let res = {
    root,
    prefix: vb3.match("#Prefix"),
    adverbs: adverbs_default(vb3, root),
    auxiliary: getAuxiliary(vb3, root),
    negative: getNegative(vb3),
    phrasal: getPhrasal(root)
  };
  return res;
};
var parse_default8 = parseVerb;

// ../../node_modules/compromise/src/3-three/verbs/api/parse/grammar/forms.js
var present = { tense: "PresentTense" };
var conditional = { conditional: true };
var future = { tense: "FutureTense" };
var prog = { progressive: true };
var past2 = { tense: "PastTense" };
var complete = { complete: true, progressive: false };
var passive = { passive: true };
var plural = { plural: true };
var singular = { plural: false };
var getData = function(tags) {
  let data = {};
  tags.forEach((o2) => {
    Object.assign(data, o2);
  });
  return data;
};
var verbForms = {
  // === Simple ===
  "imperative": [
    // walk!
    ["#Imperative", []]
  ],
  "want-infinitive": [
    ["^(want|wants|wanted) to #Infinitive$", [present]],
    ["^wanted to #Infinitive$", [past2]],
    ["^will want to #Infinitive$", [future]]
  ],
  "gerund-phrase": [
    // started looking
    ["^#PastTense #Gerund$", [past2]],
    // starts looking
    ["^#PresentTense #Gerund$", [present]],
    // start looking
    ["^#Infinitive #Gerund$", [present]],
    // will start looking
    ["^will #Infinitive #Gerund$", [future]],
    // have started looking
    ["^have #PastTense #Gerund$", [past2]],
    // will have started looking
    ["^will have #PastTense #Gerund$", [past2]]
  ],
  "simple-present": [
    // he walks',
    ["^#PresentTense$", [present]],
    // we walk
    ["^#Infinitive$", [present]]
  ],
  "simple-past": [
    // he walked',
    ["^#PastTense$", [past2]]
  ],
  "simple-future": [
    // he will walk
    ["^will #Adverb? #Infinitive", [future]]
  ],
  // === Progressive ===
  "present-progressive": [
    // he is walking
    ["^(is|are|am) #Gerund$", [present, prog]]
  ],
  "past-progressive": [
    // he was walking
    ["^(was|were) #Gerund$", [past2, prog]]
  ],
  "future-progressive": [
    // he will be
    ["^will be #Gerund$", [future, prog]]
  ],
  // === Perfect ===
  "present-perfect": [
    // he has walked
    ["^(has|have) #PastTense$", [past2, complete]]
    //past?
  ],
  "past-perfect": [
    // he had walked
    ["^had #PastTense$", [past2, complete]],
    // had been to see
    ["^had #PastTense to #Infinitive", [past2, complete]]
  ],
  "future-perfect": [
    // he will have
    ["^will have #PastTense$", [future, complete]]
  ],
  // === Progressive-perfect ===
  "present-perfect-progressive": [
    // he has been walking
    ["^(has|have) been #Gerund$", [past2, prog]]
    //present?
  ],
  "past-perfect-progressive": [
    // he had been
    ["^had been #Gerund$", [past2, prog]]
  ],
  "future-perfect-progressive": [
    // will have been
    ["^will have been #Gerund$", [future, prog]]
  ],
  // ==== Passive ===
  "passive-past": [
    // got walked, was walked, were walked
    ["(got|were|was) #Passive", [past2, passive]],
    // was being walked
    ["^(was|were) being #Passive", [past2, passive]],
    // had been walked, have been eaten
    ["^(had|have) been #Passive", [past2, passive]]
  ],
  "passive-present": [
    // is walked, are stolen
    ["^(is|are|am) #Passive", [present, passive]],
    // is being walked
    ["^(is|are|am) being #Passive", [present, passive]],
    // has been cleaned
    ["^has been #Passive", [present, passive]]
  ],
  "passive-future": [
    // will have been walked
    ["will have been #Passive", [future, passive, conditional]],
    // will be cleaned
    ["will be being? #Passive", [future, passive, conditional]]
  ],
  // === Conditional ===
  "present-conditional": [
    // would be walked
    ["would be #PastTense", [present, conditional]]
  ],
  "past-conditional": [
    // would have been walked
    ["would have been #PastTense", [past2, conditional]]
  ],
  // ==== Auxiliary ===
  "auxiliary-future": [
    // going to drink
    ["(is|are|am|was) going to (#Infinitive|#PresentTense)", [future]]
  ],
  "auxiliary-past": [
    // he did walk
    ["^did #Infinitive$", [past2, singular]],
    // used to walk
    ["^used to #Infinitive$", [past2, complete]]
  ],
  "auxiliary-present": [
    // we do walk
    ["^(does|do) #Infinitive$", [present, complete, plural]]
  ],
  // === modals ===
  "modal-past": [
    // he could have walked
    ["^(could|must|should|shall) have #PastTense$", [past2]]
  ],
  "modal-infinitive": [
    // he can walk
    ["^#Modal #Infinitive$", []]
  ],
  "infinitive": [
    // walk
    ["^#Infinitive$", []]
  ]
};
var list3 = [];
Object.keys(verbForms).map((k2) => {
  verbForms[k2].forEach((a2) => {
    list3.push({
      name: k2,
      match: a2[0],
      data: getData(a2[1])
    });
  });
});
var forms_default = list3;

// ../../node_modules/compromise/src/3-three/verbs/api/parse/grammar/index.js
var cleanUp2 = function(vb3, res) {
  vb3 = vb3.clone();
  if (res.adverbs.post && res.adverbs.post.found) {
    vb3.remove(res.adverbs.post);
  }
  if (res.adverbs.pre && res.adverbs.pre.found) {
    vb3.remove(res.adverbs.pre);
  }
  if (vb3.has("#Negative")) {
    vb3 = vb3.remove("#Negative");
  }
  if (vb3.has("#Prefix")) {
    vb3 = vb3.remove("#Prefix");
  }
  if (res.root.has("#PhrasalVerb #Particle")) {
    vb3.remove("#Particle$");
  }
  vb3 = vb3.not("#Adverb");
  return vb3;
};
var isInfinitive = function(vb3) {
  if (vb3.has("#Infinitive")) {
    let m3 = vb3.growLeft("to");
    if (m3.has("^to #Infinitive")) {
      return true;
    }
  }
  return false;
};
var getGrammar = function(vb3, res) {
  let grammar2 = {};
  vb3 = cleanUp2(vb3, res);
  for (let i3 = 0; i3 < forms_default.length; i3 += 1) {
    let todo = forms_default[i3];
    if (vb3.has(todo.match) === true) {
      grammar2.form = todo.name;
      Object.assign(grammar2, todo.data);
      break;
    }
  }
  if (!grammar2.form) {
    if (vb3.has("^#Verb$")) {
      grammar2.form = "infinitive";
    }
  }
  if (!grammar2.tense) {
    grammar2.tense = res.root.has("#PastTense") ? "PastTense" : "PresentTense";
  }
  grammar2.copula = res.root.has("#Copula");
  grammar2.isInfinitive = isInfinitive(vb3);
  return grammar2;
};
var grammar_default = getGrammar;

// ../../node_modules/compromise/src/3-three/verbs/api/parse/getSubject.js
var shouldSkip = function(last) {
  if (last.length <= 1) {
    return false;
  }
  let obj = last.parse()[0] || {};
  return obj.isSubordinate;
};
var noSubClause = function(before2) {
  let parts = before2.clauses();
  parts = parts.filter((m3, i3) => {
    if (m3.has("^(if|unless|while|but|for|per|at|by|that|which|who|from)")) {
      return false;
    }
    if (i3 > 0 && m3.has("^#Verb . #Noun+$")) {
      return false;
    }
    if (i3 > 0 && m3.has("^#Adverb")) {
      return false;
    }
    return true;
  });
  if (parts.length === 0) {
    return before2;
  }
  return parts;
};
var lastNoun2 = function(vb3) {
  let before2 = vb3.before();
  before2 = noSubClause(before2);
  let nouns = before2.nouns();
  let last = nouns.last();
  let pronoun = last.match("(i|he|she|we|you|they)");
  if (pronoun.found) {
    return pronoun.nouns();
  }
  let det = nouns.if("^(that|this|those)");
  if (det.found) {
    return det;
  }
  if (nouns.found === false) {
    det = before2.match("^(that|this|those)");
    if (det.found) {
      return det;
    }
  }
  last = nouns.last();
  if (shouldSkip(last)) {
    nouns.remove(last);
    last = nouns.last();
  }
  if (shouldSkip(last)) {
    nouns.remove(last);
    last = nouns.last();
  }
  return last;
};
var isPlural3 = function(subj, vb3) {
  if (vb3.has("(are|were|does)")) {
    return true;
  }
  if (subj.has("(those|they|we)")) {
    return true;
  }
  if (subj.found && subj.isPlural) {
    return subj.isPlural().found;
  }
  return false;
};
var getSubject = function(vb3) {
  let subj = lastNoun2(vb3);
  return {
    subject: subj,
    plural: isPlural3(subj, vb3)
  };
};
var getSubject_default = getSubject;

// ../../node_modules/compromise/src/3-three/verbs/api/lib.js
var noop = (vb3) => vb3;
var isPlural4 = (vb3, parsed) => {
  let subj = getSubject_default(vb3, parsed);
  let m3 = subj.subject;
  if (m3.has("i") || m3.has("we")) {
    return true;
  }
  return subj.plural;
};
var wasWere = (vb3, parsed) => {
  let { subject, plural: plural2 } = getSubject_default(vb3, parsed);
  if (plural2 || subject.has("we")) {
    return "were";
  }
  return "was";
};
var isAreAm = function(vb3, parsed) {
  if (vb3.has("were")) {
    return "are";
  }
  let { subject, plural: plural2 } = getSubject_default(vb3, parsed);
  if (subject.has("i")) {
    return "am";
  }
  if (subject.has("we") || plural2) {
    return "are";
  }
  return "is";
};
var doDoes = function(vb3, parsed) {
  let subj = getSubject_default(vb3, parsed);
  let m3 = subj.subject;
  if (m3.has("i") || m3.has("we")) {
    return "do";
  }
  if (subj.plural) {
    return "do";
  }
  return "does";
};
var getTense2 = function(m3) {
  if (m3.has("#Infinitive")) {
    return "Infinitive";
  }
  if (m3.has("#Participle")) {
    return "Participle";
  }
  if (m3.has("#PastTense")) {
    return "PastTense";
  }
  if (m3.has("#Gerund")) {
    return "Gerund";
  }
  if (m3.has("#PresentTense")) {
    return "PresentTense";
  }
  return void 0;
};
var toInf = function(vb3, parsed) {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  let str = parsed.root.text({ keepPunct: false });
  str = toInfinitive3(str, vb3.model, getTense2(vb3));
  if (str) {
    vb3.replace(parsed.root, str);
  }
  return vb3;
};
var noWill = (vb3) => {
  if (vb3.has("will not")) {
    return vb3.replace("will not", "have not");
  }
  return vb3.remove("will");
};

// ../../node_modules/compromise/src/3-three/verbs/api/toJSON.js
var toArray3 = function(m3) {
  if (!m3 || !m3.isView) {
    return [];
  }
  const opts2 = { normal: true, terms: false, text: false };
  return m3.json(opts2).map((s3) => s3.normal);
};
var toText4 = function(m3) {
  if (!m3 || !m3.isView) {
    return "";
  }
  return m3.text("normal");
};
var toInf2 = function(root) {
  const { toInfinitive: toInfinitive3 } = root.methods.two.transform.verb;
  let str = root.text("normal");
  return toInfinitive3(str, root.model, getTense2(root));
};
var toJSON3 = function(vb3) {
  let parsed = parse_default8(vb3);
  vb3 = vb3.clone().toView();
  const info = grammar_default(vb3, parsed);
  return {
    root: parsed.root.text(),
    preAdverbs: toArray3(parsed.adverbs.pre),
    postAdverbs: toArray3(parsed.adverbs.post),
    auxiliary: toText4(parsed.auxiliary),
    negative: parsed.negative.found,
    prefix: toText4(parsed.prefix),
    infinitive: toInf2(parsed.root),
    grammar: info
  };
};
var toJSON_default2 = toJSON3;

// ../../node_modules/compromise/src/3-three/verbs/api/conjugate/toInfinitive.js
var keep3 = { tags: true };
var toInf3 = function(vb3, parsed) {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  let aux = auxiliary.terms().harden();
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (str) {
    vb3.replace(root, str, keep3).tag("Verb").firstTerm().tag("Infinitive");
  }
  if (aux.found) {
    vb3.remove(aux);
  }
  if (parsed.negative.found) {
    if (!vb3.has("not")) {
      vb3.prepend("not");
    }
    let does = doDoes(vb3, parsed);
    vb3.prepend(does);
  }
  vb3.fullSentence().compute(["lexicon", "preTagger", "postTagger", "chunks"]);
  return vb3;
};
var toInfinitive_default3 = toInf3;

// ../../node_modules/compromise/src/3-three/verbs/api/conjugate/toPast.js
var keep4 = { tags: true };
var fns6 = {
  noAux: (vb3, parsed) => {
    if (parsed.auxiliary.found) {
      vb3 = vb3.remove(parsed.auxiliary);
    }
    return vb3;
  },
  // walk->walked
  simple: (vb3, parsed) => {
    const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
    const root = parsed.root;
    if (root.has("#Modal")) {
      return vb3;
    }
    let str = root.text({ keepPunct: false });
    str = toInfinitive3(str, vb3.model, getTense2(root));
    let all4 = conjugate2(str, vb3.model);
    str = all4.PastTense;
    str = str === "been" ? "was" : str;
    if (str === "was") {
      str = wasWere(vb3, parsed);
    }
    if (str) {
      vb3.replace(root, str, keep4);
    }
    return vb3;
  },
  both: function(vb3, parsed) {
    if (parsed.negative.found) {
      vb3.replace("will", "did");
      return vb3;
    }
    vb3 = fns6.simple(vb3, parsed);
    vb3 = fns6.noAux(vb3, parsed);
    return vb3;
  },
  hasHad: (vb3) => {
    vb3.replace("has", "had", keep4);
    return vb3;
  },
  // some verbs have this weird past-tense form
  // drive -> driven, (!drove)
  hasParticiple: (vb3, parsed) => {
    const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
    const root = parsed.root;
    let str = root.text("normal");
    str = toInfinitive3(str, vb3.model, getTense2(root));
    return conjugate2(str, vb3.model).Participle;
  }
};
var forms = {
  // walk -> walked
  "infinitive": fns6.simple,
  // he walks -> he walked
  "simple-present": fns6.simple,
  // he walked
  "simple-past": noop,
  // he will walk -> he walked
  "simple-future": fns6.both,
  // he is walking
  "present-progressive": (vb3) => {
    vb3.replace("are", "were", keep4);
    vb3.replace("(is|are|am)", "was", keep4);
    return vb3;
  },
  // he was walking
  "past-progressive": noop,
  // he will be walking
  "future-progressive": (vb3, parsed) => {
    vb3.match(parsed.root).insertBefore("was");
    vb3.remove("(will|be)");
    return vb3;
  },
  // has walked -> had walked (?)
  "present-perfect": fns6.hasHad,
  // had walked
  "past-perfect": noop,
  // will have walked -> had walked
  "future-perfect": (vb3, parsed) => {
    vb3.match(parsed.root).insertBefore("had");
    if (vb3.has("will")) {
      vb3 = noWill(vb3);
    }
    vb3.remove("have");
    return vb3;
  },
  // has been walking -> had been
  "present-perfect-progressive": fns6.hasHad,
  // had been walking
  "past-perfect-progressive": noop,
  // will have been -> had
  "future-perfect-progressive": (vb3) => {
    vb3.remove("will");
    vb3.replace("have", "had", keep4);
    return vb3;
  },
  // got walked
  "passive-past": (vb3) => {
    vb3.replace("have", "had", keep4);
    return vb3;
  },
  // is being walked  -> 'was being walked'
  "passive-present": (vb3) => {
    vb3.replace("(is|are)", "was", keep4);
    return vb3;
  },
  // will be walked -> had been walked
  "passive-future": (vb3, parsed) => {
    if (parsed.auxiliary.has("will be")) {
      vb3.match(parsed.root).insertBefore("had been");
      vb3.remove("(will|be)");
    }
    if (parsed.auxiliary.has("will have been")) {
      vb3.replace("have", "had", keep4);
      vb3.remove("will");
    }
    return vb3;
  },
  // would be walked -> 'would have been walked'
  "present-conditional": (vb3) => {
    vb3.replace("be", "have been");
    return vb3;
  },
  // would have been walked
  "past-conditional": noop,
  // is going to drink -> was going to drink
  "auxiliary-future": (vb3) => {
    vb3.replace("(is|are|am)", "was", keep4);
    return vb3;
  },
  // used to walk
  "auxiliary-past": noop,
  // we do walk -> we did walk
  "auxiliary-present": (vb3) => {
    vb3.replace("(do|does)", "did", keep4);
    return vb3;
  },
  // must walk -> 'must have walked'
  "modal-infinitive": (vb3, parsed) => {
    if (vb3.has("can")) {
      vb3.replace("can", "could", keep4);
    } else {
      fns6.simple(vb3, parsed);
      vb3.match("#Modal").insertAfter("have").tag("Auxiliary");
    }
    return vb3;
  },
  // must have walked
  "modal-past": noop,
  // wanted to walk
  "want-infinitive": (vb3) => {
    vb3.replace("(want|wants)", "wanted", keep4);
    vb3.remove("will");
    return vb3;
  },
  // started looking
  "gerund-phrase": (vb3, parsed) => {
    parsed.root = parsed.root.not("#Gerund$");
    fns6.simple(vb3, parsed);
    noWill(vb3);
    return vb3;
  }
};
var toPast3 = function(vb3, parsed, form) {
  if (forms.hasOwnProperty(form)) {
    vb3 = forms[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  return vb3;
};
var toPast_default2 = toPast3;

// ../../node_modules/compromise/src/3-three/verbs/api/conjugate/toParticiple.js
var haveHas = function(vb3, parsed) {
  let subj = getSubject_default(vb3, parsed);
  let m3 = subj.subject;
  if (m3.has("(i|we|you)")) {
    return "have";
  }
  if (subj.plural === false) {
    return "has";
  }
  if (m3.has("he") || m3.has("she") || m3.has("#Person")) {
    return "has";
  }
  return "have";
};
var simple = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  if (root.has("#Modal")) {
    return vb3;
  }
  let str = root.text({ keepPunct: false });
  str = toInfinitive3(str, vb3.model, getTense2(root));
  let all4 = conjugate2(str, vb3.model);
  str = all4.Participle || all4.PastTense;
  if (str) {
    vb3 = vb3.replace(root, str);
    let have = haveHas(vb3, parsed);
    vb3.prepend(have).match(have).tag("Auxiliary");
    vb3.remove(auxiliary);
  }
  return vb3;
};
var forms2 = {
  // walk -> walked
  "infinitive": simple,
  // he walks -> he walked
  "simple-present": simple,
  // he walked
  // 'simple-past': noop,
  // he will walk -> he walked
  "simple-future": (vb3, parsed) => vb3.replace("will", haveHas(vb3, parsed)),
  // he is walking
  // 'present-progressive': noop,
  // he was walking
  // 'past-progressive': noop,
  // he will be walking
  // 'future-progressive': noop,
  // has walked -> had walked (?)
  "present-perfect": noop,
  // had walked
  "past-perfect": noop,
  // will have walked -> had walked
  "future-perfect": (vb3, parsed) => vb3.replace("will have", haveHas(vb3, parsed)),
  // has been walking -> had been
  "present-perfect-progressive": noop,
  // had been walking
  "past-perfect-progressive": noop,
  // will have been -> had
  "future-perfect-progressive": noop
  // got walked
  // 'passive-past': noop,
  // is being walked  -> 'was being walked'
  // 'passive-present': noop,
  // will be walked -> had been walked
  // 'passive-future': noop,
  // would be walked -> 'would have been walked'
  // 'present-conditional': noop,
  // would have been walked
  // 'past-conditional': noop,
  // is going to drink -> was going to drink
  // 'auxiliary-future': noop,
  // used to walk
  // 'auxiliary-past': noop,
  // we do walk -> we did walk
  // 'auxiliary-present': noop,
  // must walk -> 'must have walked'
  // 'modal-infinitive': noop,
  // must have walked
  // 'modal-past': noop,
  // wanted to walk
  // 'want-infinitive': noop,
  // started looking
  // 'gerund-phrase': noop,
};
var toPast4 = function(vb3, parsed, form) {
  if (forms2.hasOwnProperty(form)) {
    vb3 = forms2[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  vb3 = simple(vb3, parsed, form);
  vb3.fullSentence().compute(["tagger", "chunks"]);
  return vb3;
};
var toParticiple_default = toPast4;

// ../../node_modules/compromise/src/3-three/verbs/api/conjugate/toPresent.js
var keep5 = { tags: true };
var simple2 = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const root = parsed.root;
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (isPlural4(vb3, parsed) === false) {
    str = conjugate2(str, vb3.model).PresentTense;
  }
  if (root.has("#Copula")) {
    str = isAreAm(vb3, parsed);
  }
  if (str) {
    vb3 = vb3.replace(root, str, keep5);
    vb3.not("#Particle").tag("PresentTense");
  }
  return vb3;
};
var toGerund2 = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const root = parsed.root;
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (isPlural4(vb3, parsed) === false) {
    str = conjugate2(str, vb3.model).Gerund;
  }
  if (str) {
    vb3 = vb3.replace(root, str, keep5);
    vb3.not("#Particle").tag("Gerund");
  }
  return vb3;
};
var vbToInf = (vb3, parsed) => {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const root = parsed.root;
  let str = parsed.root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (str) {
    vb3 = vb3.replace(parsed.root, str, keep5);
  }
  return vb3;
};
var forms3 = {
  // walk
  "infinitive": simple2,
  // he walks -> he walked
  "simple-present": (vb3, parsed) => {
    const { conjugate: conjugate2 } = vb3.methods.two.transform.verb;
    let { root } = parsed;
    if (root.has("#Infinitive")) {
      let subj = getSubject_default(vb3, parsed);
      let m3 = subj.subject;
      if (isPlural4(vb3, parsed) || m3.has("i")) {
        return vb3;
      }
      let str = root.text("normal");
      let pres = conjugate2(str, vb3.model).PresentTense;
      if (str !== pres) {
        vb3.replace(root, pres, keep5);
      }
    } else {
      return simple2(vb3, parsed);
    }
    return vb3;
  },
  // he walked
  "simple-past": simple2,
  // he will walk -> he walked
  "simple-future": (vb3, parsed) => {
    const { root, auxiliary } = parsed;
    if (auxiliary.has("will") && root.has("be")) {
      let str = isAreAm(vb3, parsed);
      vb3.replace(root, str);
      vb3 = vb3.remove("will");
      vb3.replace("not " + str, str + " not");
    } else {
      simple2(vb3, parsed);
      vb3 = vb3.remove("will");
    }
    return vb3;
  },
  // is walking ->
  "present-progressive": noop,
  // was walking -> is walking
  "past-progressive": (vb3, parsed) => {
    let str = isAreAm(vb3, parsed);
    return vb3.replace("(were|was)", str, keep5);
  },
  // will be walking -> is walking
  "future-progressive": (vb3) => {
    vb3.match("will").insertBefore("is");
    vb3.remove("be");
    return vb3.remove("will");
  },
  // has walked ->  (?)
  "present-perfect": (vb3, parsed) => {
    simple2(vb3, parsed);
    vb3 = vb3.remove("(have|had|has)");
    return vb3;
  },
  // had walked -> has walked
  "past-perfect": (vb3, parsed) => {
    let subj = getSubject_default(vb3, parsed);
    let m3 = subj.subject;
    if (isPlural4(vb3, parsed) || m3.has("i")) {
      vb3 = toInf(vb3, parsed);
      vb3.remove("had");
      return vb3;
    }
    vb3.replace("had", "has", keep5);
    return vb3;
  },
  // will have walked -> has walked
  "future-perfect": (vb3) => {
    vb3.match("will").insertBefore("has");
    return vb3.remove("have").remove("will");
  },
  // has been walking
  "present-perfect-progressive": noop,
  // had been walking
  "past-perfect-progressive": (vb3) => vb3.replace("had", "has", keep5),
  // will have been -> has been
  "future-perfect-progressive": (vb3) => {
    vb3.match("will").insertBefore("has");
    return vb3.remove("have").remove("will");
  },
  // got walked -> is walked
  // was walked -> is walked
  // had been walked -> is walked
  "passive-past": (vb3, parsed) => {
    let str = isAreAm(vb3, parsed);
    if (vb3.has("(had|have|has)") && vb3.has("been")) {
      vb3.replace("(had|have|has)", str, keep5);
      vb3.replace("been", "being");
      return vb3;
    }
    return vb3.replace("(got|was|were)", str);
  },
  // is being walked  ->
  "passive-present": noop,
  // will be walked -> is being walked
  "passive-future": (vb3) => {
    vb3.replace("will", "is");
    return vb3.replace("be", "being");
  },
  // would be walked ->
  "present-conditional": noop,
  // would have been walked ->
  "past-conditional": (vb3) => {
    vb3.replace("been", "be");
    return vb3.remove("have");
  },
  // is going to drink -> is drinking
  "auxiliary-future": (vb3, parsed) => {
    toGerund2(vb3, parsed);
    vb3.remove("(going|to)");
    return vb3;
  },
  // used to walk -> is walking
  // did walk -> is walking
  "auxiliary-past": (vb3, parsed) => {
    if (parsed.auxiliary.has("did")) {
      let str = doDoes(vb3, parsed);
      vb3.replace(parsed.auxiliary, str);
      return vb3;
    }
    toGerund2(vb3, parsed);
    vb3.replace(parsed.auxiliary, "is");
    return vb3;
  },
  // we do walk ->
  "auxiliary-present": noop,
  // must walk -> 'must have walked'
  "modal-infinitive": noop,
  // must have walked
  "modal-past": (vb3, parsed) => {
    vbToInf(vb3, parsed);
    return vb3.remove("have");
  },
  // started looking
  "gerund-phrase": (vb3, parsed) => {
    parsed.root = parsed.root.not("#Gerund$");
    simple2(vb3, parsed);
    return vb3.remove("(will|have)");
  },
  // wanted to walk
  "want-infinitive": (vb3, parsed) => {
    let str = "wants";
    if (isPlural4(vb3, parsed)) {
      str = "want";
    }
    vb3.replace("(want|wanted|wants)", str, keep5);
    vb3.remove("will");
    return vb3;
  }
};
var toPresent3 = function(vb3, parsed, form) {
  if (forms3.hasOwnProperty(form)) {
    vb3 = forms3[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  return vb3;
};
var toPresent_default2 = toPresent3;

// ../../node_modules/compromise/src/3-three/verbs/api/conjugate/toFuture.js
var keep6 = { tags: true };
var simple3 = (vb3, parsed) => {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  if (root.has("#Modal")) {
    return vb3;
  }
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (str) {
    vb3 = vb3.replace(root, str, keep6);
    vb3.not("#Particle").tag("Verb");
  }
  vb3.prepend("will").match("will").tag("Auxiliary");
  vb3.remove(auxiliary);
  return vb3;
};
var progressive = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (str) {
    str = conjugate2(str, vb3.model).Gerund;
    vb3.replace(root, str, keep6);
    vb3.not("#Particle").tag("PresentTense");
  }
  vb3.remove(auxiliary);
  vb3.prepend("will be").match("will be").tag("Auxiliary");
  return vb3;
};
var forms4 = {
  // walk ->
  "infinitive": simple3,
  // he walks ->
  "simple-present": simple3,
  // he walked
  "simple-past": simple3,
  // he will walk ->
  "simple-future": noop,
  // is walking ->
  "present-progressive": progressive,
  // was walking ->
  "past-progressive": progressive,
  // will be walking ->
  "future-progressive": noop,
  // has walked ->
  "present-perfect": (vb3) => {
    vb3.match("(have|has)").replaceWith("will have");
    return vb3;
  },
  // had walked ->
  "past-perfect": (vb3) => vb3.replace("(had|has)", "will have"),
  // will have walked ->
  "future-perfect": noop,
  // has been walking
  "present-perfect-progressive": (vb3) => vb3.replace("has", "will have"),
  // had been walking
  "past-perfect-progressive": (vb3) => vb3.replace("had", "will have"),
  // will have been ->
  "future-perfect-progressive": noop,
  // got walked ->
  // was walked ->
  // was being walked ->
  // had been walked ->
  "passive-past": (vb3) => {
    if (vb3.has("got")) {
      return vb3.replace("got", "will get");
    }
    if (vb3.has("(was|were)")) {
      vb3.replace("(was|were)", "will be");
      return vb3.remove("being");
    }
    if (vb3.has("(have|has|had) been")) {
      return vb3.replace("(have|has|had) been", "will be");
    }
    return vb3;
  },
  // is being walked  ->
  "passive-present": (vb3) => {
    vb3.replace("being", "will be");
    vb3.remove("(is|are|am)");
    return vb3;
  },
  // will be walked ->
  "passive-future": noop,
  // would be walked ->
  "present-conditional": (vb3) => vb3.replace("would", "will"),
  // would have been walked ->
  "past-conditional": (vb3) => vb3.replace("would", "will"),
  // is going to drink ->
  "auxiliary-future": noop,
  // used to walk -> is walking
  // did walk -> is walking
  "auxiliary-past": (vb3) => {
    if (vb3.has("used") && vb3.has("to")) {
      vb3.replace("used", "will");
      return vb3.remove("to");
    }
    vb3.replace("did", "will");
    return vb3;
  },
  // we do walk ->
  // he does walk ->
  "auxiliary-present": (vb3) => {
    return vb3.replace("(do|does)", "will");
  },
  // must walk ->
  "modal-infinitive": noop,
  // must have walked
  "modal-past": noop,
  // started looking
  "gerund-phrase": (vb3, parsed) => {
    parsed.root = parsed.root.not("#Gerund$");
    simple3(vb3, parsed);
    return vb3.remove("(had|have)");
  },
  // wanted to walk
  "want-infinitive": (vb3) => {
    vb3.replace("(want|wants|wanted)", "will want");
    return vb3;
  }
};
var toFuture2 = function(vb3, parsed, form) {
  if (vb3.has("will") || vb3.has("going to")) {
    return vb3;
  }
  if (forms4.hasOwnProperty(form)) {
    vb3 = forms4[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  return vb3;
};
var toFuture_default2 = toFuture2;

// ../../node_modules/compromise/src/3-three/verbs/api/conjugate/toGerund.js
var keep7 = { tags: true };
var toGerund3 = function(vb3, parsed) {
  const { toInfinitive: toInfinitive3, conjugate: conjugate2 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  if (vb3.has("#Gerund")) {
    return vb3;
  }
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  let gerund = conjugate2(str, vb3.model).Gerund;
  if (gerund) {
    let aux = isAreAm(vb3, parsed);
    vb3.replace(root, gerund, keep7);
    vb3.remove(auxiliary);
    vb3.prepend(aux);
  }
  vb3.replace("not is", "is not");
  vb3.replace("not are", "are not");
  vb3.fullSentence().compute(["tagger", "chunks"]);
  return vb3;
};
var toGerund_default = toGerund3;

// ../../node_modules/compromise/src/3-three/verbs/api/conjugate/toNegative.js
var keep8 = { tags: true };
var doesNot = function(vb3, parsed) {
  let does = doDoes(vb3, parsed);
  vb3.prepend(does + " not");
  return vb3;
};
var isWas = function(vb3) {
  let m3 = vb3.match("be");
  if (m3.found) {
    m3.prepend("not");
    return vb3;
  }
  m3 = vb3.match("(is|was|am|are|will|were)");
  if (m3.found) {
    m3.append("not");
    return vb3;
  }
  return vb3;
};
var hasCopula = (vb3) => vb3.has("(is|was|am|are|will|were|be)");
var forms5 = {
  // he walks' -> 'he does not walk'
  "simple-present": (vb3, parsed) => {
    if (hasCopula(vb3) === true) {
      return isWas(vb3, parsed);
    }
    vb3 = toInf(vb3, parsed);
    vb3 = doesNot(vb3, parsed);
    return vb3;
  },
  // 'he walked' -> 'he did not walk'
  "simple-past": (vb3, parsed) => {
    if (hasCopula(vb3) === true) {
      return isWas(vb3, parsed);
    }
    vb3 = toInf(vb3, parsed);
    vb3.prepend("did not");
    return vb3;
  },
  // walk! -> 'do not walk'
  "imperative": (vb3) => {
    vb3.prepend("do not");
    return vb3;
  },
  // walk -> does not walk
  "infinitive": (vb3, parsed) => {
    if (hasCopula(vb3) === true) {
      return isWas(vb3, parsed);
    }
    return doesNot(vb3, parsed);
  },
  "passive-past": (vb3) => {
    if (vb3.has("got")) {
      vb3.replace("got", "get", keep8);
      vb3.prepend("did not");
      return vb3;
    }
    let m3 = vb3.match("(was|were|had|have)");
    if (m3.found) {
      m3.append("not");
    }
    return vb3;
  },
  "auxiliary-past": (vb3) => {
    if (vb3.has("used")) {
      vb3.prepend("did not");
      return vb3;
    }
    let m3 = vb3.match("(did|does|do)");
    if (m3.found) {
      m3.append("not");
    }
    return vb3;
  },
  // wants to walk
  "want-infinitive": (vb3, parsed) => {
    vb3 = doesNot(vb3, parsed);
    vb3 = vb3.replace("wants", "want", keep8);
    return vb3;
  }
};
var toNegative2 = function(vb3, parsed, form) {
  if (vb3.has("#Negative")) {
    return vb3;
  }
  if (forms5.hasOwnProperty(form)) {
    vb3 = forms5[form](vb3, parsed);
    return vb3;
  }
  let m3 = vb3.matchOne("be");
  if (m3.found) {
    m3.prepend("not");
    return vb3;
  }
  if (hasCopula(vb3) === true) {
    return isWas(vb3, parsed);
  }
  m3 = vb3.matchOne("(will|had|have|has|did|does|do|#Modal)");
  if (m3.found) {
    m3.append("not");
    return vb3;
  }
  return vb3;
};
var toNegative_default = toNegative2;

// ../../node_modules/compromise/src/3-three/verbs/api/api.js
var api18 = function(View2) {
  class Verbs extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Verbs";
    }
    parse(n3) {
      return this.getNth(n3).map(parse_default8);
    }
    json(opts2, n3) {
      let m3 = this.getNth(n3);
      let arr = m3.map((vb3) => {
        let json = vb3.toView().json(opts2)[0] || {};
        json.verb = toJSON_default2(vb3);
        return json;
      }, []);
      return arr;
    }
    subjects(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        return getSubject_default(vb3, parsed).subject;
      });
    }
    adverbs(n3) {
      return this.getNth(n3).map((vb3) => vb3.match("#Adverb"));
    }
    isSingular(n3) {
      return this.getNth(n3).filter((vb3) => {
        return getSubject_default(vb3).plural !== true;
      });
    }
    isPlural(n3) {
      return this.getNth(n3).filter((vb3) => {
        return getSubject_default(vb3).plural === true;
      });
    }
    isImperative(n3) {
      return this.getNth(n3).filter((vb3) => vb3.has("#Imperative"));
    }
    toInfinitive(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        return toInfinitive_default3(vb3, parsed, info.form);
      });
    }
    toPresentTense(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toPresent_default2(vb3, parsed, info.form);
      });
    }
    toPastTense(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toPast_default2(vb3, parsed, info.form);
      });
    }
    toFutureTense(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toFuture_default2(vb3, parsed, info.form);
      });
    }
    toGerund(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toGerund_default(vb3, parsed, info.form);
      });
    }
    toPastParticiple(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toParticiple_default(vb3, parsed, info.form);
      });
    }
    conjugate(n3) {
      const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = this.world.methods.two.transform.verb;
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.form === "imperative") {
          info.form = "simple-present";
        }
        let inf = parsed.root.text("normal");
        if (!parsed.root.has("#Infinitive")) {
          let tense = getTense2(parsed.root);
          inf = toInfinitive3(inf, vb3.model, tense) || inf;
        }
        return conjugate2(inf, vb3.model);
      }, []);
    }
    /** return only verbs with 'not'*/
    isNegative() {
      return this.if("#Negative");
    }
    /**  return only verbs without 'not'*/
    isPositive() {
      return this.ifNo("#Negative");
    }
    /** remove 'not' from these verbs */
    toPositive() {
      let m3 = this.match("do not #Verb");
      if (m3.found) {
        m3.remove("do not");
      }
      return this.remove("#Negative");
    }
    toNegative(n3) {
      return this.getNth(n3).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        return toNegative_default(vb3, parsed, info.form);
      });
    }
    // overloaded - keep Verb class
    update(pointer) {
      let m3 = new Verbs(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  Verbs.prototype.toPast = Verbs.prototype.toPastTense;
  Verbs.prototype.toPresent = Verbs.prototype.toPresentTense;
  Verbs.prototype.toFuture = Verbs.prototype.toFutureTense;
  View2.prototype.verbs = function(n3) {
    let vb3 = find_default6(this);
    vb3 = vb3.getNth(n3);
    return new Verbs(this.document, vb3.pointer);
  };
};
var api_default21 = api18;

// ../../node_modules/compromise/src/3-three/verbs/plugin.js
var plugin_default28 = {
  api: api_default21
};

// ../../node_modules/compromise/src/3-three/coreference/compute/lib.js
var findChained = function(want, s3) {
  let m3 = s3.match(want);
  if (m3.found) {
    let ref = m3.pronouns().refersTo();
    if (ref.found) {
      return ref;
    }
  }
  return s3.none();
};
var prevSentence = function(m3) {
  if (!m3.found) {
    return m3;
  }
  let [n3] = m3.fullPointer[0];
  if (n3 && n3 > 0) {
    return m3.update([[n3 - 1]]);
  }
  return m3.none();
};

// ../../node_modules/compromise/src/3-three/coreference/compute/findPerson.js
var byGender = function(ppl, gender) {
  if (gender === "m") {
    return ppl.filter((m3) => !m3.presumedFemale().found);
  } else if (gender === "f") {
    return ppl.filter((m3) => !m3.presumedMale().found);
  }
  return ppl;
};
var getPerson = function(s3, gender) {
  let people = s3.people();
  people = byGender(people, gender);
  if (people.found) {
    return people.last();
  }
  people = s3.nouns("#Actor");
  if (people.found) {
    return people.last();
  }
  if (gender === "f") {
    return findChained("(she|her|hers)", s3);
  }
  if (gender === "m") {
    return findChained("(he|him|his)", s3);
  }
  return s3.none();
};
var findPerson_default = getPerson;

// ../../node_modules/compromise/src/3-three/coreference/compute/findThey.js
var getThey = function(s3) {
  let nouns = s3.nouns();
  let things = nouns.isPlural().notIf("#Pronoun");
  if (things.found) {
    return things.last();
  }
  let chain = findChained("(they|their|theirs)", s3);
  if (chain.found) {
    return chain;
  }
  things = nouns.match("(somebody|nobody|everybody|anybody|someone|noone|everyone|anyone)");
  if (things.found) {
    return things.last();
  }
  return s3.none();
};
var findThey_default = getThey;

// ../../node_modules/compromise/src/3-three/coreference/compute/index.js
var addReference = function(pron, m3) {
  if (m3 && m3.found) {
    let term = pron.docs[0][0];
    term.reference = m3.ptrs[0];
  }
};
var stepBack = function(m3, cb) {
  let s3 = m3.before();
  let res = cb(s3);
  if (res.found) {
    return res;
  }
  s3 = prevSentence(m3);
  res = cb(s3);
  if (res.found) {
    return res;
  }
  s3 = prevSentence(s3);
  res = cb(s3);
  if (res.found) {
    return res;
  }
  return m3.none();
};
var coreference = function(view) {
  let pronouns = view.pronouns().if("(he|him|his|she|her|hers|they|their|theirs|it|its)");
  pronouns.forEach((pron) => {
    let res = null;
    if (pron.has("(he|him|his)")) {
      res = stepBack(pron, (m3) => findPerson_default(m3, "m"));
    } else if (pron.has("(she|her|hers)")) {
      res = stepBack(pron, (m3) => findPerson_default(m3, "f"));
    } else if (pron.has("(they|their|theirs)")) {
      res = stepBack(pron, findThey_default);
    }
    if (res && res.found) {
      addReference(pron, res);
    }
  });
};
var compute_default12 = coreference;

// ../../node_modules/compromise/src/3-three/coreference/api/pronouns.js
var api19 = function(View2) {
  class Pronouns extends View2 {
    constructor(document, pointer, groups) {
      super(document, pointer, groups);
      this.viewType = "Pronouns";
    }
    hasReference() {
      this.compute("coreference");
      return this.filter((m3) => {
        let term = m3.docs[0][0];
        return term.reference;
      });
    }
    // get the noun-phrase this pronoun refers to
    refersTo() {
      this.compute("coreference");
      return this.map((m3) => {
        if (!m3.found) {
          return m3.none();
        }
        let term = m3.docs[0][0];
        if (term.reference) {
          return m3.update([term.reference]);
        }
        return m3.none();
      });
    }
    // overloaded - keep Numbers class
    update(pointer) {
      let m3 = new Pronouns(this.document, pointer);
      m3._cache = this._cache;
      return m3;
    }
  }
  View2.prototype.pronouns = function(n3) {
    let m3 = this.match("#Pronoun");
    m3 = m3.getNth(n3);
    return new Pronouns(m3.document, m3.pointer);
  };
};
var pronouns_default = api19;

// ../../node_modules/compromise/src/3-three/coreference/plugin.js
var plugin_default29 = {
  compute: { coreference: compute_default12 },
  api: pronouns_default
};

// ../../node_modules/compromise/src/three.js
two_default.plugin(plugin_default18);
two_default.plugin(plugin_default19);
two_default.plugin(plugin_default20);
two_default.plugin(plugin_default29);
two_default.plugin(plugin_default21);
two_default.plugin(plugin_default22);
two_default.plugin(plugin_default23);
two_default.plugin(plugin_default24);
two_default.plugin(plugin_default25);
two_default.plugin(plugin_default26);
two_default.plugin(plugin_default27);
two_default.plugin(plugin_default28);
var three_default = two_default;
export {
  three_default as default
};
//# sourceMappingURL=compromise.js.map
